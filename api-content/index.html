{"posts":[{"title":"教书先生API","content":" 教书先生博客：https://blog.oioweb.cn/ api网址：https://api.oioweb.cn/ api QQ信息获取：解析QQ昵称,邮箱,头像 备案查询：查询域名备案信息 短网址生成：可生成搜狐,腾讯,suo等短网址 超级Ping：支持移动、电信、联通、香港延迟检测！ 网站随机背景图：随机返回一张网站随机背景图 域名报红检测：检测在微信QQ是否报红 污话&amp;情话：不试试怎么知道你不行？ 简易版天气：获取当前地区的天气信息 随机毒汤：随机输出一句扎心的话 随机一言：随机输出一句话 快递查询：查询快递物流信息 精神语录：My name is 精神小伙 扫码取QQSkey：获取QQskey 做你自己想做的事情 网易云热评墙：你的故事在这里 二维码生成：可选很多参数进行生成 短网址还原：还原任何短网址的真实URL 搜索引擎收录量查询：查询百度，搜狗，360收录量 域名注册查询：查询域名是否被注册 历史上的今天：今天发生在历史的那些事！ AI垃圾分类：使用AI对垃圾进行分类 IP归属地查询：查询IP详细信息 QQ会员信息：查看QQ等级和成长值信息 菜谱：还不会做菜的你快来试试吧！ 图片鉴黄识别：对图片进行鉴黄检测 垃圾分类：你是什么垃圾? 文字转语音：把一段文字转换为音乐输出 必应每日一图：返回必应最近的7张图 中通快递：中通快递物流查询接口 QQ业务开通查询：查询QQ开通的业务 天气接口：支持三种方式调用哦 圆通快递：查询圆通快递物流信息 图片文字识别：识别图片上的文字信息 QQ名片配图：支持七种类型 QQ收藏解析：解析QQ收藏里面的内容 自动仿站API：输入网址即可一键扒站 二维码解析：解析二维码内容 全民k歌：解析全民k歌歌曲链接 同IP站查询：查询相同IP的网站 网站信息查询：可以获取网站标题，关键字，描述信息 更多api接口正在更新... use 转到API接口网址 查看文档调用 如果你打算使用Python来调用接口，你可以看Python处理JSON格式的数据接口 这篇文章 ","link":"https://Wangrongsheng.github.io/post/BL09rHUXi/"},{"title":"爬虫案例平台","content":" 案例列表 本案例平台自爬数据、自建页面、自接反爬，案例稳定后永不过期，适合教学与练习。 SSR 网站 ssr1：猫眼电影数据网站，数据通过服务端渲染，适合基本爬虫练习。 ssr2：HTTPS 无效证书网站，适合做跳过验证 HTTPS 案例。 ssr3：HTTP Basic Authentication 网站，适合做 HTTP 认证案例，用户名密码均为 admin。 ssr4：每个响应增加了 5 秒延迟，适合测试慢速网站爬取或做爬取速度测试，减少本身网速干扰。 SPA 网站 spa1：猫眼电影数据网站，数据通过 Ajax 加载，页面动态渲染，适合 Ajax 分析和动态页面渲染爬取。 spa2：猫眼电影数据网站，数据通过 Ajax 加载，数据接口参数加密且有时间限制，适合动态页面渲染爬取或 JavaScript 逆向分析。 spa3：猫眼电影数据网站，数据通过 Ajax 加载，无页码翻页，适合 Ajax 分析和动态页面渲染抓取。 spa4：新闻网站索引，数据通过 Ajax 加载，无页码翻页，适合 Ajax 分析和动态页面渲染抓取以及智能页面提取分析。 spa5：豆瓣图书网站，数据通过 Ajax 加载，有翻页，无反爬，适合大批量动态页面渲染抓取。 spa6：电影数据网站，数据通过 Ajax 加载，数据接口参数加密且有时间限制，源码经过混淆，适合 JavaScript 逆向分析。 验证码网站 captcha1：对接滑动拼图验证码，适合滑动拼图验证码分析处理。 captcha2：对接图标点选验证码，适合图标点选验证码分析处理。 captcha3：对接图文点选验证码，适合图文点选验证码分析处理。 captcha4：对接语序分析验证码，适合语序分析验证码分析处理。 captcha5：对接空间推理验证码，适合空间推理验证码分析处理。 captcha6：对接九宫格识图验证码，适合九宫格识图验证码分析处理。 模拟登录网站 login1：登录时用户名和密码经过加密处理，适合 JavaScript 逆向分析。 login2：对接 Session + Cookies 模拟登录，适合用作 Session + Cookies 模拟登录练习。 login3：对接 JWT 模拟登录方式，适合用作 JWT 模拟登录练习。 反爬型网站 antispider1：WebDriver 反爬网站，检测到 WebDriver 就不显示页面。 antispider2：对接 User-Agent 反爬，检测到常见爬虫 User-Agent 就会拒绝响应，适合用作 User-Agent 反爬练习。 antispider3：对接文字偏移反爬，所见顺序并不一定和源码顺序一致，适合用作文字偏移反爬练习。 antispider4：对接字体文件反爬，显示的内容并不在 HTML 内，而是隐藏在字体文件，设置了文字映射表，适合用作字体反爬练习。 antispider5：限制 IP 访问频率为最多 1 秒一个，如果过多则会封禁 IP。 App app1：最基本的 App 案例，数据通过接口加载，无反爬，无任何加密参数，适合做抓包分析和请求模拟。 app2：设置了接口请求不走系统代理，因此无法直接抓包，适合做抓包特殊处理。 app3：对系统代理进行了检测，如果设置了代理则无法正常请求数据，适合做抓包特殊处理。 app4：设置了 SSL Pining，如果设置了非法证书则无法正常请求数据，适合做反 SSL Pining 处理。 app5：接口增加了加密参数，适合做抓包实时处理或可视化爬取或逆向分析。 app6：接口增加了加密参数，同时对源码进行了混淆，适合做抓包实时处理或可视化爬取或逆向分析。 app7：接口增加了加密参数，同时对安装包进行了加固处理，适合做抓包实时处理或可视化爬取或逆向分析。 暂且是这么多，后续还会继续增加，大家可以试着爬爬看。 汇总链接 为了方便，专门申请了一个域名，scrape.center，意思名为「爬取中心」，似乎听起来意义上还说的过去？ 案例平台首页 URL：https://scrape.center，截图如下： ","link":"https://Wangrongsheng.github.io/post/qQNn4D7fw/"},{"title":"基于矩阵分解的推荐算法","content":" 描述 我们都熟知在一些软件中常常有评分系统，但并不是所有的用户user都会对项目item进行评分，因此评分系统所收集到的用户评分信息必然是不完整的矩阵。那如何跟据这个不完整矩阵中已有的评分来预测未知评分呢。使用矩阵分解的思想很好地解决了这一问题。 假如我们现在有一个用户-项目的评分矩阵R(n，m)是n行m列的矩阵，n表示user个数，m行表示item个数 i1 i2 i3 i4 u1 5 3 - 1 u2 4 - - 1 u3 1 1 - 5 u4 1 - - 4 u5 - 1 5 4 其中，u1⋯u5表示的是5个不同的用户，I1⋯i4表示的是4个不同的商品，这样便构成了用户-商品矩阵，在该矩阵中，有用户对每一件商品的打分，其中“-”表示的是用户未对该商品进行打分。 在推荐系统中有一类问题是对未打分的商品进行评分的预测。 基于矩阵分解的推荐算法 矩阵分解的一般形式 矩阵分解是指将一个矩阵分解成两个或者多个矩阵的乘积。对于上述的用户-商品矩阵(评分矩阵)，记为 Rm×nR_{m\\times n}Rm×n​ 。可以将其分解成两个或者多个矩阵的乘积，假设分解成两个矩阵 Pm×kP_{m\\times k}Pm×k​ 和 Qk×nQ_{k\\times n}Qk×n​ ，我们要使得矩阵Pm×kP_{m\\times k}Pm×k​ 和 Qk×nQ_{k\\times n}Qk×n​的乘积能够还原原始的矩阵Rm×nR_{m\\times n}Rm×n​： Rm×n≈Pm×k×Qk×n=R^m×nR_{m\\times n}\\approx P_{m\\times k}\\times Q_{k\\times n}=\\hat{R}_{m\\times n} Rm×n​≈Pm×k​×Qk×n​=R^m×n​ 其中，矩阵 Pm×kP_{m\\times k}Pm×k​ 表示的是m个用户与k个主题之间的关系，而矩阵Qk×nQ_{k\\times n}Qk×n​表示的是kkk个主题与nnn个商品之间的关系。 利用矩阵分解进行预测 在上述的矩阵分解的过程中，将原始的评分矩阵Rm×nR_{m\\times n}Rm×n​分解成两个矩阵Pm×kP_{m\\times k}Pm×k​ 和 Qk×nQ_{k\\times n}Qk×n​的乘积： Rm×n≈Pm×k×Qk×n=R^m×nR_{m\\times n}\\approx P_{m\\times k}\\times Q_{k\\times n}=\\hat{R}_{m\\times n} Rm×n​≈Pm×k​×Qk×n​=R^m×n​ 那么接下来的问题是如何求解矩阵Pm×kP_{m\\times k}Pm×k​ 和 Qk×nQ_{k\\times n}Qk×n​的每一个元素，可以将这个问题转化成机器学习中的回归问题进行求解。 损失函数 可以使用原始的评分矩阵Rm×nR_{m\\times n}Rm×n​与重新构建的评分矩阵R^m×n\\hat{R}_{m\\times n}R^m×n​之间的误差的平方作为损失函数，即： ei,j2=(ri,j−r^i,j)2=(ri,j−∑k=1Kpi,kqk,j)2e_{i,j}^2=\\left ( r_{i,j}-\\hat{r}_{i,j} \\right )^2=\\left (r_{i,j}-\\sum_{k=1}^{K}p_{i,k}q_{k,j} \\right )^2ei,j2​=(ri,j​−r^i,j​)2=(ri,j​−∑k=1K​pi,k​qk,j​)2 最终，需要求解所有的非“-”项的损失之和的最小值： min loss=∑ri,j≠−ei,j2min\\; loss= \\sum_{r_{i,j}\\neq -}e_{i,j}^2 minloss=ri,j​​=−∑​ei,j2​ 损失函数的求解 对于上述的平方损失函数，可以通过梯度下降法求解，梯度下降法的核心步骤是 求解损失函数的负梯度： ∂∂pi,kei,j2=−2(ri,j−∑k=1Kpi,kqk,j)qk,j=−2ei,jqk,j\\frac{\\partial }{\\partial p_{i,k}}e_{i,j}^2=-2\\left ( r_{i,j}-\\sum_{k=1}^{K}p_{i,k}q_{k,j} \\right )q_{k,j}=-2e_{i,j}q_{k,j}∂pi,k​∂​ei,j2​=−2(ri,j​−∑k=1K​pi,k​qk,j​)qk,j​=−2ei,j​qk,j​ ∂∂qk,jei,j2=−2(ri,j−∑k=1Kpi,kqk,j)pi,k=−2ei,jpi,k\\frac{\\partial }{\\partial q_{k,j}}e_{i,j}^2=-2\\left ( r_{i,j}-\\sum_{k=1}^{K}p_{i,k}q_{k,j} \\right )p_{i,k}=-2e_{i,j}p_{i,k}∂qk,j​∂​ei,j2​=−2(ri,j​−∑k=1K​pi,k​qk,j​)pi,k​=−2ei,j​pi,k​ 根据负梯度的方向更新变量： pi,k′=pi,k−α∂∂pi,kei,j2=pi,k+2αei,jqk,j{p_{i,k}}&#x27;=p_{i,k}-\\alpha \\frac{\\partial }{\\partial p_{i,k}}e_{i,j}^2=p_{i,k}+2\\alpha e_{i,j}q_{k,j}pi,k​′=pi,k​−α∂pi,k​∂​ei,j2​=pi,k​+2αei,j​qk,j​ qk,j′=qk,j−α∂∂qk,jei,j2=qk,j+2αei,jpi,k{q_{k,j}}&#x27;=q_{k,j}-\\alpha \\frac{\\partial }{\\partial q_{k,j}}e_{i,j}^2=q_{k,j}+2\\alpha e_{i,j}p_{i,k}qk,j​′=qk,j​−α∂qk,j​∂​ei,j2​=qk,j​+2αei,j​pi,k​ 通过迭代，直到算法最终收敛。 加入正则项的损失函数即求解方法 通常在求解的过程中，为了能够有较好的泛化能力，会在损失函数中加入正则项，以对参数进行约束，加入L2L_2L2​正则的损失函数为： Ei,j2=(ri,j−∑k=1Kpi,kqk,j)2+β2∑k=1K(pi,k2+qk,j2)E_{i,j}^2=\\left (r_{i,j}-\\sum_{k=1}^{K}p_{i,k}q_{k,j} \\right )^2+\\frac{\\beta }{2}\\sum_{k=1}^{K}\\left ( p_{i,k}^2+q_{k,j}^2 \\right )Ei,j2​=(ri,j​−∑k=1K​pi,k​qk,j​)2+2β​∑k=1K​(pi,k2​+qk,j2​) 利用梯度下降法的求解过程为： 求解损失函数的负梯度： ∂∂pi,kEi,j2=−2(ri,j−∑k=1Kpi,kqk,j)qk,j+βpi,k=−2ei,jqk,j+βpi,k\\frac{\\partial }{\\partial p_{i,k}}E_{i,j}^2=-2\\left ( r_{i,j}-\\sum_{k=1}^{K}p_{i,k}q_{k,j} \\right )q_{k,j}+\\beta p_{i,k}=-2e_{i,j}q_{k,j}+\\beta p_{i,k}∂pi,k​∂​Ei,j2​=−2(ri,j​−∑k=1K​pi,k​qk,j​)qk,j​+βpi,k​=−2ei,j​qk,j​+βpi,k​ ∂∂qk,jEi,j2=−2(ri,j−∑k=1Kpi,kqk,j)pi,k+βqk,j=−2ei,jpi,k+βqk,j\\frac{\\partial }{\\partial q_{k,j}}E_{i,j}^2=-2\\left ( r_{i,j}-\\sum_{k=1}^{K}p_{i,k}q_{k,j} \\right )p_{i,k}+\\beta q_{k,j}=-2e_{i,j}p_{i,k}+\\beta q_{k,j}∂qk,j​∂​Ei,j2​=−2(ri,j​−∑k=1K​pi,k​qk,j​)pi,k​+βqk,j​=−2ei,j​pi,k​+βqk,j​ 根据负梯度的方向更新变量： pi,k′=pi,k−α(∂∂pi,kei,j2+βpi,k)=pi,k+α(2ei,jqk,j−βpi,k){p_{i,k}}&#x27;=p_{i,k}-\\alpha \\left ( \\frac{\\partial }{\\partial p_{i,k}}e_{i,j}^2+\\beta p_{i,k} \\right )=p_{i,k}+\\alpha \\left ( 2e_{i,j}q_{k,j}-\\beta p_{i,k} \\right )pi,k​′=pi,k​−α(∂pi,k​∂​ei,j2​+βpi,k​)=pi,k​+α(2ei,j​qk,j​−βpi,k​) qk,j′=qk,j−α(∂∂qk,jei,j2+βqk,j)=qk,j+α(2ei,jpi,k−βqk,j){q_{k,j}}&#x27;=q_{k,j}-\\alpha \\left ( \\frac{\\partial }{\\partial q_{k,j}}e_{i,j}^2+\\beta q_{k,j} \\right )=q_{k,j}+\\alpha \\left ( 2e_{i,j}p_{i,k}-\\beta q_{k,j} \\right )qk,j​′=qk,j​−α(∂qk,j​∂​ei,j2​+βqk,j​)=qk,j​+α(2ei,j​pi,k​−βqk,j​) 通过迭代，直到算法最终收敛。 预测 利用上述的过程，我们可以得到矩阵Pm×kP_{m\\times k}Pm×k​ 和 Qk×nQ_{k\\times n}Qk×n​，这样便可以为用户iii对商品jjj进行打分： ∑k=1Kpi,kqk,j\\sum_{k=1}^{K}p_{i,k}q_{k,j} k=1∑K​pi,k​qk,j​ 代码实现 import numpy as np from math import pow import matplotlib.pyplot as plt %matplotlib inline def mf(R,P,Q,K): alpha = 0.0002 beta = 0.02 times = 5000 eplison = 0.001 result = [] #将矩阵Q进行转置 Q = Q.T #将生成的矩阵相乘 for time in range(times): #求R尖的值 for i in range(len(R)): for j in range(len(R[i])): eij = R[i][j] - np.dot(P[i,:],Q[:,j]) for k in range(K): P[i][k] = P[i][k] + 2*alpha*eij*Q[k][j] Q[k][j] = Q[k][j] + 2*alpha*eij*P[i][k] eR = np.dot(P,Q) #求eij的平方 eij_2 = 0 for i in range(len(R)): for j in range(len(R[i])): for k in range(K): eij_2 = eij_2 + pow((R[i][j] - np.dot(P[i,:],Q[:,j])),2) + 0.5*beta*(pow(P[i][k],2))+pow(Q[k][j],2) result.append(eij_2) if eij_2 &lt; eplison: break return P,Q.T,result def main(): R = [ [5,3,0,1], [4,0,0,1], [1,1,0,5], [1,0,0,4], [0,1,5,4] ] #将R列表转化为矩阵 R = np.array(R) #获取该矩阵的大小 N = len(R) M = len(R[0]) print(N) print(M) ''' 如何预测缺失的评分呢？对于缺失的评分，可以转化为基于机器学习的回归问题，也就是连续值的预测， 对于矩阵分解有如下式子，R是类似图1的评分矩阵，假设N*M维(N表示行数，M表示列数)，可以分解为P跟Q矩阵， 其中P矩阵维度N*K，P矩阵维度K*M。 对于P,Q矩阵的解释，直观上，P矩阵是N个用户对K个主题的关系，Q矩阵是K个主题跟M个物品的关系，至于K个 主题具体是什么，在算法里面K是一个参数，需要调节的，通常10~100之间。 ''' K = 2 P = np.random.rand(N,K) Q = np.random.rand(M,K) #调用矩阵分解的函数 mf_P,mf_Q,result = mf(R,P,Q,K) print(&quot;原始矩阵:&quot;,R) mf_R = np.dot(mf_P,mf_Q.T) print(&quot;经过MF后:&quot;,mf_R) #做出图像 for t in range(5000): plt.scatter(t,result[t]) plt.show() main() ","link":"https://Wangrongsheng.github.io/post/4QQ6rxiI0/"},{"title":"为Gridea主题添加Live2D看板娘","content":" 概要 看到别人的网站有看板娘，但是Gridea并没有特别完整的解决方案，便在Github上寻找相关的代码，看到项目：live2d-widget ，便稍作修改，就实现将看板娘本地化到主题中，需要改动的地方很少。 效果预览：https://sqdxwz.top 操作方法 直接添加live2d（不可选） 从Github上下载或clone repo，地址：Live2D For Gridea ，修改文件夹名称为live2d 。 将文件以文件夹形式放入到\\主题\\assets\\media 。 将下面的代码加入 index.ejs的&lt;head&gt;或 &lt;body&gt;之间保存。 &lt;script src=&quot;./media/live2d/autoload.js&quot;&gt;&lt;/script&gt; 在Gridea中预览添加完成后的效果。 在主题中添加开启按钮（可选） 在config.json最后添加： { &quot;name&quot;: &quot;Live2D&quot;, &quot;label&quot;: &quot;Live2D看板娘&quot;, &quot;group&quot;: &quot;Live2D&quot;, &quot;value&quot;: true, &quot;type&quot;: &quot;switch&quot;, &quot;note&quot;: &quot;若不需要，可关闭以加快页面加载速度&quot; } &lt;head&gt;或 &lt;body&gt;间的代码更改为： &lt;% if (site.customConfig.Live2D){ %&gt; &lt;script src=&quot;./media/live2d/autoload.js&quot;&gt;&lt;/script&gt; &lt;% } %&gt; 其它live2d自定义 在waifu-tips.json和waifu-tips.js中可以自定义看板娘的文字内容，按需更改。 ","link":"https://Wangrongsheng.github.io/post/K8j0WpePD/"},{"title":"更换pip源到国内镜像","content":" pip国内的一些镜像 阿里云 https://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣(douban) http://pypi.douban.com/simple/ 清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/ 中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/ 修改源方法 临时使用 可以在使用pip的时候在后面加上-i参数，指定pip源： pip install scrapy -i https://pypi.tuna.tsinghua.edu.cn/simple 永久修改 Linux 修改 ~/.pip/pip.conf (没有就创建一个)， 内容如下： [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple Windows 直接在user目录中创建一个pip目录，如：C:\\Users\\xx\\pip，新建文件pip.ini，内容如下： [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple ","link":"https://Wangrongsheng.github.io/post/T9SyylFjR/"},{"title":"查看或者修改本地 Git 用户名和邮箱地址","content":" 用户名 和 邮箱地址 是本地 Git 客户端的一个变量，当你安装 Git 后首先要做的事情就是设置你的 用户名 和 邮箱地址 ，因为每次 Git 提交都会使用这个 用户名 和 邮箱地址 来记录提交信息，下面分享一下本地 Git 如何查看 / 修改 用户名 和 邮箱地址 。 查看用户名和邮箱地址 打开终端，分别输入以下命令即可查看 用户名 和 邮箱地址 。 //查看用户名 git config user.name //查看邮箱地址 git config user.email 修改用户名和邮箱地址 这个 用户名 和 邮箱地址 的设置是全局的，所有 Git 仓库的提交都会使用这个 用户名 和 邮箱地址 。 打开终端，分别输入以下命令即可修改 用户名 和 邮箱地址 。 //修改用户名，xxx 处填写你的用户名 git config --global user.name &quot;xxx&quot; //修改邮箱地址，xxx 处填写你的邮箱地址 git config --global user.email &quot;xxx&quot; 修改指定项目的用户名和邮箱地址 如果你希望在一个特定的项目中使用不同的用户名和邮箱地址来提交，可以使用下面的方法单独设置用户名和邮箱地址，如果不设置就会默认使用上面全局设置的用户名和邮箱地址` 。 打开终端 cd 到指定项目的仓库下，分别输入以下命令即可单独修改 用户名 和 邮箱地址 。 //修改用户名，xxx 处填写你的用户名 git config user.name &quot;xxx&quot; //修改邮箱地址，xxx 处填写你的邮箱地址 git config user.email &quot;xxx&quot; 最后说明一下这个 用户名 和 邮箱地址 只是用来记录本地 Git 提交信息的一个标识，和你远程仓库账号下的 用户名 或 邮箱地址 没有任何关系。 ","link":"https://Wangrongsheng.github.io/post/idhjH1MVy/"},{"title":"win10安装anaconda3并且配置tf、pytorch、keras环境","content":" Anaconda3 Win10环境下进行安装和配置！ 下载 进入Anaconda的官网进行下载 ； 选择你想下载的Python版本； 选择你的操作系统和位数，这里我们选择的是Windows64位； 然后点击Download按钮就开始下载了； 安装 正常安装完成就可以。 注意： 安装过程中一定要选择添加环境变量： 如果安装过程中你没有选择Add PATH 就需要配置环境变量了：如何配置你电脑上的环境变量 配置环境 配置tensorflow 1、打开anaconda安装时自带的Anaconda prompt 2、打开后,输入中科大镜像的tensorflow 的下载地址(如果你已经在墙外翱翔了,可以省略这一步): conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/conda-forge/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/msys2/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/bioconda/ conda config --add channels https://mirrors.ustc.edu.cn/anaconda/cloud/menpo/ conda config --set show_channel_urls yes 更换为其它源 3、接着我们开始创建一个python3.6 的环境,因为如果你安装的是最新的anaconda ,它默认环境为py3.8 ,并且在不久之前,tensorflow 已经开始支持py3.6 ,所以我们创建一个py3.6 环境: conda create -n tensorflow_1.12 python=3.6 4、启动anaconda 中的py3.6 环境: activate tensorflow_1.12 如果不能进入,则重新执行第3步骤 5、进入py3.6 的环境中后,我们就可以进行安装了(此处我们安装的是CPU版本的tensorflow): pip install --upgrade --ignore-installed tensorflow==1.12.0 GPU版本的Tensorflow安装：Windows10-64位下Anaconda3安装GPU版Tensorflow详细过程 6、当我们不使用tensorflow时,我们就可以使用: aonda deactivate 退出该环境 7、开始测试一下是否安装成功: 重新打开Anaconda Prompt—&gt;activate tensorflow_1.12—&gt;python来启动tensorflow，并进入python环境 #TensorFlow使用图(Graph)来表示计算任务；并使用会话(Session)来执行图，通过Session.close()来关闭会话（这是一种显式关闭会话的方式）。会话方式有显式和隐式会话之分。 import tensorflow as tf hello = tf.constant('Hello, TensorFlow!') #初始化一个TensorFlow的常量 sess = tf.Session() #启动一个会话 print(sess.run(hello)) 如果可以准确的输出结果,那么恭喜你,安装tensorflow成功! 配置keras 1、打开anaconda安装时自带的Anaconda prompt 2、创建一个py3.6 的keras环境: conda create -n keras python=3.6 CondaHTTPError:HTTP 000 CONNECTION FAILED错误的解决： 解决方案1 解决方案2 解决方案3 3、启动anaconda 中的py3.6 环境: activate keras 4、安装keras conda install keras 5、查看是否成功 import keras 如果输出无异常，那么就是安装成功！ 配置pytorch 首先，打开 PyTorch 官网安装页面（需自备梯子）：https://pytorch.org/get-started/locally/ PyTorch Build 就是选择下载稳定版（Stable）还是预览版（Preview），这里一般选择稳定版（Stable） YourOS 不多说，选择自己对应的操作系统类型 Package：下载方式，教程提供的是 Conda 方式 Language：python /c++/java CUDA：如果要下载 gpu 版本，那么就选择你对应的 cuda 的版本（不知道自己 cuda 版本的请打开cmd输入nvidia-smi即可查看到）；如果下载 cpu 版本，那么选择 None Run this Command：当你选择好版本后，会自动再次生成下载安装 PyTorch 的命令 然后复制页面中Run this Command后的代码,粘贴在你的命令行,等待安装完成就可以了~ 查看是否成功： import torch 如果输出无异常，那么就是安装成功！ ","link":"https://Wangrongsheng.github.io/post/c4JACV5eo/"},{"title":"区分规范化，归一化，标准化，正则化","content":" 规范化 数据库层面 规范化把关系满足的规范要求分为几级，满足要求最低的是第一范式（1NF），再来是第二范式、第三范式、BC范式和4NF、5NF等等，范数的等级越高，满足的约束集条件越严格。 数据层面 数据的规范化包括归一化标准化正则化，是一个统称（也有人把标准化作为统称）。 数据规范化是数据挖掘中的数据变换的一种方式，数据变换将数据变换或统一成适合于数据挖掘的形式，将被挖掘对象的属性数据按比例缩放，使其落入一个小的特定区间内，如[-1, 1]或[0, 1] 对属性值进行规范化常用于涉及神经网络和距离度量的分类算法和聚类算法当中。比如使用神经网络后向传播算法进行分类挖掘时，对训练元组中度量每个属性的输入值进行规范化有利于加快学习阶段的速度。对于基于距离度量相异度的方法，数据归一化能够让所有的属性具有相同的权值。 数据规范化的常用方法有三种：最小最大值规范化，z-score标准化和按小数定标规范化 标准化（standardization） 数据标准化是将数据按比例缩放，使其落入到一个小的区间内，标准化后的数据可正可负，但是一般绝对值不会太大，一般是z-score标准化方法：减去期望后除以标准差。 特点 对不同特征维度的伸缩变换的目的是使其不同度量之间的特征具有可比性，同时不改变原始数据的分布。 好处 不改变原始数据的分布，保持各个特征维度对目标函数的影响权重 对目标函数的影响体现在几何分布上 在已有样本足够多的情况下比较稳定，适合现代嘈杂大数据场景 归一化（normalization） 把数值放缩到0到1的小区间中（归到数字信号处理范畴之内），一般方法是最小最大规范的方法：min-max normalization 上面min-max normalization是线性归一化，还有非线性归一化，通过一些数学函数，将原始值进行映射。该方法包括log、指数、反正切等。需要根据数据分布的情况，决定非线性函数的曲线。 log函数：x = lg(x)/lg(max)；反正切函数：x = atan(x)*2/pi 应用 无量纲化 例如房子数量和收入，从业务层知道这两者的重要性一样，所以把它们全部归一化，这是从业务层面上作的处理。 避免数值问题 不同的数据在不同列数据的数量级相差过大的话，计算起来大数的变化会掩盖掉小数的变化。 一些模型求解的需要 例如梯度下降法，如果不归一化，当学习率较大时，求解过程会呈之字形下降。学习率较小，则会产生直角形路线，不管怎么样，都不会是好路线（路线解释看西面归一化和标准化的对比）。解释神经网络梯度下降的文章。 时间序列 进行log分析时，会将原本绝对化的时间序列归一化到某个基准时刻，形成相对时间序列，方便排查。 收敛速度 加快求解过程中参数的收敛速度。 特点 对不同特征维度进行伸缩变换 改变原始数据的分布，使得各个特征维度对目标函数的影响权重归于一致（使得扁平分布的数据伸缩变换成类圆形） 对目标函数的影响体现在数值上 把有量纲表达式变为无量纲表达式 归一化可以消除量纲对最终结果的影响，使不同变量具有可比性。比如两个人体重差10KG，身高差0.02M，在衡量两个人的差别时体重的差距会把身高的差距完全掩盖，归一化之后就不会有这样的问题。 好处 提高迭代求解的收敛速度 提高迭代求解的精度 缺点 最大值与最小值非常容易受异常点影响 鲁棒性较差，只适合传统精确小数据场景 正则化（regularization） 在求解最优化问题中，调节拟合程度的参数一般称为正则项，越大表明欠拟合，越小表明过拟合 为了解决过拟合问题，通常有两种方法，第一是减小样本的特征（即维度），第二是正则化（又称为惩罚penalty） 正则化的一般形式是在整个平均损失函数的最后增加一个正则项（L2范数正则化，也有其他形式的正则化，作用不同） 正则项越大表明惩罚力度越大，等于0表示不做惩罚。 正则项越小，惩罚力度越小，极端为正则项为0，则会造成过拟合问题；正则化越大，惩罚力度越大，则容易出现欠拟合问题。 参考 https://www.cnblogs.com/lzping/p/12547210.html ","link":"https://Wangrongsheng.github.io/post/lrwKFJ8bL/"},{"title":"Logistics Regression","content":" 逻辑回归概述 线性回归和逻辑回归区别？ 在前面讲述的回归模型中，处理的因变量都是数值型区间变量，建立的模型描述是因变量的期望与自变量之间的线性关系。比如常见的线性回归模型： 而在采用回归模型分析实际问题中，所研究的变量往往不全是区间变量而是顺序变量或属性变量，比如二项分布问题。通过分析年龄、性别、体质指数、平均血压、疾病指数等指标，判断一个人是否换糖尿病，Y=0表示未患病，Y=1表示患病，这里的响应变量是一个两点（0-1）分布变量，它就不能用h函数连续的值来预测因变量Y（只能取0或1）。 总之，线性回归模型通常是处理因变量是连续变量的问题，如果因变量是定性变量，线性回归模型就不再适用了，需采用逻辑回归模型解决。 逻辑回归（Logistic Regression）是用于处理因变量为分类变量的回归问题，常见的是二分类或二项分布问题，也可以处理多分类问题，它实际上是属于一种分类方法。 sigmoid 函数 相较于线性回归的因变量 y 为连续值，逻辑回归的因变量则是一个 0/1 的二分类值，这就需要我们建立一种映射将原先的实值转化为 0/1 值。这时候就要请出我们熟悉的 sigmoid 函数了： 其函数图形如下： 除了长的很优雅之外，sigmoid 函数还有一个很好的特性就是其求导计算等于下式，这给我们后续求交叉熵损失的梯度时提供了很大便利。 逻辑回归模型的数学推导 代码实现 # -*- coding: utf-8 -*- ##针对梯度上升求最大似然估计，可先设置大一点的步长与0.02， 求取一个初步的最优解， 然后设置小一点的步长，进一步求取精度更高的参数 import numpy as np import time from sklearn.datasets import load_breast_cancer from sklearn.model_selection import train_test_split def load_data (): dataSet = load_breast_cancer() return dataSet.data, dataSet.target def sigmoid (X): return 1.0 / (1.0 + np.exp(-X)) def LR_train (train_x, train_y, maxCycle, alpha): numSamples, numFeatures = np.shape(train_x) weights = np.ones((numFeatures, )) # 需要注意 np.ones((numFeatures, )) 和 np.ones((numFeatures, 1)) 的区别，虽然其数值是一样的，但是索引不同 # 此处选择第一种是为了与数据集中的形式匹配 for i in range(maxCycle): #梯度下降，用到所有样本, 通过所有样本找到梯度，然后调整权重, 需要多次迭代才能收敛（实验为500次） # output =sigmoid(np.dot(train_x, weights)) # err = train_y - output # weights = weights + alpha * np.dot(train_x.transpose(), err) # SGD 随机梯度下降，每次用单个样本计算梯度方向，此处为因此用到所有样本计算梯度，收敛快，迭代次数少（实验为10次）。因样本少，所以 # 两者计算时间相差不大，当数据量大时，SGD理论收敛要快计算时长要少 for i in range(numSamples): output =sigmoid(np.dot(train_x[i,:], weights)) err = train_y[i,] - output weights = weights + alpha * np.dot(train_x[i,:].transpose(), err) return weights def LR_test (test_x, test_y, weights): numSamples, numFeatures = np.shape(test_x) count = 0 for i in range(numSamples): if sigmoid(np.dot(test_x[i,:], weights)) &gt; 0.5: predict = 1 else: predict = 0 if predict == test_y[i,]: count = count + 1 return float(count/numSamples) if __name__ == &quot;__main__&quot;: data, label = load_data() startTime = time.time() train_x, test_x , train_y, test_y=train_test_split(data, label,test_size=0.25, random_state=33) weights = LR_train (train_x, train_y, 10, 0.01) accuracy = LR_test (test_x, test_y, weights) print(&quot;准确率：&quot;+ str(accuracy)) print(&quot;计算时长：&quot; +str(time.time() - startTime)) 逻辑回归特点 优点 实现简单，广泛的应用于工业问题上； 训练速度较快。分类速度很快 内存占用少； 便利的观测样本概率分数，可解释性强； 缺点 当特征空间很大时，逻辑回归的性能不是很好； 一般准确度不太高 很难处理数据不平衡的问题 参考 https://www.cnblogs.com/hum0ro/p/9652674.html https://recomm.cnblogs.com/blogpost/9129493?page=1 ","link":"https://Wangrongsheng.github.io/post/JjpghIA29/"},{"title":"Python代码加上进度条","content":" 自定义ProgressBar import sys import time def progressbar(it, prefix=&quot;&quot;, size=60, file=sys.stdout): count = len(it) def show(j): x = int(size*j/count) file.write(&quot;%s[%s%s] %i/%i\\r&quot; % (prefix, &quot;#&quot;*x, &quot;.&quot;*(size-x), j, count)) file.flush() show(0) for i, item in enumerate(it): yield item show(i+1) file.write(&quot;\\n&quot;) file.flush() for i in progressbar(range(15), &quot;Computing: &quot;, 40): progressbar(50) time.sleep(0.1) 自己定义的好处就是可以将进度条定义成我们想要的形式比如上面就是使用#与·来输出，为什么不用print？因为sys.stdout就是print的一种默认输出格式，而sys.stdout.write()可以不换行打印，sys.stdout.flush()可以立即刷新输出的内容。当然也可以封装成类来更好的使用 ，但效果是类似的。 from __future__ import print_function import sys import re class ProgressBar(object): DEFAULT = 'Progress: %(bar)s %(percent)3d%%' FULL = '%(bar)s %(current)d/%(total)d (%(percent)3d%%) %(remaining)d to go' def __init__(self, total, width=40, fmt=DEFAULT, symbol='=', output=sys.stderr): assert len(symbol) == 1 self.total = total self.width = width self.symbol = symbol self.output = output self.fmt = re.sub(r'(?P&lt;name&gt;%\\(.+?\\))d', r'\\g&lt;name&gt;%dd' % len(str(total)), fmt) self.current = 0 def __call__(self): percent = self.current / float(self.total) size = int(self.width * percent) remaining = self.total - self.current bar = '[' + self.symbol * size + ' ' * (self.width - size) + ']' args = { 'total': self.total, 'bar': bar, 'current': self.current, 'percent': percent * 100, 'remaining': remaining } print('\\r' + self.fmt % args, file=self.output, end='') def done(self): self.current = self.total self() print('', file=self.output) from time import sleep progress = ProgressBar(80, fmt=ProgressBar.FULL) for x in range(progress.total): progress.current += 1 progress() sleep(0.1) progress.done() tqdm from tqdm import trange import time for i in trange(10): time.sleep(1) rich from rich.progress import track import time for step in track(range(30)): print('早起Python') time.sleep(0.5) ","link":"https://Wangrongsheng.github.io/post/WxbomMWrG/"},{"title":"Github协议详解","content":" 转载自：http://www.bewindoweb.com/224.html ","link":"https://Wangrongsheng.github.io/post/Q9k42ltHY/"},{"title":"图像分类、目标检测、语义分割模型","content":" 图像分类模型 VGG16 VGG19 InceptionV3 Xception MobileNet AlexNet LeNet ZF_Net ResNet18 ResNet34 ResNet50 ResNet_101 ResNet_152 目标检测模型 全部目标检测模型 ： 经典常用的目标检测模型： R-CNN OverFeat Fast R-CNN Faster R-CNN OHEM Yolo SSD R-FCN FPN RetinaNet Mask R-CNN RefineDet M2Det 51 个深度学习目标检测模型汇总，论文、源码一应俱全！ 语义分割模型 FCN SegNet U-Net Dilated Convolutions DeepLab (v1 &amp; v2) RefineNet PSPNet Large Kernel Matters DeepLab v3 ","link":"https://Wangrongsheng.github.io/post/CaOYpTlGm/"},{"title":"我需要多久实现财富自由？","content":" 直接使用Chorme浏览器 的Console运行代码即可~ let cost = { cloth:-1, eat:-1, house:-1, traffic:-1 } let monthCost = 0; let freedom = 0; let yearSave = 0; let monthSave = 0; let old = -1; let already = 0; let checkType = (money,type)=&gt;{ if(money&lt;0){ console.warn('开销不能为负数'); return -1; } if(type==='月') return money; if(type === '日') return money*30; if(type === '年') return Math.floor(money/12); } let money = (money) =&gt; { already = money; } let checkInfo = (funName)=&gt; { let can = true; if(cost.cloth&lt;0){ console.warn('你还需要调用cloth(),告诉程序你在穿着打扮上的开销'); can = false; } if(cost.eat&lt;0){ console.warn('你还需要调用eat(),告诉程序你在吃上的开销'); can = false; } if(cost.house&lt;0){ console.warn('你还需要调用house(),告诉程序你在住上的开销'); can = false; } if(cost.traffic&lt;0){ console.warn('你还需要调用traffic(),告诉程序你在交通出行上的开销'); can = false; } if(!can) console.warn(`否则无法运行${funName}()`); return can; } let eat = (money,type='月')=&gt;{ cost.eat = checkType(money,type); return `每个月在吃上花${cost.eat}元` } let cloth = (money,type='月') =&gt; { cost.cloth = checkType(money,type); return `每个月在穿上花${cost.cloth}元` } let house = (money,type='月') =&gt; { cost.house = checkType(money,type); return `每个月在住上花${cost.house}元` } let traffic = (money,type='月') =&gt; { cost.traffic = checkType(money,type); return `每个月在行上花${cost.traffic}元` } let age = (age)=&gt;{ old = age; return `今年${age}岁` } let getValue = ()=&gt;{ let {cloth,eat,house,traffic} = cost; monthCost = cloth+eat+house+traffic; yearCost = monthCost * 12; freedom = Math.floor(yearCost/0.04); } let costSum = () =&gt; { if(!checkInfo('costSum')) return; getValue(); freedom = Math.floor(yearCost/0.04); console.log(`月开销：%c${monthCost}`,'color:yellow'); console.log(`年开销：%c${yearCost}`,'color:yellow'); console.log(`财务自由需要存款%c${freedom}`,'color:yellow') } let keep = (income) =&gt; { if(!checkInfo('keep')) return; getValue(); if(income&lt;monthCost){ console.warn(`你的月生活开销是${monthCost},而月收入是${income}` ); console.warn(`你的收入无法支撑你的生活开销，请降低你的生活开销或提高你的收入` ) return '你可以通过调用eat(),house(),cloth(),traffic()降低生活开销'; } yearIncom = income*12; canSave = yearIncom - yearCost; let save = already; let temp = 0; i = 1; console.log(`你的总资产是：${already}，若保持月收入${income}`); if(already&gt;0) console.log('一开始便将闲置资产投入有收益的理财产品（如基金）') console.warn('每年历程如下！') while(save&lt;freedom){ temp = save; if(save&lt;0){ save+=canSave; console.log(`第${i}年后，总债务${temp}，多余收入需要还债务，清还${canSave},总资产${save}`); if(save&gt;0) console.log('此时便将资产投入理财产品（如基金）') }else{ save+=canSave + save*0.04; console.log(`第${i}年后，存款产生收益${Math.floor(temp*0.04)}，未操作前总存款${Math.floor(temp)},存入${canSave},总存款${Math.floor(save)}`); } i++; }; console.log(`%c恭喜你，在第${i}年进入财务自由，总存款${Math.floor(save)},存款产生收益${Math.floor(save*0.04)}`,'color:red'); console.log(`如果保持当前月收入%c${10000}%c，你需要%c${i}年%c的时间达到财务自由`,'color:lightgreen','','color:yellow','') } let aim = (aimOld)=&gt;{ if(!checkInfo('aim')) return; getValue(); if(!aimOld){ return '请通过运行调用本函数时，在aim()的括号中填入你希望多少岁达到财务自由，否则无法计算' } if(aimOld&lt;old){ return `时光无法倒流，请正确填入数字` } if(old&lt;0){ console.warn('由于您还为告诉系统您的正确年龄，所以无法计算'); return '请通过运行 age()，在括号中填入年龄，来告诉程序您当前年龄' } if(already&lt;0){ return '目前暂不支持负资产调用本计算，因为我数学不太行- -' } howManyYear = aimOld - old m = 0; for(let i = 1;i&lt;howManyYear;i++){ m = m*0.04+m+1 } yearSave = Math.floor((freedom-already)/m); monthSave = yearSave/12; console.log(`你的总资产是${already},今年${old}岁，想要在${aimOld}时财务自由`); console.log(`你需要在每年都存下${yearSave}`); console.log(`然而你每年的开销是${yearCost}`); console.log(`所以你的年薪至少需要是${Math.floor(yearCost+yearSave)}`); console.log(`所以需要每个月都存下${Math.floor(monthSave)}`); console.log(`然而你每个月的开销是${monthCost}`); console.log(`所以你每个月至少要赚${Math.floor(monthCost+monthSave)}`) let saving = already; console.warn('每年历程如下！') for(let i = 0;i&lt;howManyYear;i++){ let temp = saving; saving+=yearSave+(temp*0.04) if(i===howManyYear-1){ console.log(`恭喜你，在第${i+1}年进入财务自由，总存款${Math.floor(temp)}，存款产生收益${Math.floor(temp*0.04)}`); console.log(`如果想要在${24+howManyYear}时达到财务自由，你的月收入需要达到每个月${Math.floor(monthCost+monthSave)}`) }else{ console.log(`第${i+1}年，存款产生收益${Math.floor(temp*0.04)}，未操作前总存款${Math.floor(temp)},存入${yearSave},总存款${Math.floor(saving)}`); } } } let rule = ()=&gt;{ console.log(`%c欢迎使用财务自由小程序`,'color:yellow;font-size:20px'); console.log(`%c-----------------第一步-----------------`,'font-size:15px'); console.log(`首先使用cloth(),eat(),house(),traffic()四个方法告诉程序你的日常开销`); console.log(`四个函数分别对应着衣食住行`); console.log(`%ceat：%c告诉程序你花在吃上的开销`,'color:lightgreen;font-wight:bold',''); console.log(`例：%ceat(50,'日')`,'color:yellow'); console.log(`在这个例子中，第一个参数50是指需要花50元，第二个参数'日'是指单位`); console.log(`%c也就是告诉程序，一天在吃上需要花费50元`,'color:yellow'); console.log(`%ccloth：%c告诉程序你花在穿着打扮上的开销`,'color:lightgreen;font-wight:bold',''); console.log(`例：%ccloth(2000,'年')`,'color:yellow'); console.log(`%chouse：%c告诉程序你花在住房上的开销`,'color:lightgreen;font-wight:bold',''); console.log(`例：%chouse(3000,'月')`,'color:yellow'); console.log(`%ctraffic：%c告诉程序你花在吃上的开销`,'color:lightgreen;font-wight:bold',''); console.log(`例：%ctraffic(200,'月')`,'color:yellow'); console.log(`%c具体方法请查看视频！`,'color:red'); console.log(`%c------------------第二步-----------------`,'font-size:15px'); console.log(`完成上述操作后，可使用costSum(),keep(),aim()函数来查看计算结果`); console.log(`%ccostSum：%c计算月开销和年开销以及财务自由所需的存款`,'color:lightgreen;font-wight:bold',''); console.log(`例：%ccostSum()`,'color:yellow'); console.log(`%ckeep:：%c计算保持现有每月收入的情况下，多久达到财务自由`,'color:lightgreen;font-wight:bold',''); console.log(`例：%ckeep(5000)`,'color:yellow'); console.log(`%caim：%c计算如果想要在目标年龄实现财务自由，平均需要月入多少`,'color:lightgreen;font-wight:bold',''); console.log(`例：%caim(30)`,'color:yellow'); console.log(`%cage：%c设置你的年龄`,'color:lightgreen;font-wight:bold',''); console.log(`例：%cage(18)`,'color:yellow'); console.log(`%cmoney：%c设置你的存款`,'color:lightgreen;font-wight:bold',''); console.log(`例：%cmoney(1000)`,'color:yellow'); console.log(`%c具体方法请查看文档！`,'color:red'); } rule(); ","link":"https://Wangrongsheng.github.io/post/u0GKl--57/"},{"title":"学生疫情期间信息管理系统（python实现）","content":" import time def meun(): menu_info = '''＋－－－－－－－－－－－－－－－－－－－－－－＋ ｜ １）添加学生信息 ｜ ｜ ２）显示所有学生的信息 ｜ ｜ ３）删除学生信息 ｜ ｜ ４）修改学生信息 ｜ ｜ ５）按学生外出次数高－低显示学生信息 ｜ ｜ ６）按学生外出次数低－高显示学生信息 ｜ ｜ ７）按学生所在地确诊人数高－低显示学生信息 ｜ ｜ ８）按学生所在地确诊人数低－高显示学生信息 ｜ ｜ ９）保存学生信息到文件（students.txt) ｜ ｜ １０）从文件中读取数据（students.txt) ｜ ｜ 退出：其他任意按键＜回车＞ ｜ ＋－－－－－－－－－－－－－－－－－－－－－－＋ ''' print(menu_info) def get_outgotimes(*a): for i in a: return i.get(&quot;outgotimes&quot;) def get_people(*a): for i in a: return i.get(&quot;people&quot;) # 1)添加学生信息 def add_student_info(): L = [] while True: sid = input(&quot;请输入学号:&quot;) if not sid: #学号为空跳出循环 break n = input(&quot;请输入姓名:&quot;) if not n: #名字为空，跳出循环 break try: a = int(input(&quot;请输入外出次数:&quot;)) s = int(input(&quot;请输入所在地确诊人数:&quot;)) except: print(&quot;输入无效，请输入整数....重新录入信息&quot;) continue t = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime()) info = {&quot;id&quot;:sid,&quot;name&quot;:n,&quot;outgotimes&quot;:a,&quot;people&quot;:s,&quot;intimes&quot;:t} L.append(info) print(&quot;学生信息录入完毕！！！&quot;) return L # 2)显示所有学生的信息 def show_student_info(student_info): if not student_info: print(&quot;无数据信息......&quot;) return print(&quot;学号&quot;.center(12),&quot;姓名&quot;.center(8),&quot;外出次数&quot;.center(8),&quot;确诊人数&quot;.center(8),&quot;录入时间&quot;.center(30)) for info in student_info: print(info.get(&quot;id&quot;).center(12),info.get(&quot;name&quot;).center(8),str(info.get(&quot;outgotimes&quot;)).center(8),str(info.get(&quot;people&quot;)).center(8),info.get(&quot;intimes&quot;).center(30)) # 3) 删除学生信息 def del_student_info(student_info,del_name = ''): if not del_name: del_name = input(&quot;请输入删除的学生姓名：&quot;) for info in student_info: if del_name == info.get(&quot;name&quot;): print(&quot;学生信息即将被删除或更新&quot;) return info raise IndexError(&quot;学生信息不匹配,没有找到%s&quot; %del_name) # 4) 修改学生信息 def mod_student_info(student_info): mod_name = input(&quot;请输入修改的学生姓名:&quot;) for info in student_info: if mod_name == info.get(&quot;name&quot;): m = input(&quot;请输入学号:&quot;) if not m: break a = int(input(&quot;请输入外出次数:&quot;)) s = int(input(&quot;请输入所在地确诊人数:&quot;)) t = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime()) info = {&quot;id&quot;:m,&quot;name&quot;:mod_name,&quot;outgotimes&quot;:a,&quot;people&quot;:s,&quot;intimes&quot;:t} return info raise IndexError(&quot;学生信息不匹配，没有找到%s&quot;%mod_name) # 5) 按学生外出次数高—低显示学生信息 def outgotimes_reduce(student_info): print(&quot;按学生外出次数高—低显示:&quot;) mit = sorted(student_info,key = get_outgotimes,reverse = True) show_student_info(mit) # 6) 按学生外出次数低—高显示学生信息 def outgotimes_rise(student_info): print(&quot;按学生外出次数低—高显示:&quot;) mit = sorted(student_info,key = get_outgotimes) show_student_info(mit) # 7) 按照学生所在地确诊人数高—低显示学生信息 def people_reduce(student_info): print(&quot;按学生所在地确诊人数高－低显示学生信息：&quot;) mit = sorted(student_info ,key = get_people,reverse = True) show_student_info(mit) # ８）按学生所在地确诊人数低—高显示学生信息 def people_rise(student_info): print(&quot;按学生所在地确诊人数低—高显示学生信息&quot;) mit = sorted(student_info ,key = get_people) show_student_info(mit) # ９）保存学生信息到文件（students.txt) def save_info(student_info): try: students_txt = open(&quot;students.txt&quot;,&quot;w&quot;) # 以写模式打开，并清空文件内容 except Exception as e: students_txt = open(&quot;students.txt&quot;, &quot;x&quot;) # 文件不存在，创建文件并打开 for info in student_info: students_txt.write(str(info)+&quot;\\n&quot;) # 按行存储，添加换行符 students_txt.close() # １０）从文件中读取数据（students.txt) def read_info(): old_info = [] try: students_txt = open(&quot;students.txt&quot;) except: print(&quot;暂未保存数据信息&quot;) # 打开失败，文件不存在说明没有数据保存 return while True: info = students_txt.readline() if not info: break #print(info) info = info.rstrip() # 去掉换行符 # print(info) info = info[1:-1] # 去掉｛｝ # print(info) student_dict = {} # 单个学生字典信息 for x in info.split(&quot;,&quot;): # 以，为间隔拆分 # print(x) key_value = [] # 开辟空间，key_value[0]存key,key_value[0]存value for k in x.split(&quot;:&quot;): # 以：为间隔拆分 k = k.strip() # 去掉首尾空字符 # print(k) if k[0] == k[-1] and len(k) &gt; 2: # 判断是字符串还是整数 key_value.append(k[1:-1]) # 去掉 首尾的＇ else: key_value.append(str(k)) # print(key_value) student_dict[key_value[0]] = key_value[1] # 学生信息添加 # print(student_dict) old_info.append(student_dict) # 所有学生信息汇总 students_txt.close() return old_info def main(): student_info = [] while True: # print(student_info) meun() number = input(&quot;请输入选项：&quot;) if number == '1': student_info = add_student_info() elif number == '2': show_student_info(student_info) elif number == '3': try: student_info.remove(del_student_info(student_info)) except Exception as e: # 学生学号不匹配 print(e) elif number == '4': try: student = mod_student_info(student_info) except Exception as e: # 学生学号不匹配 print(e) else: # 首先按照根据输入信息的名字，从列表中删除该生信息，然后重新添加该学生最新信息 student_info.remove(del_student_info(student_info,del_name = student.get(&quot;name&quot;))) student_info.append(student) elif number == '5': outgotimes_reduce(student_info) elif number == '6': outgotimes_rise(student_info) elif number == '7': people_reduce(student_info) elif number == '8': people_rise(student_info) elif number == '9': save_info(student_info) elif number == '10': student_info = read_info() else: break input(&quot;回车显示菜单&quot;) main() ","link":"https://Wangrongsheng.github.io/post/XKyLFg5bR/"},{"title":"《计算机网络》复习","content":" 一、绪论 1.1计算机网络 计算机网络：是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。 计算机网络向用户提供的两个最重要的功能： 数据通信（连通性）：计算机网络最基本最重要的功能。 资源共享 1.2因特网概述 因特网发展的三个阶段： 第一阶段：从单个网络 ARPANET 向互联网发展的过程。1983 年 TCP/IP 协议成为 ARPANET 上的标准协议。 第二阶段：建成三级结构的因特网：主干网、地区网和校园网（或企业网）。 第三阶段：形成多层次的ISP（Internet Service Provider 因特网服务提供者）结构的因特网 Internet 和 Internet 的区别： internet：通用名词，它泛指由多个计算机网络互连而成的网络。 Internet：专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定计算机网络，它采用 TCP/IP 协议族作为通信的规则，且其前身是美国的 ARPANET。 1.3互联网的组成P8 边缘部分 ：由所有连接在因特网上的主机组成。这部分由用户直接使用 ，用来进行通信和资源共享。 核心部分 : 由大量的网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的 （提供连通性和交换）。 处于边缘部分的用户通信方式 P9-P10 客户服务器方式（C/S 方式）：即 Client/Server 方式。（客户是服务的请求方，服务器是服务的提供方） 对等方式（P2P 方式）：即 Peer-to-Peer 方式。（对等连接中的每一个主机既是客户又同时是服务器） 核心部分的交换技术 P11-15 电路交换 的三个阶段：建立连接——通话——释放连接 在通话时，两用户之间占用端到端的资源，而由于绝大部分时间线路都是空闲的，所以线路的传输速率往往很低。 分组交换 的组成：报文、首部、分组。采用存储转发技术，即收到分组——存储分组——查询路由（路由选择协议）——转发分组。优点：高效、灵活、迅速、可靠。缺点：时延、开销。关键构件：路由器。 报文交换 整个报文传送到相邻结点，全部存储下来之后查询转发表，转发到下一个结点。 1.4计算机网络的类别P17 分类 按通信距离分：广域网、局域网、城域网 按网络拓扑结构分：星型网、树型网、环型网、总线网 按传输带宽分：基带网、宽带网 按使用范围分：公用网、专用网 按速率分：高速网、中速网、低速网 按通信传播方式分：广播式、点到点式 广播式网络：共享公共通信通道 点对点网络：使用分组存储转发和路由选择机制 性能指标（P18）：速率、带宽、时延 速率 ：指连接在计算机网络上的主机在数字信道上传送数据的速率。b/s（bps） 如100M以太网，实际是指100Mb/s。往往是指额定速率或标称速率。 带宽 ：数字信道所能传送的最高速率。b/s（bps） 吞吐量 ：单位时间内通过某个网络（或信道、接口）的实际数据量。其绝对上限值等于带宽。 时延 ：数据（一个报文或分组、甚至比特）从网络（或链路）的一段传送到另一端的时间，也称延迟。 ① 发送时延：主机或路由器发送数据帧所需的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。也成传输时延。 发送时延 = 数据帧长度（b） / 信道带宽（b/s） ② 传播时延：电磁波在信道中传输一定距离所需划分的时间。 传播时间 = 信道长度（m） / 传输速率（m/s） ③ 处理时延：主机或路由器处理收到的分组所花费的时间。 ④ 排队时延：分组在输入队列中等待处理的时间加上其在输出队列中等待转发的时间。 综上：总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延。 注：对于高速网络链路，提高的是发送速率而不是传播速率。 时延带宽积：传播时延 * 带宽。表示链路的容量。 往返时间RTT：从发送方发送数据开始，到发送发收到接收方的确认为止，所花费的时间。 利用率：某信道有百分之几是被利用的（有数据通过）。而信道或网络利用率过高会产生非常大的时延。 当前时延=空闲时时延/（1-利用率） 1.5计算机网络的体系结构P25 网络协议 ：简称协议，是为了进行网络中的数据交换而建立的规则、标准或约定，是控制两个对等实体进行通信的规则的集合。在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务，而要实现本层协议，还需要使用下一层提供的服务。 网络协议的三要素 语法：数据与控制信息的结构或格式 语义：需要发出何种控制信息，完成何种动作以及做出何种响应 同步：事件实现顺序的详细说明 实体 ：第 n 层的活动元素称为 n 层实体。同一层的实体叫对等实体 。 接口 ：上层使用下层服务的入口 服务 ：下层为相邻上层提供的功能调用。 体系结构 (architecture)简称分层结构 ，是计算机网络的各层及其协议的集合。 7 层 OSI 参考模型： 物理层、数据链路层、网络层：提供点到点的服务 传输层、会话层、表示层、应用层：提供端到端的服务 4 层 TCP/IP 参考模型 ：网络接口层、网际层IP、运输层、应用层 TCP/IP 设计之初就考虑到异构网互联问题，将 IP 作为重要层次；而 OSI 参考模型先于协议发明，不偏向特定协议。 两者常考的异同点：OSI 参考模型网络层是「无连接+面向连接」，而 TCP/IP 模型是「无连接」的；OSI 参考模型传输层是「面向连接」，而 TCP/IP 模型是「无连接+面向连接」。 五层协议的体系结构（综合了 OSI 和 TCP/IP 的优点） 物理层 ：物理层的任务就是透明地传送比特流。（注意：传递信息的物理媒体，如双绞线、同轴电缆、光缆等，是在物理层的下面，当做第0 层。）物理层还要确定连接电缆插头的定义及连接法。 数据链路层 ：将网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上”透明“的传送以帧为单位的数据。每一帧包括数据和必要的控制信息。在收到数据时，控制信息使收到端直到哪个帧从哪个比特开始和结束。 网络层 ：选择合适的路由，使发送站的运输层所传下来的分组能够正确无误地按照地址找到目的站，并交付给目的站的运输层。网络层将运输层产生的报文或用户数据报封装成分组（IP数据报）或包进行传送。 运输层 ：向上一层的进行通信的两个进程之间提供一个可靠的端对端服务，使它们看不见运输层以下的数据通信的细节。（TCP、UDP） 应用层 ：直接为用户的应用进程提供服务（HTTP、FTP等） 二、物理层 2.1物理层基础概念 物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是值具体的传输媒体。 物理层特性： 机械特性 电气特性 功能特性 规程特性 2.2数据通信基础知识 数据 ：传递信息的实体，通常是有意义的符号序列。 信号 ：数据的电气/电磁的表现，是数据在传输过程中的存在形式。 数字信号：代表消息的参数取值是离散的 模拟信号：代表信号的参数取值是连续的 信源 ：产生和发送数据的源头。 信宿 ：接收数据的终点 信道 ：信号的传输媒介。一般用来表示像某一个方向传输信号的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。 三种通信方式： 单工通信 ：只有一个方向的通信而没有反方向的交互，仅需一条信道。 半双工通信 ：通信的双方都可以发送或接受信息，但任何一方都不能同时发送和接收，需要两条信道。 全双工通信 ：通信双方可以同时发送和接收信息，也需要两条信道。 两种数据传输方式： 串行传输 ：速度慢，费用低，适合远距离 并行传输 ：速度快，费用高，适合近距离 2.3物理层下的传播媒体 双绞线：双绞线已成为局域网中的主流传输媒体 屏蔽双绞线 STP (Shielded Twisted Pair) 无屏蔽双绞线 UTP (Unshielded Twisted Pair) 同轴电缆： 细缆（适合短距离，安装容易，造价低） 粗缆（适合较大局域网，布线距离长，可靠性好） 光纤：光纤有很好的抗电磁干扰特性和很宽的频带，主要用在环形网中 多模光纤（用发光二极管，便宜，定向性较差） 单模光纤（注入激光二极管，定向性好） 非导向传输媒体：微波、红外线、激光、卫星通信 2.4信道复用技术 这部分掌握码分复用计算即可 频分复用FDM (Frequency Division Multiplexing)：所有用户在同样的时间占用不同的频率带宽资源。 时分复用TDM(Time Division Multiplexing)则是将时间划分为一段段等长的时分复用帧（TDM 帧）。 统计时分复用 STDM(Statistic TDM)是改进的时分复用，明显地提高信道的利用率。 波分复用 WDM (Wavelength Division Multiplexing)：光的频分复用 码分复用 CDM (Code Division Multiplexing)常用的名词是码分多址 CDMA：有很强的抗干扰能力。 码分多址的计算靠一个例题就基本会了： 三、数据链路层 数据链路层使用的信道主要有以下两种类型： 点对点信道 广播信道 3.1使用点对点信道的数据链路层 链路 ：从一个结点到相邻结点的一段物理线路 数据链路 ：把实现这些协议的硬件和软件加载链路上 现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。一般的适配器都包括了数据链路层和物理层这两层的功能。 三个基本问题： 封装成帧 就是在一段数据的前后分别添加首部（帧开始符SOH 01）和尾部（帧结束符EOT 04），然后就构成了一个帧。（数据部分&lt;=长度限制MTU）首部和尾部的一个重要作用就是进行帧定界。 帧定界是分组交换的必然要求 透明传输 为了达到透明传输（即传输的数据部分不会因为包含SOH和EOT而出错），在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(十六进制1B) 透明传输避免消息符号与帧定界符号相混淆 差错检测 现实通信链路中比特在传输中会产生差错，传输错误的比特占比称为误码率BER，为了保证可靠性，通常通过循环冗余检验CRC来做差错检测。 差错检测防止无效数据帧浪费后续路由上的传输和处理资源 3.2点对点协议PPP P70 PPP协议的组成部分 一个将 IP 数据报封装到串行链路的方法 链路控制协议 LCP (Link Control Protocol) 网络控制协议 NCP (Network Control Protocol) PPP协议的帧格式 首部： 首部中的标志字段F(Flag)，规定为0x7E(符号0x表示它后面的字符是用十六进制表示的。十六进制的7E的二进制表示是01111110)，标志字段表示一个帧的开始。 首部中的地址字段A规定为0xFF(即11111111)。 首部中的控制字段C规定为0x03(即00000011)。 首部中的2字节的协议字段： (1)当协议字段为0x0021时，PPP帧的信息字段就是IP数据报。 (2)当协议字段为0xC021时，PPP帧的信息字段就是PPP链路控制协议LCP的数据。 (3)当协议字段为0x8021时，PPP帧的信息字段就是网络层的控制数据。 尾部： 尾部中的第一个字段(2个字节)是使用CRC的帧检验序列FCS。 尾部中的标志字段F(Flag)，规定为0x7E(符号0x表示它后面的字符是用十六进制表示的。十六进制的7E的二进制表示是01111110)，标志字段表示一个帧的结束。 透明传输的实现方法 当信息字段中出现和标志字段一样的比特(0x7E)组合时，就必须采取一些措施使这种形式上和标志字段一样的比特组合不出现在信息字段中。 字节填充 ——PPP使用异步传输 当 PPP 用在异步传输时，就使用一种特殊的字符填充法：将每一个 0x7E字节变为(0x7D, 0x5E)，0x7D转变成为(0x7D, 0x5D)。ASCII 码的控制字符（即数值小于 0x20 的字符），则在前面要加入0x7D，同时将该字符的编码加以改变。 零比特填充 ——PPP使用同步传输 只要发现有5个连续的1，则立即填入一个0 PPP 协议的工作状态： 链路静止-建立物理层-链路建立-pc发LCP-NCP分配IP地址-链路打开，网络层建立。（释放时倒过来） 3.3使用广播信道的数据链路层 P76 广播信道是一种一对多的通信，局域网使用的就是广播信道 局域网的数据链路层（局域网的数据链路层被拆分为了两个子层） 逻辑链路控制LLC子层：与传输媒体无关 媒体接入控制MAC子层：和局域网都对LLC子层来说是透明的 CSMA/CD 协议 以太网采用CSMA/CD协议的方式来协调总线上各计算机的工作。在使用CSMA/CD协议的时候，一个站不可能同时进行发送和接收，因此使用CSMA/CD协议的以太网不可能进行全双工通信而只能进行双向交替通信（半双工）。 CSMA/CD是载波监听多点接入/碰撞检测（Carrier Sense Multiple Access with Collision Detection）的缩写，下面是CSMA/CD协议的要点： “多点接入” 就是计算机以多点接入（动态媒体接入控制）的方式连接在一根总线上。 “载波监听” 就是”发送前先监听”，即每一个站在发送数据前先要检测一下总线是否有其他站在发送数据，如有则暂时不要发送数据，要等到信道为空闲。 “碰撞检测” 就是“边发送边监听”，即适配器边发送数据边检测信道上的信号电压的变化情况。当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。 把总线上的单程端到端传播时延记为τ，A 发送数据后，最迟要经过2τ才能知道自己发送的数据和其他站发送的数据有没有发生碰撞。 3.4MAC地址 “MAC地址”又叫做硬件地址或物理地址，实际上就是适配器地址或适配器标识符EUI-48。高位24位：厂家，低位24位由厂家自行指派 MAC帧的格式 常用的以太网MAC帧格式有两种标准 ： DIX Ethernet V2 标准IEEE 的 802.3 标准。V2使用较多，如图： 以太网V2的MAC帧较为简单，有五个字段组成。 前两个字段分别为6字长的目标地址和源地址字段。第三个字段是2字节的类型字段，用来标志上一层使用的是什么协议，以便把收到的MAC帧的数据上交给上一层的这个协议。后面数据字段46~1500字节，FCS字段4个字节。 3.5扩展的以太网 在物理层扩展—集线器 P91 现在，双绞线以太网成为以太网的主流类型，扩展主机和集线器之间的距离的一种简单方法就是使用光纤(通常是一对光纤)和一对光纤调制解调器。 光纤调制解调器的作用，是进行电信号和光信号的转换。 在数据链路层扩展—网桥（自学习算法）P94 注：在数据链路层扩展以太网要使用网桥 网桥工作在数据链路层，它根据MAC帧的目的地址对收到的帧进行转发或过滤。当网桥收到一个帧时，并不是向所有的接口转发这个帧，而是检查此帧的目的MAC地址，然后再确定将该帧转发到哪一个接口，或者是把它丢弃(即过滤)。 具体可以参考这篇博客：http://blog.csdn.net/cainv89/article/details/50651489 虚拟局域网-交换机P98 多接口网桥即交换式集线器常称为以太网交换机。利用以太网交换机可以很方便地 实现虚拟局域网，虚拟局域网协议允许在以太网的帧格式中插入一个 4 字节的标识符，称为 VLAN 标记。 四、网络层 4.1网际协议IP 网际协议IP是TCP/IP体系中两个最重要的协议之一，也是最重要的因特网标准协议之一。与IP协议配套是用的四个协议： 地址解析协议ARP ：是解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。 逆地址解析协议RARP ：是解决同一个局域网上的主机或路由器的硬件地址和IP地址的映射问题。 网际控制报文协议ICMP ：提供差错报告和询问报文，以提高IP数据交付成功的机会 网际组管理协议IGMP ：用于探寻、转发本局域网内的组成员关系。 4.1.1虚拟互连网络 因为没有一种单一的网络能够适应所有的用户需求，所以网络互连也变得困难，所以需要一些中间设备： 物理层中间设备：转发器(repeater) 数据链路层中间设备：网桥或桥接器(bridge) 网络层中间设备：路由器(router) 网络层以上的中间设备：网关(gateway) 具体各层的设备说明可以看这篇博客“网络设备”部分：http://blog.csdn.net/hushhw/article/details/78489470 4.1.2分类的IP地址 P113 IP 地址 就是给每个连接在因特网上的主机（或路由器）分配一个在全世界范围是唯一的 32 位的标识符。由因特网名字与号码指派公司ICANN进行分配。 IP地址编制方法的三个阶段： 分类的IP地址 子网的划分 构成超网 每一类地址都由 网络号 net-id和 主机号 host-id组成 主机号中全0表示网络地址，全1表示广播地址 A类 由1字节的网络地址和3字节主机地址组成 网络地址的最高位必须是“0“，可指派的网络数为128-2，减2的原因是0.0.0.0对应“本网络”，另外一个是127.0.0.1是本地软件的回环地址，用于测试自己电脑IP地址是否可用。 地址范围1.0.0.0到126.255.255.255 最大主机数为2563-2=16777214台，减2的原因是全0的主机号字段代表该IP地址是”本主机“，全1表示”所有的“，表示该网络上的所有主机 B类 由2字节的网络地址和2字节主机地址组成 网络地址的最高位必须是“10”，可指派的网络数为 214 -1，因为最高位为10，所以不存在全0全1的情况，但是B类网络地址128.0.0.0是不指派的，可指派最小网络地址是128.1.0.0 地址范围128.0.0.0-191.255.255.255 最大主机数为2562-2=65534台，减2同样是全0全1情况。 C类 由3字节的网络地址和1字节主机地址组成 网络地址的最高位必须是“110”，可指派的网络数为221-1，192.0.0.0不指派，最小可指派网络地址是192.0.1.0 地址范围192.0.0.0-223.255.255.255 最大主机数为256-2=254台，减2同样是全0全1情况。 D类是多播地址，“lll0”开始 E类地址保留为今后使用，“llll0”开头 4.1.3IP地址与硬件地址 硬件地址 是数据链路层和物理层使用的地址 IP地址 是网络层和以上各层使用的地址，是一种逻辑地址 IP地址放在IP数据报的首部，而硬件地址放在MAC帧的首部。当数据报放入数据链路层的MAC帧中后，整个IP数据报就成为MAC帧的数据，因而在数据链路层看不见数据报的IP地址。 4.1.4地址解析协议ARP ARP是解决同一个局域网 上的主机或路由器的 IP 地址和硬件地址的映射问题。 每一个主机都设有一个ARP高速缓存(ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。 如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。 4.1.5 IP数据报 IP数据报格式 一个IP数据报由首部（20 字节+可选字段）和数据两部分组成 分组转发 - (1) 从数据报的首部提取目的主机的 IP 地址 D, 得出目的网络地址为 N。 - (2) 若网络 N 与此路由器直接相连，则把数据报直接交付目的主机 D；否则是间接交付，执行(3)。 - (3) 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(4)。 - (4) 若路由表中有到达网络 N 的路由，则把数据报传送给路由表指明的下一跳路由器；否则，执行(5)。 - (5) 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行(6) - (6) 报告转发分组出错。 4.2划分子网 P128 两级IP地址缺陷： IP 地址空间的利用率有时很低。 给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。 两级的 IP 地址不够灵活 子网划分的基本思路： 划分子网纯属一个单位内部的事情，单位对外仍然表现为没有划分子网的网络。 划分子网的方法是从主机号借用若干个位作为子网号。 路由器在收到IP数据报后，按目标网络号和子网号定位目标子网 子网掩码 子网掩码是一个网络或一个子网的重要属性 这里要会已知IP地址，子网掩码，求网络地址 4.3构造超网（无分类编址CIDR） CIDR（无分类域间路由选择） 的主要特点： CIDR消除了传统的A、B、C类地址以及划分子网的概念，用网络前缀代替网络号和子网号，后面的部分指明主机。因此，CIDR使IP地址从三级编址(使用子网掩码)，又回到了两级编址，但这已是无分类的两级编址。 CIDR把网络前缀相同的连续的IP地址组成一个”CIDR地址块”只要知道CIDR地址块中的任何一个地址，就可以知道这地址块的起始地址(即最小地址)和最大地址，以及地址块中的地址数。 地址掩码：是一连串的1和0组成，而1的个数救赎网络前缀长度。在斜线记法中。斜线后面的数字就是地址掩码中1的个数。 构成超网：由于一个CIDR地址块中含有很多地址，所以在路由表中就利用CIDR地址块来查找目标网络，这种地址的聚合常称为路由聚合，也称构成超网。 4.4网际控制报文协议ICMP 为了更有效地转发IP数据报和提高交付成功的机会，在网际层使用了ICMP，ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。 ICMP报文的种类 ICMP差错报告报文 ICMP询问报文 ICMP 差错报告报文共有 5 种： 终点不可达 源点抑制(Source quench) 时间超过 参数问题 改变路由（重定向）(Redirect) ICMP 询问报文有两种： 回送请求和回答报文 时间戳请求和回答报文 4.5路由选择协议 两大类路由选择协议： 内部网关协议 IGP：一个自治系统内部使用的路由选择协议。有多种协议，如 RIP 和OSPF 协议。 外部网关协议EGP：一个自治系统的边界，将路由选择信息传递到另一个自治系统中。目前使用的就是BGP RIP协议的优缺点： - RIP 存在的一个问题是当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器。 - RIP 协议最大的优点就是实现简单，开销较小。 - RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。 - 路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。 RIP是一种分布式的基于距离向量的路由选择协议，其主要特点： （1）仅和相邻路由器交换信息。 （3）按固定的时间间隔交换路由信息，例如，每隔30秒。 OSPF最主要的特征就是使用分布式的链路状态协议，其主要特点： （1）使用洪泛法向本自治系统中所有路由器发送信息。 （2）发送的信息是与本路由器相邻的所有路由器的链路状态。 （3）只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。 BGP是不同自治系统的路由器之间交换路由信息的协议，它采用路径向量路由选择协议，其主要特点： （2）自治系统AS之间的路由选择必须考虑有关策略。 （3）BGP只能力求寻找一条能够到达目的网络且比较好的路由，而并非要寻找一条最佳路由。 五、运输层 5.1运输层协议概述 运输层功能 运输层为应用进程之间提供端到端的逻辑通信（但网络层是为主机之间提供逻辑通信） 运输层还要对收到的报文进行差错检测 运输层需要有两种不同的运输协议，即面向连接的 TCP 和无连接的 UDP 运输层的两个主要协议 TCP/IP 的运输层有两个不同的协议： - 用户数据报协议 UDP (User Datagram Protocol) - 传输控制协议 TCP (Transmission Control Protocol) UDP 在传送数据之前不需要先建立连接。对方的运输层在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 是一种最有效的工作方式。 TCP 则提供面向连接的服务。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。 运输层的端口 TCP/IP的运输层的端口用一个 16 位端口号进行标志 端口号只具备本地意义，即端口号只是为了标志本计算机应用层中的各进程。 客户发起通讯请求时，必须先知道对方服务器的IP地址和端口号，运输层的端口号分为下面三大类： 熟知端口号，数值一般为 0~1023。 一些常用的数值端口号： FTP 21 LELNET 23 SMTP 25 DNS 53 TFTP 69 HTTP 80 SNMP 161 SNMP(trap) 162 登记端口号，数值为1024~49151，为没有熟知端口号的应用程序使用的。 客户端口号或短暂端口号，数值为49152~65535，留给客户进程选择暂时使用。 5.2用户数据报协议 UDP UDP的主要特点： UDP 是无连接的，即发送数据之前不需要建立连接。 UDP 使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制 UDP 是面向报文的 UDP 没有拥塞控制，很适合多媒体通信的要求。 UDP 支持一对一、一对多、多对一和多对多的交互通信 UDP 的首部开销小，只有 8 个字节 5.3传输控制协议 TCP TCP的主要特点： TCP 是面向连接的运输层协议 每一条 TCP 连接只能有两个端点(endpoint)，每一条 TCP 连接只能是点对点的（一对一） TCP 提供可靠交付的服务 TCP 提供全双工通信 面向字节流 ","link":"https://Wangrongsheng.github.io/post/Nl-joqc6K/"},{"title":"深度学习中的batch、epoch、iteration","content":" 名词解释 名词 定义 Epoch 使用训练集的全部数据对模型进行一次完整的训练，被称为“一代训练” Batch 使用训练集中的一小部分样本对模型权重进行一次反向传播的参数更新，这一小部分样本被称为“一批数据” Iteration 使用一个Batch数据对模型进行一次参数更新的过程，被称之为“一次训练” （1）batchsize：批大小。在深度学习中，一般采用SGD训练，即每次训练在训练集中取batchsize个样本训练； （2）iteration：1个iteration等于使用batchsize个样本训练一次； （3）epoch：1个epoch等于使用训练集中的全部样本训练一次，通俗的讲epoch的值就是整个数据集被轮几次。 换算关系 梯度下降方式 Training Set Size Batch Size Number of Batches BGD N N 1 SGD N 1 N Mini-Batch N B N/B+1 实际上，梯度下降的几种方式的根本区别就在于上面公式中的Batch Size 不同。 *注：上表中 Mini-Batch 的 Batch 个数为 N / B + 1 是针对未整除的情况。整除则是 N / B。 示例 CIFAR10 数据集有 50000 张训练图片，10000 张测试图片。现在选择 Batch Size = 256 对模型进行训练。 每个 Epoch 要训练的图片数量：50000 训练集具有的 Batch 个数：50000/256 = 195+1 =196 每个 Epoch 需要完成的 Batch 个数：196 每个 Epoch 具有的 Iteration 个数：196 每个 Epoch 中发生模型权重更新的次数：196 训练 10 代后，模型权重更新的次数：196*10=1960 不同代的训练，其实用的是同一个训练集的数据。第 1 代和第 10 代虽然用的都是训练集的五万张图片，但是对模型的权重更新值却是完全不同的。因为不同代的模型处于代价函数空间上的不同位置，模型的训练代越靠后，越接近谷底，其代价越小。 ","link":"https://Wangrongsheng.github.io/post/v8nO-SL05/"},{"title":"Python「剪藏」网页为 PDF","content":" 简介 Python 的第三方库pdfkit ，这个模块可以将网页、html 文件以及字符串生成pdf文件。 把我们想要的网页保存到本地PDF文件，再结合PDF神器（Adobe Acrobat Pro DC）高亮标记文章的重点内容，很舒服~ 下面介绍一下使用pdfkit保存网页、html文件为pdf文件的具体过程。 安装使用 安装 使用pip安装pdfkit库 使用pip安装pdfkit 库： pip install pdfkit 安装wkhtmltopdf.exe文件 pdfkit 是基于wkhtmltopdf 的python 封装，需要安装wkhtmltopdf.exe 。wkhtmltopdf 是轻量级软件，非常很容易安装。 下载地址:https://wkhtmltopdf.org/downloads.html 去官网下载安装好之后，将安装目录下的bin添加到环境变量的path中。 环境变量配置在Windows上的步骤依次为：右键“此电脑”-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;系统变量-&gt;Path 使用 网页生成pdf：pdfkit.from_url() html文件生成pdf：pdfkit.from_file() 字符串生成pdf：pdfkit.from_string() 其中，第一个参数为准备保存的链接地址或者html文件，第二个参数为保存的文件路径。 # 导入库 import pdfkit path_wk = r'E:\\wkhtmltopdf\\bin\\wkhtmltopdf.exe' #安装位置 config = pdfkit.configuration(wkhtmltopdf = path_wk) pdfkit.from_url(r'https://zhuanlan.zhihu.com/p/140750619', 'wenzhang.pdf' ,configuration=config) ''' pdfkit.from_file('wenzhang.html','wenzhang1.pdf') pdfkit.from_string('Hello Pdf!','wenzhang2.pdf') ''' ","link":"https://Wangrongsheng.github.io/post/0CG3l2x-A/"},{"title":"如何正确向别人提问？","content":" ","link":"https://Wangrongsheng.github.io/post/8JRwIVUvN/"},{"title":"使用百度AI studio创建pytorch tensorflow gpu环境","content":" 教程 document.getElementById(\"spkj\").style.height=document.getElementById(\"spkj\").scrollWidth*0.76+\"px\"; 命令 mkdir /home/aistudio/cuda10 mkdir /home/aistudio/cuda92 mkdir /home/aistudio/cudnn mkdir /home/aistudio/tf cp /home/aistudio/data/data32924/cudnn-9.2.tgz /home/aistudio/cudnn cp /home/aistudio/data/data32924/cudnn-10.1.tgz /home/aistudio/cudnn pip install torch==1.5.0+cu101 torchvision==0.6.0+cu101 -f https://download.pytorch.org/whl/torch_stable.html -t /home/aistudio/cuda10 pip install torch==1.5.0+cu92 torchvision==0.6.0+cu92 -f https://download.pytorch.org/whl/torch_stable.html -t /home/aistudio/cuda92 pip install tensorflow-gpu==1.15 -t /home/aistudio/tf cd cudnn tar -zxvf cudnn-9.2.tgz tar -zxvf cudnn-10.1.tgz 进入GPU环境： import sys sys.path.append('/home/aistudio/cuda92') sys.path.append('/home/aistudio/tf') import torch import tensorflow as tf print(torch.cuda.is_available()) print(tf.test.is_built_with_cuda()) ","link":"https://Wangrongsheng.github.io/post/u_RYU_QNJ/"},{"title":"用OpenCV和Python构建车辆检测","content":" 简介 本篇文章中实现车辆检测采用视频中无监督目标检测方法，即不使用任何标记数据的目标检测。使用帧差分技术。 帧差分 视频是一组按正确顺序堆叠在一起的帧。所以，当我们看到一个物体在视频中移动时，这意味着这个物体在每一个连续的帧上都处于不同的位置。 如果我们假设在一对连续的帧中除了该目标之外，没有其他物体移动，那么第一帧与第二帧的像素差将突出显示移动目标的像素，从而我们可以得到移动物体的像素和坐标。这就是帧差分法的工作原理。 举个例子。考虑视频中的以下两个帧： 你能看出这两帧的区别吗？ 握笔手的位置从第1帧变为第2帧。其余的物体根本没有移动。所以，正如前面提到的，为了定位移动目标，我们将执行帧差分。结果如下： 你可以看到高亮或白色区域，这是手最初出现的地方。除此之外，记事本的边缘也会突出显示一点。这可能是由于手的移动改变了光照。建议不要对静止物体进行不必要的检测。因此，我们需要对帧执行某些图像预处理步骤。 构建车辆检测 导入库 import os import re import cv2 # opencv library import numpy as np from os.path import isfile, join import matplotlib.pyplot as plt 导入视频帧 请从此链接下载原始视频的帧。 将框架保存在工作目录中名为“frames”的文件夹中。从该文件夹中，我们将导入帧并将其保存在列表中： # get file names of the frames col_frames = os.listdir('frames/') # sort file names col_frames.sort(key=lambda f: int(re.sub('\\D', '', f))) # empty list to store the frames col_images=[] for i in col_frames: # read the frames img = cv2.imread('frames/'+i) # append the frames to the list col_images.append(img) 数据探索 让我们显示两个连续的帧： # plot 13th frame i = 13 for frame in [i, i+1]: plt.imshow(cv2.cvtColor(col_images[frame], cv2.COLOR_BGR2RGB)) plt.title(&quot;frame: &quot;+str(frame)) plt.show() 很难在这两个框架中找到区别，不是吗？如前所述，获取两个连续帧的像素值的差值将有助于我们观察移动目标。那么，让我们在上面两个帧上使用该技术： # convert the frames to grayscale grayA = cv2.cvtColor(col_images[i], cv2.COLOR_BGR2GRAY) grayB = cv2.cvtColor(col_images[i+1], cv2.COLOR_BGR2GRAY) # plot the image after frame differencing plt.imshow(cv2.absdiff(grayB, grayA), cmap = 'gray') plt.show() 现在我们可以清楚地看到第13帧和第14帧中的移动目标。其他没有移动的东西都被减去了。 图像预处理 让我们看看对上面的图像应用阈值后会发生什么： diff_image = cv2.absdiff(grayB, grayA) # perform image thresholding ret, thresh = cv2.threshold(diff_image, 30, 255, cv2.THRESH_BINARY) # plot image after thresholding plt.imshow(thresh, cmap = 'gray') plt.show() 现在，移动物体（车辆）看起来更像我们期望看到的那样了，大部分噪音（不希望出现的白色区域）都消失了。但是，突出显示的区域有点零碎。因此，我们可以对该图像应用图像膨胀： # apply image dilation kernel = np.ones((3,3),np.uint8) dilated = cv2.dilate(thresh,kernel,iterations = 1) # plot dilated image plt.imshow(dilated, cmap = 'gray') plt.show() 移动的物体有更多的实心高亮区域。希望帧中每个目标的轮廓数不超过3。 但是，我们不会使用整个框架来检测移动的车辆。我们将首先选择一个区域，如果车辆进入该区域，则仅检测到该区域。 那么，我们将会使用的区域: # plot vehicle detection zone plt.imshow(dilated) cv2.line(dilated, (0, 80),(256,80),(100, 0, 0)) plt.show() 水平线y = 80以下的区域是我们的车辆检测区域。我们将只检测在这个区域发生的任何移动。你还可以创建自己的检测区。 现在让我们在上述帧的检测区域中找到轮廓： # find contours contours, hierarchy = cv2.findContours(thresh.copy(),cv2.RETR_TREE,cv2.CHAIN_APPROX_NONE) 上面的代码查找整个图像中的所有轮廓，并将它们保存在变量&quot;contours&quot;中。由于我们只需要找到检测区域中存在的轮廓，我们将对发现的轮廓进行两次检查。 第一个检查是轮廓左上角的y坐标是否应大于等于80（我这里包括另一个检查，x坐标小于等于200）。另一个检查是轮廓的面积是否大于等于25。在cv2.courtoArea() 函数的帮助下，你可以找到轮廓区域。 valid_cntrs = [] for i,cntr in enumerate(contours): x,y,w,h = cv2.boundingRect(cntr) if (x &lt;= 200) &amp; (y &gt;= 80) &amp; (cv2.contourArea(cntr) &gt;= 25): valid_cntrs.append(cntr) # count of discovered contours len(valid_cntrs) 接下来，让我们绘制轮廓和原始帧: dmy = col_images[13].copy() cv2.drawContours(dmy, valid_cntrs, -1, (127,200,0), 2) cv2.line(dmy, (0, 80),(256,80),(100, 255, 255)) plt.imshow(dmy) plt.show() 太酷了！只有位于检测区域内的车辆轮廓可见。这就是我们在整个画面中检测车辆的方法 视频中的车辆检测 现在是时候对所有帧应用相同的图像变换和预处理操作，并找到所需的轮廓。重申一下，我们将遵循以下步骤： 对每对连续帧应用帧差分 对上一步的输出图像应用图像阈值 对上一步的输出图像进行图像放大 在上一步的输出图像中查找轮廓 检测区域出现的候选轮廓 保存帧与最终轮廓 # kernel for image dilation kernel = np.ones((4,4),np.uint8) # font style font = cv2.FONT_HERSHEY_SIMPLEX # directory to save the ouput frames pathIn = &quot;contour_frames_3/&quot; for i in range(len(col_images)-1): # frame differencing grayA = cv2.cvtColor(col_images[i], cv2.COLOR_BGR2GRAY) grayB = cv2.cvtColor(col_images[i+1], cv2.COLOR_BGR2GRAY) diff_image = cv2.absdiff(grayB, grayA) # image thresholding ret, thresh = cv2.threshold(diff_image, 30, 255, cv2.THRESH_BINARY) # image dilation dilated = cv2.dilate(thresh,kernel,iterations = 1) # find contours contours, hierarchy = cv2.findContours(dilated.copy(), cv2.RETR_TREE,cv2.CHAIN_APPROX_NONE) # shortlist contours appearing in the detection zone valid_cntrs = [] for cntr in contours: x,y,w,h = cv2.boundingRect(cntr) if (x &lt;= 200) &amp; (y &gt;= 80) &amp; (cv2.contourArea(cntr) &gt;= 25): if (y &gt;= 90) &amp; (cv2.contourArea(cntr) &lt; 40): break valid_cntrs.append(cntr) # add contours to original frames dmy = col_images[i].copy() cv2.drawContours(dmy, valid_cntrs, -1, (127,200,0), 2) cv2.putText(dmy, &quot;vehicles detected: &quot; + str(len(valid_cntrs)), (55, 15), font, 0.6, (0, 180, 0), 2) cv2.line(dmy, (0, 80),(256,80),(100, 255, 255)) cv2.imwrite(pathIn+str(i)+'.png',dmy) 准备视频 在这里，我们为所有帧中的所有移动车辆添加了轮廓。现在是时候堆叠帧并创建视频了： # specify video name pathOut = 'vehicle_detection_v3.mp4' # specify frames per second fps = 14.0 接下来，我们将阅读列表中的最后一帧： frame_array = [] files = [f for f in os.listdir(pathIn) if isfile(join(pathIn, f))] files.sort(key=lambda f: int(re.sub('\\D', '', f))) for i in range(len(files)): filename=pathIn + files[i] #read frames img = cv2.imread(filename) height, width, layers = img.shape size = (width,height) #inserting the frames into an image array frame_array.append(img) 制作目标检测视频 最后，我们将使用以下代码制作目标检测视频： out = cv2.VideoWriter(pathOut,cv2.VideoWriter_fourcc(*'DIVX'), fps, size) for i in range(len(frame_array)): # writing to a image array out.write(frame_array[i]) out.release() 全代码 #导入库 import os import re import cv2 # opencv library import numpy as np from os.path import isfile, join import matplotlib.pyplot as plt # 导入视频帧 # get file names of the frames col_frames = os.listdir('frames/') # sort file names col_frames.sort(key=lambda f: int(re.sub('\\D', '', f))) # empty list to store the frames col_images=[] for i in col_frames: # read the frames img = cv2.imread('frames/'+i) # append the frames to the list col_images.append(img) # 数据探索 # plot 13th frame i = 13 for frame in [i, i+1]: plt.imshow(cv2.cvtColor(col_images[frame], cv2.COLOR_BGR2RGB)) plt.title(&quot;frame: &quot;+str(frame)) plt.show() # 像素差值展示 # convert the frames to grayscale grayA = cv2.cvtColor(col_images[i], cv2.COLOR_BGR2GRAY) grayB = cv2.cvtColor(col_images[i+1], cv2.COLOR_BGR2GRAY) # plot the image after frame differencing plt.imshow(cv2.absdiff(grayB, grayA), cmap = 'gray') plt.show() # 图像预处理 diff_image = cv2.absdiff(grayB, grayA) # perform image thresholding ret, thresh = cv2.threshold(diff_image, 30, 255, cv2.THRESH_BINARY) # plot image after thresholding plt.imshow(thresh, cmap = 'gray') plt.show() # 图像膨胀 # apply image dilation kernel = np.ones((3,3),np.uint8) dilated = cv2.dilate(thresh,kernel,iterations = 1) # plot dilated image plt.imshow(dilated, cmap = 'gray') plt.show() # 区域选定 # plot vehicle detection zone plt.imshow(dilated) cv2.line(dilated, (0, 80),(256,80),(100, 0, 0)) plt.show() # find contours contours, hierarchy = cv2.findContours(thresh.copy(),cv2.RETR_TREE,cv2.CHAIN_APPROX_NONE) # valid_cntrs = [] for i,cntr in enumerate(contours): x,y,w,h = cv2.boundingRect(cntr) if (x &lt;= 200) &amp; (y &gt;= 80) &amp; (cv2.contourArea(cntr) &gt;= 25): valid_cntrs.append(cntr) # count of discovered contours len(valid_cntrs) dmy = col_images[13].copy() cv2.drawContours(dmy, valid_cntrs, -1, (127,200,0), 2) cv2.line(dmy, (0, 80),(256,80),(100, 255, 255)) plt.imshow(dmy) plt.show() # kernel for image dilation kernel = np.ones((4,4),np.uint8) # font style font = cv2.FONT_HERSHEY_SIMPLEX # directory to save the ouput frames pathIn = &quot;contour_frames_3/&quot; for i in range(len(col_images)-1): # frame differencing grayA = cv2.cvtColor(col_images[i], cv2.COLOR_BGR2GRAY) grayB = cv2.cvtColor(col_images[i+1], cv2.COLOR_BGR2GRAY) diff_image = cv2.absdiff(grayB, grayA) # image thresholding ret, thresh = cv2.threshold(diff_image, 30, 255, cv2.THRESH_BINARY) # image dilation dilated = cv2.dilate(thresh,kernel,iterations = 1) # find contours contours, hierarchy = cv2.findContours(dilated.copy(), cv2.RETR_TREE,cv2.CHAIN_APPROX_NONE) # shortlist contours appearing in the detection zone valid_cntrs = [] for cntr in contours: x,y,w,h = cv2.boundingRect(cntr) if (x &lt;= 200) &amp; (y &gt;= 80) &amp; (cv2.contourArea(cntr) &gt;= 25): if (y &gt;= 90) &amp; (cv2.contourArea(cntr) &lt; 40): break valid_cntrs.append(cntr) # add contours to original frames dmy = col_images[i].copy() cv2.drawContours(dmy, valid_cntrs, -1, (127,200,0), 2) cv2.putText(dmy, &quot;vehicles detected: &quot; + str(len(valid_cntrs)), (55, 15), font, 0.6, (0, 180, 0), 2) cv2.line(dmy, (0, 80),(256,80),(100, 255, 255)) cv2.imwrite(pathIn+str(i)+'.png',dmy) # 准备视频 # specify video name pathOut = 'vehicle_detection_v3.mp4' # specify frames per second fps = 14.0 frame_array = [] files = [f for f in os.listdir(pathIn) if isfile(join(pathIn, f))] files.sort(key=lambda f: int(re.sub('\\D', '', f))) for i in range(len(files)): filename=pathIn + files[i] #read frames img = cv2.imread(filename) height, width, layers = img.shape size = (width,height) #inserting the frames into an image array frame_array.append(img) out = cv2.VideoWriter(pathOut,cv2.VideoWriter_fourcc(*'DIVX'), fps, size) for i in range(len(frame_array)): # writing to a image array out.write(frame_array[i]) out.release() 文件格式 初始化时你的文件的格式为： . ├── 车辆识别.py ├── frames └── contour_frames_3 演示视频 document.getElementById(\"spkj\").style.height=document.getElementById(\"spkj\").scrollWidth*0.76+\"px\"; ","link":"https://Wangrongsheng.github.io/post/Z81AYL98W/"},{"title":"数据增强及实现","content":" 什么是数据增强 Data Augmentation ，基于有限的数据生成更多等价（同样有效）的数据，丰富训练数据的分布，使通过训练集得到的模型泛化能力更强。 数据增强分类 数据增强可以分为两类，一类是离线增强，一类是在线增强。 离线增强 ： 直接对数据集进行处理，数据的数目会变成增强因子乘以原数据集的数目，这种方法常常用于数据集很小的时候。 在线增强 ： 这种增强的方法用于，获得 batch 数据之后，然后对这个 batch 的数据进行增强，如旋转、平移、翻折等相应的变化，由于有些数据集不能接受线性级别的增长，这种方法长用于大的数据集，很多机器学习框架已经支持了这种数据增强方式，并且可以使用 GPU 优化计算。 数据增强作用 数据增强让有限的数据产生更多的数据，增加训练样本的数量以及多样性（噪声数据），提升模型鲁棒性。神经网络需要大量的参数，许许多多的神经网路的参数都是数以百万计，而使得这些参数可以正确工作则需要大量的数据进行训练，但在很多实际的项目中，我们难以找到充足的数据来完成任务。 随机改变训练样本可以降低模型对某些属性的依赖，从而提高模型的泛化能力。 数据增强方法 旋转|反射变换(Rotation/reflection)：随机旋转图像一定角度; 改变图像内容的朝向; 翻转变换(flip): 沿着水平或者垂直方向翻转图像; 缩放变换(zoom): 按照一定的比例放大或者缩小图像; 平移变换(shift): 在图像平面上对图像以一定方式进行平移; 可以采用随机或人为定义的方式指定平移范围和平移步长, 沿水平或竖直方向进行平移. 改变图像内容的位置; 尺度变换(scale): 对图像按照指定的尺度因子, 进行放大或缩小; 或者参照SIFT特征提取思想, 利用指定的尺度因子对图像滤波构造尺度空间. 改变图像内容的大小或模糊程度; 对比度变换(contrast): 在图像的HSV颜色空间，改变饱和度S和V亮度分量，保持色调H不变. 对每个像素的S和V分量进行指数运算(指数因子在0.25到4之间), 增加光照变化; 噪声扰动(noise): 对图像的每个像素RGB进行随机扰动, 常用的噪声模式是椒盐噪声和高斯噪声; 颜色变换(color): 在训练集像素值的RGB颜色空间进行PCA, 得到RGB空间的3个主方向向量,3个特征值, p1, p2, p3, λ1, λ2, λ3. 对每幅图像的每个像素Ixy=[IRxy,IGxy,IBxy]T进行加上如下的变化:[p1,p2,p3][α1λ1,α2λ2,α3λ3]T；其中:αi是满足均值为0,方差为0.1的随机变量。 数据增强实现 多框架实现 包含PIL、tensorflow、pytorch、keras实现 深度学习中的数据增强与实现 单独实现 import matplotlib.pyplot as plt from PIL import Image,ImageChops,ImageEnhance import numpy as np import skimage %matplotlib inline plt.rc('font', family='SimHei', size=13) img_path='./test.jpg' img_data = Image.open(img_path) 翻转 # 竖直翻转 image_1 = np.array(img_data) img2 = image_1[::-1, :, :] plt.subplot(1, 2, 1) plt.imshow(img2) plt.title(&quot;竖直翻转&quot;) # 水平翻转 img3 = image_1[:, ::-1, :] plt.subplot(1, 2, 2) plt.imshow(img3) plt.title(&quot;水平翻转&quot;) plt.show() 裁剪 img = img_data.crop((200, 100, 800, 500)) # 参数为坐标左上右下 plt.subplot(1, 2, 2) plt.imshow(img) plt.title(&quot;PIL&quot;) plt.show() 旋转 img = img_data.rotate(90) # 逆时针旋转 plt.subplot(1, 2, 2) plt.title(&quot;PIL&quot;) plt.imshow(img) plt.show() 缩放变形 plt.subplot(1,2,1) plt.title(&quot;original&quot;) plt.imshow(img_data) img = img_data.crop((200, 100, 800, 500)) img = img.resize((1000,600),resample=Image.LANCZOS) plt.subplot(1,2,2) plt.title(&quot;scale&quot;) plt.imshow(img) plt.show() 平移变换 plt.subplot(1,2,1) plt.title(&quot;original&quot;) plt.imshow(img) img = ImageChops.offset(img_data,200,100) plt.subplot(1,2,2) plt.title(&quot;scale&quot;) plt.imshow(img) plt.show() 颜色变换 # 调整图像的饱和度 random_factor1 = np.random.randint(5, 20) / 10. # 随机因子 color_image = ImageEnhance.Color(img_data).enhance(random_factor1) # 调整图像的亮度 random_factor2 = np.random.randint(5, 21) / 10. brightness_image = ImageEnhance.Brightness(img_data).enhance(random_factor2) # 调整图像对比度 random_factor3 = np.random.randint(5, 20) / 10. contrast_image = ImageEnhance.Contrast(img_data).enhance(random_factor3) # 调整图像的锐度 random_factor4 = np.random.randint(5, 20) / 10. sharp_image = ImageEnhance.Sharpness(img_data).enhance(random_factor4) plt.subplot(2,2,1) plt.title(&quot;饱和度&quot;) plt.imshow(color_image) plt.subplot(2,2,2) plt.title(&quot;亮度&quot;) plt.imshow(brightness_image) plt.subplot(2,2,3) plt.title(&quot;对比度&quot;) plt.imshow(contrast_image) plt.subplot(2,2,4) plt.title(&quot;锐度&quot;) plt.imshow(sharp_image) 噪声变换 img = np.array(img_data) plt.subplot(1, 2, 1) plt.title(&quot;origin&quot;) plt.imshow(img_data) img_noise = skimage.util.random_noise(img, mode=&quot;gaussian&quot;) plt.subplot(1, 2, 2) plt.title(&quot;gaussian&quot;) plt.imshow(img_noise) plt.show() 更丰富的噪声变换 import numpy as np from PIL import Image import matplotlib.pyplot as plt import math import random import cv2 import scipy.misc import scipy.signal import scipy.ndimage def medium_filter(im, x, y, step): sum_s=[] for k in range(-int(step/2),int(step/2)+1): for m in range(-int(step/2),int(step/2)+1): sum_s.append(im[x+k][y+m]) sum_s.sort() return sum_s[(int(step*step/2)+1)] def mean_filter(im, x, y, step): sum_s = 0 for k in range(-int(step/2),int(step/2)+1): for m in range(-int(step/2),int(step/2)+1): sum_s += im[x+k][y+m] / (step*step) return sum_s def convert_2d(r): n = 3 # 3*3 滤波器, 每个系数都是 1/9 window = np.ones((n, n)) / n ** 2 # 使用滤波器卷积图像 # mode = same 表示输出尺寸等于输入尺寸 # boundary 表示采用对称边界条件处理图像边缘 s = scipy.signal.convolve2d(r, window, mode='same', boundary='symm') return s.astype(np.uint8) # def convert_3d(r): # s_dsplit = [] # for d in range(r.shape[2]): # rr = r[:, :, d] # ss = convert_2d(rr) # s_dsplit.append(ss) # s = np.dstack(s_dsplit) # return s def add_salt_noise(img): rows, cols, dims = img.shape R = np.mat(img[:, :, 0]) G = np.mat(img[:, :, 1]) B = np.mat(img[:, :, 2]) Grey_sp = R * 0.299 + G * 0.587 + B * 0.114 Grey_gs = R * 0.299 + G * 0.587 + B * 0.114 snr = 0.9 mu = 0 sigma = 0.12 noise_num = int((1 - snr) * rows * cols) for i in range(noise_num): rand_x = random.randint(0, rows - 1) rand_y = random.randint(0, cols - 1) if random.randint(0, 1) == 0: Grey_sp[rand_x, rand_y] = 0 else: Grey_sp[rand_x, rand_y] = 255 Grey_gs = Grey_gs + np.random.normal(0, 48, Grey_gs.shape) Grey_gs = Grey_gs - np.full(Grey_gs.shape, np.min(Grey_gs)) Grey_gs = Grey_gs * 255 / np.max(Grey_gs) Grey_gs = Grey_gs.astype(np.uint8) # 中值滤波 Grey_sp_mf = scipy.ndimage.median_filter(Grey_sp, (8, 8)) Grey_gs_mf = scipy.ndimage.median_filter(Grey_gs, (8, 8)) # 均值滤波 n = 3 window = np.ones((n, n)) / n ** 2 Grey_sp_me = convert_2d(Grey_sp) Grey_gs_me = convert_2d(Grey_gs) plt.subplot(321) plt.title('Grey salt and pepper noise') plt.imshow(Grey_sp, cmap='gray') plt.subplot(322) plt.title('Grey gauss noise') plt.imshow(Grey_gs, cmap='gray') plt.subplot(323) plt.title('Grey salt and pepper noise (medium)') plt.imshow(Grey_sp_mf, cmap='gray') plt.subplot(324) plt.title('Grey gauss noise (medium)') plt.imshow(Grey_gs_mf, cmap='gray') plt.subplot(325) plt.title('Grey salt and pepper noise (mean)') plt.imshow(Grey_sp_me, cmap='gray') plt.subplot(326) plt.title('Grey gauss noise (mean)') plt.imshow(Grey_gs_me, cmap='gray') plt.show() def main(): img = np.array(Image.open('./test.jpg')) add_salt_noise(img) if __name__ == '__main__': main() 遮挡 paste_data = Image.open(&quot;./demo.png&quot;) img_data.paste(paste_data,(200,300,200+paste_data.size[0],300+paste_data.size[1])) ","link":"https://Wangrongsheng.github.io/post/FIhedg2M1/"},{"title":"图片数据集制作","content":" 简介 进行图片数据的制作是我们进行AI实践的必须操作，除了公开的官方数据集，我们自己制作数据集将会是更好的方法。在这里我将介绍用一种方法来制作图片数据集：先拍个视频然后把视频转化成图片。用ffmpeg 工具。 使用 安装ffmpeg 工具 sudo apt-get install -y autoconf automake build-essential git libass-dev libfreetype6-dev libsdl2-dev libtheora-dev libtool libva-dev libvdpau-dev libvorbis-dev libxcb1-dev libxcb-shm0-dev libxcb-xfixes0-dev pkg-config texinfo wget zlib1g-dev sudo add-apt-repository ppa:djcj/hybrid sudo apt-get update sudo apt-get install ffmpeg 图片获取 ffmpeg -i ./test/video.mp4 -r 10 -f image2 ./destination/%05d.jpg ./test/video.mp4 表示要转化的视频 10 表示每秒保存10帧 ./destination 表示转的的图片存储目录 %05d.jpg 图片命名规则，表示5位数不够用0补足，除了.jpg 还可以是.png 、.bmp 等格式 其他方法 python工具-将视频按帧截取图片 如何使用Python+Opencv将视频切分成帧图片 ","link":"https://Wangrongsheng.github.io/post/yVrGpH1pe/"},{"title":"好玩的ping命令","content":" ping 基本使用详解 在网络中 ping 是一个十分强大的 TCP/IP 工具。它的作用主要为： 1、用来检测网络的连通情况和分析网络速度 2、根据域名得到服务器 IP 3、根据 ping 返回的 TTL 值来判断对方所使用的操作系统及数据包经过路由器数量。 我们通常会用它来直接 ping ip 地址，来测试网络的连通情况。 类如这种，直接 ping ip 地址或网关，ping 通会显示出以上数据。 字节值：数据包大小。 时间值：响应时间，这个时间越小，说明你连接这个地址速度越快。 TTL 值：Time To Live, 表示 DNS 记录在 DNS 服务器上存在的时间，它是 IP 协议包的一个值，告诉路由器该数据包何时需要被丢弃。可以通过 Ping 返回的 TTL 值大小，粗略地判断目标系统类型是 Windows 系列还是 UNIX/Linux 系列。 默认情况下，Linux 系统的 TTL 值为 64 或 255，WindowsNT/2000/XP 系统的 TTL 值为 128，Windows98 系统的 TTL 值为 32，UNIX 主机的 TTL 值为 255。 因此一般 TTL 值： 100~130ms 之间，Windows 系统 ； 240~255ms 之间，UNIX/Linux 系统。 ping 命令除了直接 ping 网络的 ip 地址，验证网络畅通和速度之外，它还有这些用法。 命令使用 ping -t 的使用 不间断地 Ping 指定计算机，直到管理员中断。 这就说明电脑连接路由器是通的，网络效果很好。下面按按住键盘的 Ctrl+c 终止它继续 ping 下去，就会停止了，会总结出运行的数据包有多少，通断的有多少了。 ping -a 的使用 ping-a 解析计算机名与 NetBios 名。就是可以通过 ping 它的 ip 地址，可以解析出主机名。 ping -n 的使用 在默认情况下，一般都只发送四个数据包，通过这个命令可以自己定义发送的个数，对衡量网络速度很有帮助，比如我想测试发送 10 个数据包的返回的平均时间为多少，最快时间为多少，最慢时间为多少就可以通过以下获知： 从以上我就可以知道在给 220.181.38.148 发送 10 个数据包的过程当中，返回了 10 个，没有丢失，这 10 个数据包当中返回速度最快为 21ms，最慢为 23ms，平均速度为 22ms。说明我的网络良好。 如果对于一些不好的网络，比如监控系统中非常卡顿，这样测试，返回的结果可能会显示出丢失出一部分，如果丢失的比较多的话，那么就说明网络不好，可以很直观的判断出网络的情况。 ping -l size 的使用 -l size：发送 size 指定大小的到目标主机的数据包。 在默认的情况下 Windows 的 ping 发送的数据包大小为 32byt，最大能发送 65500byt。当一次发送的数据包大于或等于 65500byt 时，将可能导致接收方计算机宕机。所以微软限制了这一数值；这个参数配合其它参数以后危害非常强大，比如攻击者可以结合 - t 参数实施 DOS 攻击。（所以它具有危险性，不要轻易向别人计算机使用）。 例如：ping -l 65500 -t ip 会连续对 IP 地址执行 ping 命令，直到被用户以 Ctrl+C 中断。 这样它就会不停的向指定计算机发送大小为 65500byt 的数据包，如果你只有一台计算机也许没有什么效果，但如果有很多计算机那么就可以使对方完全瘫痪，网络严重堵塞，由此可见威力非同小可。 ping -r count 的使用 在 “记录路由” 字段中记录传出和返回数据包的路由，探测经过的路由个数，但最多只能跟踪到 9 个路由。 ping -n 1 -r 9 ip （发送一个数据包，最多记录 9 个路由） 批量 Ping 网段 对于一个网段 ip 地址众多，如果单个检测实在麻烦，那么我们可以直接批量 ping 网段检测，那个 ip 地址出了问题，一目了然。 先看代码，直接在命令行窗口输入： for /L %D in (1,1,255) do ping 10.168.1.%D IP 地址段修改成你要检查的 IP 地址段。 当输入批量命令后，那么它就自动把网段内所有的 ip 地址都 ping 完为止。 那么这段 “for /L %D in(1,1,255) do ping 10.168.1.%D” 代码是什么意思呢？ 代码中的这个 (1,1,255) 就是网段起与始，就是检测网段 192.168.1.1 到 192.168.1.255 之间的所有的 ip 地址，每次逐增 1，直接到 1 到 255 这 255 个 ip 检测完为止。 ","link":"https://Wangrongsheng.github.io/post/8b986l-is/"},{"title":"感知机","content":" 感知机是一种较为简单的二分类模型，但由简至繁，感知机却是神经网络和支持向量机的基础。感知机旨在学习能够将输入数据划分为+1/-1的线性分离超平面，所以说整体而言感知机是一种线性模型。因为是线性模型，所以感知机的原理并不复杂。 感知机原理 假设输入x表示为任意实例的特征向量，输出y={+1,-1}为实例的类别。感知机定义由输入到输出的映射函数如下： 其中sign符号函数为： w和b为感知机模型参数，也是感知机要学习的东西。w和b构成的线性方程wx+b=0极为线性分离超平面。 假设数据是线性可分的，当然有且仅在数据线性可分的情况下，感知机才能奏效。感知机模型简单，但这也是其缺陷之一。所谓线性可分，也即对于任何输入和输出数据都存在某个线性超平面wx+b=0能够将数据集中的正实例点和负实例点完全正确的划分到超平面两侧，这样数据集就是线性可分的。 感知机的训练目标就是找到这个线性可分的超平面。为此，定义感知机模型损失函数如下： 要优化这个损失函数，可采用梯度下降法对参数进行更新以最小化损失函数。计算损失函数关于参数w和b的梯度如下： 由上可知完整的感知机算法包括参数初始化、对每个数据点判断其是否误分，如果误分，则按照梯度下降法更新超平面参数，直至没有误分类点。 以上便是感知机算法的基本原理。当然这里说的感知机仅限于单层的感知机模型，仅适用于线性可分的情况。 代码实现 import copy from matplotlib import pyplot as plt from matplotlib import animation training_set = [[(1, 2), 1], [(2, 3), 1], [(3, 1), -1], [(4, 2), -1]] # 训练数据集 w = [0, 0] # 参数初始化 b = 0 history = [] # 用来记录每次更新过后的w,b def update(item): &quot;&quot;&quot; 随机梯度下降更新参数 :param item: 参数是分类错误的点 :return: nothing 无返回值 &quot;&quot;&quot; global w, b, history # 把w, b, history声明为全局变量 w[0] += 1 * item[1] * item[0][0] # 根据误分类点更新参数,这里学习效率设为1 w[1] += 1 * item[1] * item[0][1] b += 1 * item[1] history.append([copy.copy(w), b]) # 将每次更新过后的w,b记录在history数组中 def cal(item): &quot;&quot;&quot; 计算item到超平面的距离,输出yi(w*xi+b) （我们要根据这个结果来判断一个点是否被分类错了。如果yi(w*xi+b)&gt;0,则分类错了） :param item: :return: &quot;&quot;&quot; res = 0 for i in range(len(item[0])): # 迭代item的每个坐标，对于本文数据则有两个坐标x1和x2 res += item[0][i] * w[i] res += b res *= item[1] # 这里是乘以公式中的yi return res def check(): &quot;&quot;&quot; 检查超平面是否已将样本正确分类 :return: true如果已正确分类则返回True &quot;&quot;&quot; flag = False for item in training_set: if cal(item) &lt;= 0: # 如果有分类错误的 flag = True # 将flag设为True update(item) # 用误分类点更新参数 if not flag: # 如果没有分类错误的点了 print(&quot;最终结果: w: &quot; + str(w) + &quot;b: &quot; + str(b)) # 输出达到正确结果时参数的值 return flag # 如果已正确分类则返回True,否则返回False if __name__ == &quot;__main__&quot;: for i in range(1000): # 迭代1000遍 if not check(): break # 如果已正确分类，则结束迭代 # 以下代码是将迭代过程可视化 # 首先建立我们想要做成动画的图像figure, 坐标轴axis,和plot element fig = plt.figure() ax = plt.axes(xlim=(0, 2), ylim=(-2, 2)) line, = ax.plot([], [], 'g', lw=2) # 画一条线 label = ax.text([], [], '') def init(): line.set_data([], []) x, y, x_, y_ = [], [], [], [] for p in training_set: if p[1] &gt; 0: x.append(p[0][0]) # 存放yi=1的点的x1坐标 y.append(p[0][1]) # 存放yi=1的点的x2坐标 else: x_.append(p[0][0]) # 存放yi=-1的点的x1坐标 y_.append(p[0][1]) # 存放yi=-1的点的x2坐标 plt.plot(x, y, 'bo', x_, y_, 'rx') # 在图里yi=1的点用点表示，yi=-1的点用叉表示 plt.axis([-6, 6, -6, 6]) # 横纵坐标上下限 plt.grid(True) # 显示网格 plt.xlabel('x1') # 这里我修改了原文表示 plt.ylabel('x2') # 为了和原理中表达方式一致，横纵坐标应该是x1,x2 plt.title('Perceptron Algorithm (www.hankcs.com)') # 给图一个标题：感知机算法 return line, label def animate(i): global history, ax, line, label w = history[i][0] b = history[i][1] if w[1] == 0: return line, label # 因为图中坐标上下限为-6~6，所以我们在横坐标为-7和7的两个点之间画一条线就够了，这里代码中的xi,yi其实是原理中的x1,x2 x1 = -7 y1 = -(b + w[0] * x1) / w[1] x2 = 7 y2 = -(b + w[0] * x2) / w[1] line.set_data([x1, x2], [y1, y2]) # 设置线的两个点 x1 = 0 y1 = -(b + w[0] * x1) / w[1] label.set_text(history[i]) label.set_position([x1, y1]) return line, label print(&quot;参数w,b更新过程：&quot;, history) anim = animation.FuncAnimation(fig, animate, init_func=init, frames=len(history), interval=1000, repeat=True, blit=True) plt.show() ","link":"https://Wangrongsheng.github.io/post/L_hVjPvE0/"},{"title":"微信公众号接入网课查题功能","content":" 网课查题功能添加 1、 访问 http://api.51aidian.com/ 申请id和token ； 2、 token值系统自动生成，只需自定义输入id 即可； 3、 登录公众号后台，找到“基本配置”，开启开发者密码； 4、 点击修改配置； 5、 填写配置： url输入：http://api.51aidian.com/api/api.php?id=自己申请得到的id token：输入申请得到的token值 EncodingAESKey：随机生成即可 6、点击启动； 7、对接完成； 网课答案公众号推荐 答案一点通 智慧的树知到免费答案 帅搜 墨水校园 PP题库 GJ网课查题 呆小槑 教书的先生 学小易 ","link":"https://Wangrongsheng.github.io/post/HkKtStsCl/"},{"title":"SCI论文投稿全程模板","content":" 最初投稿Cover letter Dear Editors: We would like to submit the enclosed manuscript entitled “Paper Title”, which we wish to be considered for publication in “Journal Name”. No conflict of interest exists in the submission of this manuscript, and the manuscript is approved by all authors for publication. I would like to declare on behalf of my co-authors that the work described was original research that has not been published previously, and not under consideration for publication elsewhere, in whole or in part. All the authors listed have approved the manuscript that is enclosed. In this work, we evaluated …… (简要介绍一下论文的创新性). I hope this paper is suitable for “Journal Name”. The following is a list of possible reviewers for your consideration: 1) Name A E-mail: ××××@×××× 2) Name B E-mail: ××××@×××× We deeply appreciate your consideration of our manuscript, and we look forward to receiving comments from the reviewers. If you have any queries, please don’t hesitate to contact me at the address below. Thank you and best regards. Yours sincerely, ×××××× Corresponding author: Name: ××× Institution: xxx E-mail: ××××@×××× 催稿信 Dear Prof. ×××: Sorry for disturbing you. I am not sure if it is the right time to contact you to inquire about the status of my submitted manuscript titled “Paper Title”. (ID: 文章稿号), although the status of “With Editor” has been lasting for more than two months, since submitted to journal three months ago. I am just wondering if my manuscript has been sent to reviewers or not. I would be greatly appreciated if you could spend some of your time check the status for us. I am very pleased to hear from you on the reviewer’s comments. Thank you very much for your consideration. Best regards! Yours sincerely, ×××××× Corresponding author: Name: ××× Institution: xxx E-mail: ××××@×××× 修改稿Cover letter Dear Dr/ Prof..（写上负责你文章编辑的姓名，显得尊重，因为第一次的投稿不知道具体负责的编辑，只能用通用的Editors）: On behalf of my co-authors, we thank you very much for giving us an opportunity to revise our manuscript, we appreciate editor and reviewers very much for their positive and constructive comments and suggestions on our manuscript entitled “Paper Title”. (ID: 文章稿号). We have studied reviewer’s comments carefully and have made revision which marked in red in the paper. We have tried our best to revise our manuscript according to the comments. Attached please find the revised version, which we would like to submit for your kind consideration. We would like to express our great appreciation to you and reviewers for comments on our paper. Looking forward to hearing from you. Thank you and best regards. Yours sincerely, ×××××× Corresponding author: Name: ××× Institution: xxx E-mail: ××××@×××× 修改稿回答审稿人的意见 （最重要的部分） List of Responses Dear Editors and Reviewers: Thank you for your letter and for the reviewers’ comments concerning our manuscript entitled “Paper Title” (ID: 文章稿号). Those comments are all valuable and very helpful for revising and improving our paper, as well as the important guiding significance to our research. We have studied comments carefully and have made the correction which we hope meet with approval. The revised portion is marked in red in the paper. The main corrections in the paper and the responses to the reviewer’s comments are as flowing: Responds to the reviewer’s comments: Reviewer #1: 1. Response to comment: (……简要列出意见……) Response: ×××××× 2. Response to comment: (……简要列出意见……) Response: ×××××× 。。。。。。 逐条意见回答，切忌一定不能有遗漏 针对不同的问题有下列几个礼貌术语可适当用用： We are very sorry for our negligence of ……... We are very sorry for our incorrect writing ……... It is really true as Reviewer suggested that…… We have made the correction according to the Reviewer’s comments. We have re-written this part according to the Reviewer’s suggestion As Reviewer suggested that…… Considering the Reviewer’s suggestion, we have …… 最后特意感谢一下这个审稿人的意见： Special thanks to you for your good comments. Reviewer #2: 同上述 Reviewer #3: ×××××× Other changes: 1. Line 60-61, the statements of “……” were corrected as “…………” 2. Line 107, “……” was added 3. Line 129, “……” was deleted ×××××× We tried our best to improve the manuscript and made some changes in the manuscript. These changes will not influence the content and framework of the paper. And here we did not list the changes but marked in red in revised paper. We appreciate for Editors/Reviewers’ warm work earnestly and hope that the correction will meet with approval. Once again, thank you very much for your comments and suggestions. 负责你文章的编辑或主编 （根据需要） Dear Prof. ××××××: Thanks very much for your kind work and consideration on a publication of our paper. On behalf of my co-authors, we would like to express our great appreciation to editor and reviewers. Thank you and best regards. Yours sincerely, ×××××× Corresponding author: Name: ××× Institution: xxx E-mail: ××××@×××× 询问校稿信件 （如果文章接受后时间较长） Dear ×××: Sorry for disturbing you. I am not sure if it is the right time to contact you to inquire about the status of our accepted manuscript titled “Paper Title” (ID: 文章稿号), since the copyright agreement for publication has been sent to you two months ago. I am just wondering that how long I can receive the proof of our manuscript from you? I would be greatly appreciated if you could spend some of your time for a reply. I am very pleased to hear from you. Thank you very much for your consideration. Yours sincerely, ×××××× Corresponding author: Name: ××× Institution: xxx E-mail: ××××@×××× 文章校稿信件 Dear Mr. ×××: Thanks very much for your kind letter about the proof of our paper titled “Paper Title” (ID: 文章稿号) for publication in “Journal Name”. We have finished the proofreading and checking carefully, and some corrections about the proof and the answers to the queries are provided below. Corrections: 1. In ****** should be **** (Page ***, Right column, line***) 2. In **** the “*****” should be “****” (Page ****, Right column, line****) Answers for “author queries”: 1. *********************. 2. ********************** 3. ********************** We greatly appreciate the efficient, professional and rapid processing of our paper by your team. If there is anything else we should do, please do not hesitate to let us know. Thank you and best regards. Yours sincerely, ×××××× Corresponding author: Name: ××× Institution: xxx E-mail: ××××@×××× ","link":"https://Wangrongsheng.github.io/post/Ouum2wVyq/"},{"title":"tensorboard将MNIST识别训练过程可视化","content":" 获取数据集 MNIST数据集官方网站：http://yann.lecun.com/exdb/mnist/ 去把四个文件都下载下来，并放在名称为MNIST_data 的文件夹中： Training set images: train-images-idx3-ubyte.gz (9.9 MB, 解压后 47 MB, 包含 60,000 个样本) Training set labels: train-labels-idx1-ubyte.gz (29 KB, 解压后 60 KB, 包含 60,000 个标签) Test set images: t10k-images-idx3-ubyte.gz (1.6 MB, 解压后 7.8 MB, 包含 10,000 个样本) Test set labels: t10k-labels-idx1-ubyte.gz (5KB, 解压后 10 KB, 包含 10,000 个标签) 训练 可以进行超参数的修改！ #coding:utf-8 from tensorflow.examples.tutorials.mnist import input_data mnist = input_data.read_data_sets(&quot;MNIST_data/&quot;, one_hot=True) import tensorflow as tf learning_rate = 0.001 train_epochs = 200 batch_size = 64 logs_path = 'tmp/logs' #日志保存路径 n_input = 784 n_hidden1 = 100 n_hidden2 = 100 n_classes = 10 #name参数，记录变量名字 x = tf.placeholder(tf.float32, shape=[None, n_input], name='InputData') y = tf.placeholder(tf.float32, shape=[None, n_classes], name='LabelData') weights = {'w1': tf.Variable(tf.random_normal([n_input, n_hidden1]), name='W1'), 'w2': tf.Variable(tf.random_normal([n_hidden1, n_hidden2]), name='W2'), 'w3': tf.Variable(tf.random_normal([n_hidden2, n_classes]), name='W3')} biases = {'b1': tf.Variable(tf.random_normal([n_hidden1]), name='b1'), 'b2': tf.Variable(tf.random_normal([n_hidden2]), name='b2'), 'b3': tf.Variable(tf.random_normal([n_classes]), name='b3')} def inference(input_x): layer_1 = tf.nn.relu(tf.matmul(x, weights['w1']) + biases['b1']) tf.summary.histogram('layer_1', layer_1) #记录变量直方图 layer_2 = tf.nn.relu(tf.matmul(layer_1, weights['w2']) + biases['b2']) tf.summary.histogram('layer_2', layer_2) #记录变量直方图 out_layer = tf.matmul(layer_2, weights['w3']) + biases['b3'] return out_layer #定义计算过程的名字 with tf.name_scope('Inference'): logits = inference(x) with tf.name_scope('Loss'): loss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=logits, labels=y)) with tf.name_scope('Optimizer'): optimizer = tf.train.AdamOptimizer(learning_rate=learning_rate) train_op = optimizer.minimize(loss) with tf.name_scope('Accuracy'): pre_correct = tf.equal(tf.argmax(y, 1), tf.argmax(tf.nn.softmax(logits), 1)) accuracy = tf.reduce_mean(tf.cast(pre_correct, tf.float32)) #记录张量的数据 tf.summary.scalar(&quot;Loss&quot;, loss) tf.summary.scalar(&quot;Accuracy&quot;, accuracy) init = tf.global_variables_initializer() merged_summary_op = tf.summary.merge_all() #定义记录运算 with tf.Session() as sess: sess.run(init) summary_writer = tf.summary.FileWriter(logs_path, graph=tf.get_default_graph()) #创建写对象 total_batch = int(mnist.train.num_examples / batch_size) for epoch in range(train_epochs): for batch in range(total_batch): batch_x, batch_y = mnist.train.next_batch(batch_size) _, loss_, summary = sess.run([train_op, loss, merged_summary_op], feed_dict={x:batch_x, y:batch_y}) #执行记录运算 summary_writer.add_summary(summary, epoch * total_batch + batch) #将日志写入文件 if epoch % 5 == 0: loss_, acc = sess.run([loss, accuracy], feed_dict={x:batch_x, y:batch_y}) print(&quot;epoch {}, loss {:.4f}, acc {:.3f}&quot;.format(epoch, loss_, acc)) print(&quot;optimizer finished!&quot;) #计算测试集的准确度 test_acc = sess.run(accuracy, feed_dict={x:mnist.test.images, y:mnist.test.labels}) print('test accuracy', test_acc) 可视化查看 在tmp 文件夹下写个.bat 文件，并且写入： tensorboard --logdir path=你的文件位置 双击.bat文件 -&gt; http://localhost:6006/ 就可以看到了 ","link":"https://Wangrongsheng.github.io/post/5YW1AOjGB/"},{"title":"吴恩达 AI For Everyone 中十个重要 AI 观","content":" AI大局观 讲到AI，我们通常是指狭义AI而非通用AI 多数AI应用是让机器学会一个对应关系 大数据、神经网络及运算能力是AI成功关键 只需花费你1秒的任务，大都可由AI自动化 对AI的态度不应过度乐观，但也不必太悲观 AI偏见难解，但或许比消除人类偏见简单 拥抱AI的最好方法是将其与领域专业结合 机器学习和资料科学的产出分别是系统和洞见 AI时代，你得思考未来自己想要扮演的角色 终身学习在这个年代前所未有的重要 讲到AI，我们通常是指狭义AI而非通用AI 尽管很多AI 应用的表现甚至已经比人类还优秀，这些AI 基本上都专注在完成「特定 」的任务；这跟科幻电影如魔鬼终结者里头，能跟人类以一样的方式思考并做「任何 」事情的通用AI（Artificial General Intelligence, AGI）是有很大差异的。 多数AI应用是让机器学会一个对应关系 大部分的机器学习以及AI 应用本质上都是让电脑学会一个映射函数（Mapping Function），帮我们将输入的数据A 对应到理想的输出B： 大数据、神经网络及运算能力是AI成功关键 只需花费你1秒的任务，（未来）大都可由AI自动化 AI可能会改变我们未来以及下一代的生活型态。 不抱着「AI 能解决所有问题 」的不切实际幻想。 AI偏见难解，但或许比消除人类偏见简单 在利用监督式学习的方式训练AI 的时候，我们常常会使用现实世界的数据 让机器学习。 好消息是因为现在数位化以及网际网络的发达，我们有非常多数据可以交给AI 学习；坏消息是这些数据时常反映了人类数十年甚至几个世纪的偏见。 用这些数据训练出来的AI 系统就像是面照妖镜，也会不可避免地学会这些偏见（Bias） 。 知名的例子有： 以白人照片训练出来的人脸辨识系统在辨识深色肤色的人种时表现很差 自动化雇用的AI系统对女性存有偏见 银行的自动信用评比AI系统对某些族群产生偏见 拥抱AI的最好方法是将其与领域专业结合 想要学习AI，不需要打掉重练。虽然现在AI 相关领域十分热门，究其根本也就只是一种工具/技术。而且AI技术接下来会越来越平民化，上手的门槛会越来越低。 因此比起现在转行当AI 工程师，你要先做的应该是想办法利用自己工作累积的领域知识（Domain Knowledge）以及洞见（Insight），找出能应用AI 改善的地方，进而创造出专属于你或企业的竞争优势。 机器学习和资料科学的产出分别是系统和洞见 机器学习（Machine Learning, ML）以及数据科学（Data Science, DS）这两个词汇常常结伴出现，且依照不同企业其定义都有所不同。因此，不在这块领域里的人常常不知道两者的差异。 一般来说，在企业内的ML项目大都分为3 个阶段： 收集数据 训练模型 部署模型 而DS 项目的步骤则为： 收集数据 分析数据 建议行动/假说 总结来说，ML项目较注重在软件工程方面，且最终希望产出一个以AI为基础的线上系统；DS项目的结果则可能是一份帮助经营者做重大投资决策的PPT报告。 AI时代，你得思考未来自己想要扮演的角色 终身学习在这个年代前所未有重要 ","link":"https://Wangrongsheng.github.io/post/YF8iIspqi/"},{"title":"可可爱爱的向女朋友道歉","content":" ","link":"https://Wangrongsheng.github.io/post/A--fuLKM8/"},{"title":"自动获取优学院课程全部答案","content":" # -*-coding:utf-8-*- import requests import json import re import getpass # 定义所需url login_url = &quot;https://www.ulearning.cn/umooc/user/login.do&quot; # 登录 api_url = &quot;https://api.ulearning.cn/questionAnswer/&quot; # 获取答案的接口，后接ID info_url = &quot;https://api.ulearning.cn/user&quot; # 获取用户信息的接口 chap_info_url = &quot;https://api.ulearning.cn/wholepage/chapter/stu/chapid&quot; # 获取章节信息的接口 outline_url = &quot;https://api.ulearning.cn/course/stu/cseid/directory?class_id=clsid&quot; # 获取课程大纲信息 # 启动一个session，用于登录交互 session = requests.Session() # 存储单个章节信息 chapter = {&quot;title&quot;: None, &quot;id&quot;: None, &quot;sections&quot;: []} # 存储所有单元信息 chapters = [] # token token = &quot;&quot; # 登录函数 def login(): auth = {} auth[&quot;name&quot;] = input(&quot;[*] 用户名：&quot;) auth[&quot;passwd&quot;] = getpass.getpass(&quot;[*] 密码(输入时不可见):&quot;) session.post(login_url, auth) if &quot;token&quot; in session.cookies.keys(): global token token = session.cookies[&quot;token&quot;] print(&quot;[+] 登录成功&quot;) return True else: print(&quot;[-] 登录失败&quot;) # 显示用户信息 def print_user_info(): res = session.get(info_url, headers={&quot;UA-AUTHORIZATION&quot;: token}) info = res.text.strip() info = json.loads(info) print(&quot;[*] 用户ID: &quot; + str(info[&quot;userid&quot;])) print(&quot;[*] 用户姓名: &quot; + info[&quot;name&quot;]) # 打印单题答案 def print_answer(que_id,par_id): res = session.get(api_url + str(que_id) + &quot;?parentId=&quot; + str(par_id)) data = res.text.strip().replace(&quot;\\n&quot;, &quot;&quot;) data = json.loads(data) print(&quot;答案：&quot; + str(data[&quot;correctAnswerList&quot;])) # 打印所有答案 def print_all_answers(): for x in chapters: print(x[&quot;title&quot;]) url = chap_info_url.replace(&quot;chapid&quot;, str(x[&quot;id&quot;])) res = session.get(url, headers={&quot;UA-AUTHORIZATION&quot;: token}) res = res.text.strip() data = json.loads(res) for wpIDL in data[&quot;wholepageItemDTOList&quot;]: if &quot;wholepageDTOList&quot; in wpIDL.keys(): for cspDL in wpIDL[&quot;wholepageDTOList&quot;]: if &quot;coursepageDTOList&quot; in cspDL.keys(): for cpDL in cspDL[&quot;coursepageDTOList&quot;]: if &quot;questionDTOList&quot; in cpDL.keys(): if &quot;parentid&quot; in cpDL.keys(): parentID = cpDL['parentid'] try: for qDL in cpDL[&quot;questionDTOList&quot;]: print(&quot;\\t&quot; + &quot;题目：&quot; + escape_html(qDL[&quot;title&quot;])) print(&quot;\\t&quot;, end=&quot;&quot;) print_answer(qDL[&quot;questionid&quot;], parentID) except: continue # 解析课程和班级ID def parse_que_id(url): course_id = re.search(r&quot;courseId=\\d+&quot;, url).group() course_id = course_id.replace(&quot;courseId=&quot;, &quot;&quot;) class_id = re.search(r&quot;classId=\\d+&quot;, url).group() class_id = class_id.replace(&quot;classId=&quot;, &quot;&quot;) return course_id, class_id # 解析章节大纲 def parse_chap_info(course_id, class_id): url = outline_url.replace(&quot;cseid&quot;, course_id) url = url.replace(&quot;clsid&quot;, class_id) chap_info = session.get(url, headers={&quot;UA-AUTHORIZATION&quot;: token}) chap_info = chap_info.text.strip() chap_info = json.loads(chap_info) for x in range(len(chap_info[&quot;chapters&quot;])): global chapters chap = dict() # section = [] chap[&quot;title&quot;] = chap_info[&quot;chapters&quot;][x][&quot;nodetitle&quot;] chap[&quot;id&quot;] = chap_info[&quot;chapters&quot;][x][&quot;nodeid&quot;] # 每一讲信息 # for y in range(len(chap_info[&quot;chapters&quot;][x][&quot;items&quot;])): # section.append(chap_info[&quot;chapters&quot;][x][&quot;items&quot;][y][&quot;title&quot;]) # chap[&quot;sections&quot;] = section chapters.append(chap) print_all_answers() # 正则匹配，过滤html def escape_html(text): chinese = &quot;&quot; if &quot;“&quot; in text: p = re.compile(r&quot;“.*”&quot;) res = p.findall(text) for x in res: chinese += x text = text.replace(x, &quot;&quot;) p = re.compile(r&quot;&lt;/.*&gt;&quot;) res = p.findall(text) for x in res: text = text.replace(x, &quot;&quot;) p = re.compile(r&quot;&lt;.*&gt;&quot;) res = p.findall(text) for x in res: text = text.replace(x, &quot;&quot;) return chinese + text # 开始 def work(): url = input(&quot;[*] 输入题目所在链接：&quot;) if &quot;https&quot; in url or &quot;http&quot; in url: try: course_id, class_id = parse_que_id(url) parse_chap_info(course_id, class_id) except: print(&quot;[!] 不支持当前URL&quot;) work() else: print(&quot;[-] 链接格式错误，重新输入&quot;) work() def main(): if not login(): main() else: print_user_info() work() if __name__ == '__main__': main() 请勿用于非法用途！ ","link":"https://Wangrongsheng.github.io/post/3yBhZzzkp/"},{"title":"朴素贝叶斯（Naive Bayes model）","content":" 朴素贝叶斯是一种基于贝叶斯定理和特征条件独立假设的分类算法。 简单而言，对于给定的训练数据，朴素贝叶斯先基于特征条件独立假设学习输入和输出的联合概率分布，然后基于此分布对于新的实例，利用贝叶斯定理计算出最大的后验概率。朴素贝叶斯不会直接学习输入输出的联合概率分布，而是通过学习类的先验概率 和类条件概率 来完成。 所谓朴素贝叶斯中朴素的含义，即特征条件独立假设，条件独立假设就是说用于分类的特征在类确定的条件下都是条件独立的。这一假设使得朴素贝叶斯的学习成为可能。朴素贝叶斯算法具体步骤如下。 首先计算类先验概率： 类先验概率可直接用极大似然估计进行计算。 然后计算类条件概率： 最后给定新的实例，计算其对应的最大后验概率，然后判断其所属的类别： import numpy as np import pandas as pd class Naive_Bayes: def __init__(self): pass # 朴素贝叶斯训练过程 def nb_fit(self, X, y): classes = y[y.columns[0]].unique() class_count = y[y.columns[0]].value_counts() # 类先验概率 class_prior = class_count / len(y) # 计算类条件概率 prior = dict() for col in X.columns: for j in classes: p_x_y = X[(y == j).values][col].value_counts() for i in p_x_y.index: prior[(col, i, j)] = p_x_y[i] / class_count[j] return classes, class_prior, prior # 预测新的实例 def predict(self, X_test): res = [] for c in classes: p_y = class_prior[c] p_x_y = 1 for i in X_test.items(): p_x_y *= prior[tuple(list(i) + [c])] res.append(p_y * p_x_y) return classes[np.argmax(res)] if __name__ == &quot;__main__&quot;: x1 = [1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3] x2 = ['S', 'M', 'M', 'S', 'S', 'S', 'M', 'M', 'L', 'L', 'L', 'M', 'M', 'L', 'L'] y = [-1, -1, 1, 1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1] df = pd.DataFrame({'x1': x1, 'x2': x2, 'y': y}) X = df[['x1', 'x2']] y = df[['y']] X_test = {'x1': 2, 'x2': 'S'} nb = Naive_Bayes() classes, class_prior, prior = nb.nb_fit(X, y) print('测试数据预测类别为：', nb.predict(X_test)) ","link":"https://Wangrongsheng.github.io/post/qxtTazjkv/"},{"title":"排序算法","content":" 排序算法可以分为内部排序和外部排序： 内部排序是数据记录在内存中进行排序。 外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。 常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。 时间复杂度 平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。 线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序； O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序 线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。 稳定性 稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。 不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。 排序 冒泡排序 算法步骤 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 动画演示 选择排序 算法步骤 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 动画演示 插入排序 算法步骤 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） 动画演示 希尔排序 算法步骤 选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1； 按增量序列个数 k，对序列进行 k 趟排序； 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 动画演示 归并排序 算法步骤 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤 3 直到某一指针达到序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。 动画演示 快速排序 算法步骤 从数列中挑出一个元素，称为 “基准”（pivot）; 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序； 动画演示 堆排序 算法步骤 创建一个堆 H[0……n-1]； 把堆首（最大值）和堆尾互换； 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置； 重复步骤 2，直到堆的尺寸为 1。 动画演示 计数排序 算法步骤 花O(n)的时间扫描一下整个序列 A，获取最小值 min 和最大值 max 开辟一块新的空间创建新的数组 B，长度为 ( max – min + 1) 数组 B 中 index 的元素记录的值是 A 中某元素出现的次数 最后输出目标整数序列，具体的逻辑是遍历数组 B，输出相应元素以及对应的个数 动画演示 桶排序 算法步骤 设置固定数量的空桶。 把数据放到对应的桶中。 对每个不为空的桶中数据进行排序。 拼接不为空的桶中数据，得到结果。 动画演示 基数排序 算法步骤 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零 从最低位开始，依次进行一次排序 从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列 动画演示 ","link":"https://Wangrongsheng.github.io/post/VT62e2oy8/"},{"title":"模拟退火算法（Simulate Anneal）","content":" 爬山算法 ( Hill Climbing ) 介绍模拟退火前，先介绍爬山算法。爬山算法是一种简单的贪心搜索算法，该算法 每次从当前解的临近解空间中选择一个最优解作为当前解，直到达到一个局部最优解 。 爬山算法实现很简单，其主要缺点是会陷入局部最优解 ，而不一定能搜索到全局最优解。如图1所示：假设C点为当前解，爬山算法搜索到A点这个局部最优解就会停止搜索，因为在A点无论向那个方向小幅度移动都不能得到更优的解。 模拟退火算法（SA） 退火的概念 在热力学上，退火（annealing）现象指物体逐渐降温的物理现象，温度愈低，物体的能量状态会低；够低后，液体开始冷凝与结晶，在结晶状态时，系统的能量状态最低。大自然在缓慢降温（亦即，退火）时，可“找到”最低能量状态：结晶。但是，如果过程过急过快，快速降温（亦称「淬炼」，quenching）时，会导致不是最低能态的非晶形。 如下图所示，首先（左图）物体处于非晶体状态。我们将固体加温至充分高（中图），再让其徐徐冷却，也就退火（右图）。加温时，固体内部粒子随温升变为无序状，内能增大，而徐徐冷却时粒子渐趋有序，在每个温度都达到平衡态，最后在常温时达到基态，内能减为最小（此时物体以晶体形态呈现）。 似乎，大自然知道慢工出细活：缓缓降温，使得物体分子在每一温度时，能够有足够时间找到安顿位置，则逐渐地，到最后可得到最低能态，系统最安稳。 模拟退火的概念 想象一下如果我们现在有下面这样一个函数，现在想求函数的（全局）最优解。如果采用Greedy策略，那么从A点开始试探，如果函数值继续减少，那么试探过程就会继续。而当到达点B时，显然我们的探求过程就结束了（因为无论朝哪个方向努力，结果只会越来越大）。最终我们只能找打一个局部最后解B。 模拟退火其实也是一种Greedy算法，但是它的搜索过程引入了随机因素。模拟退火算法以一定的概率来接受一个比当前解要差的解，因此有可能会跳出这个局部的最优解，达到全局的最优解。 以上图为例，模拟退火算法在搜索到局部最优解B后，会以一定的概率接受向右继续移动。也许经过几次这样的不是局部最优的移动后会到达B 和C之间的峰点，于是就跳出了局部最小值B。 若f( Y(i+1) ) &lt;= f( Y(i) ) (即移动后得到更优解)，则总是接受该移动； 若f( Y(i+1) ) &gt; f( Y(i) ) (即移动后的解比当前解要差)，则以一定的概率 接受移动，而且这个概率随着时间推移逐渐降低 （逐渐降低才能趋向稳定）相当于上图中，从B移向BC之间的小波峰时，每次右移（即接受一个更糟糕值）的概率在逐渐降低。如果这个坡特别长，那么很有可能最终我们并不会翻过这个坡。如果它不太长，这很有可能会翻过它，这取决于衰减 t 值的设定。 模拟退火的步骤 初始化温度T，初始解状态S，每个温度t下的迭代次数L； 当k = 1，2，……，L时，进行3~6； 对当前解进行变换得到新解S’（例如对某些解中的元素进行互换，置换）； 计算增量Δt′=C(S′)-C(S)，其中C(S)为评价函数； 若Δt′&lt;0则接受S′作为新的当前解，否则以概率exp(-Δt′/(KT))接受S′作为新的当前解(k为玻尔兹曼常数，数值为：K=1.3806505(24) × 10^-23 J/K）； 如果满足终止条件则输出当前解作为最优解，结束程序； 减小T，转到第2步，直到T小于初始设定的阈值。 模拟退火的优缺点 迭代搜索效率高，并且可以并行化； 算法中有一定概率接受比当前解较差的解，因此一定程度上可以跳出局部最优； 算法求得的解与初始解状态S无关，因此有一定的鲁棒性； 具有渐近收敛性，已在理论上被证明是一种以概率l 收敛于全局最优解的全局优化算法。 代码实现 import numpy as np import matplotlib.pyplot as plt import math # 绘图 # 定义函数表达式 # define aim function def aimFunction(x): y = x ** 3 + 3 * x ** 2 - 6 return y x = [i / 10 for i in range(-1000, 1000)] # 定义域为[-100,100] y = [0.0 for i in range(-1000, 1000)] for i in range(2000): y[i] = aimFunction(x[i]) plt.plot(x, y) plt.show() # 求最值 T = 1000 # 初始温度initiate temperature Tmin = 10 # 终止温度 x = np.random.uniform(low=-100, high=100) # 当前状态 k = 50 # 每次温度下的循环次数 y = 0 # 评估函数 t = 0 # 用于控制降温的快慢 while T &gt;= Tmin: for i in range(k): # 计算y y = aimFunction(x) # 产生新解 xNew = x + np.random.uniform(low=-0.055, high=0.055) * T if (-100 &lt;= xNew and xNew &lt;= 100): yNew = aimFunction(xNew) if yNew - y &gt; 0: # 新的评估函数更大，接受新解，若求极小，改为 if yNew - y &gt; 0: x = xNew else: # metropolis 准则 得到新解或执行降温 p = math.exp((yNew - y) / T)#求极大值，若求极小，改为p = math.exp(-(yNew - y) / T) r = np.random.uniform(low=0, high=1) if r &lt; p: x = xNew t += 1 # print(t) # 降温退火 T = 10000 / (1 + t) print(x, aimFunction(x)) ","link":"https://Wangrongsheng.github.io/post/zJBSvccP0/"},{"title":"Python处理JSON格式的数据接口","content":" 什么是json？ JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 ECMAScript 的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得JSON 成为理想的数据交换语言。易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 在JS语言中，一切都是对象。因此，任何支持的类型都可以通过JSON来表示，例如字符串、数字、对象、数组等。但是对象和数组是比较特殊且常用的两种类型： 对象表示为键值对 数据由逗号分隔 花括号保存对象 方括号保存数组 json使用方法 获取一个json数据 import requests url ='https://api.oioweb.cn/api/jsyl.php' r = requests.get(url) #json格式 json_response = r.content.decode() print(json_response) {&quot;code&quot;:1,&quot;msg&quot;:&quot;别把辉煌记在心间，别拿昨天挂在嘴边。&quot;} 更多接口API：教书先生api接口 、免费api接口 python 处理json 格式模块有json 和picle json 模块提供了四个方法：dumps、dump、loads、load； pickle 模块也提供了四个功能：dumps、dump、loads、load； 序列化：将python 的值转换为json 格式的字符串； 反序列化：将json 格式的字符串转换成python 的数据类型； json与字典相互转换 json.dumps用于将 Python 对象编码成JSON 字符串。 json.loads将已编码的 JSON 字符串解码为Python 对象。 import requests import json url ='https://api.oioweb.cn/api/jsyl.php' r = requests.get(url) #json格式 json_response = r.content.decode() print(json_response) #json 转字典 dict_json = json.loads(json_response) print(dict_json) 结果输出(上为字典格式、下是json格式) {&quot;code&quot;:1,&quot;msg&quot;:&quot;兄弟为手足，女人为衣服。谁动我手足，我扒谁衣服。&quot;} {'code': 1, 'msg': '兄弟为手足，女人为衣服。谁动我手足，我扒谁衣服。'} 说明：json是字符串，在输出展示方面与字典是不同的，为双引号 序列化 下面列举了数据处理中常用的7种类型的序列化与反序列化： #1）字典序列化： import json dic={&quot;name&quot;:&quot;mcw&quot;,&quot;age&quot;:18} xu=json.dumps(dic) print(xu,type(xu),type(dic)) print('------------1---------------') #2）列表序列化与反序列化： import json li=[1,2] xu=json.dumps(li) print(xu,type(xu),type(li)) fx=json.loads(xu) print(fx,type(fx)) print('-------------2--------------') #3）字符串序列化与反序列化: import json mcwstr=&quot;xiaoma&quot; xu=json.dumps(mcwstr) print(xu,type(xu),type(mcwstr)) fx=json.loads(xu) print(fx,type(fx)) print('------------3---------------') #4）整型序列化与反序列化 import json mcwint=2 xu=json.dumps(mcwint) print(xu,type(xu),type(mcwint)) fx=json.loads(xu) print(fx,type(fx)) print('------------4---------------') #5）浮点型序列化与反序列化 import json mcwfloat=2.03 xu=json.dumps(mcwfloat) print(xu,type(xu),type(mcwfloat)) fx=json.loads(xu) print(fx,type(fx)) print('--------------5-------------') #6）布尔型序列化与反序列化： import json mcwbool=True xu=json.dumps(mcwbool) print(xu,type(xu),type(mcwbool)) fx=json.loads(xu) print(fx,type(fx)) print('--------------6-------------') #7）None序列化与反序列化 import json mcwnone=None xu=json.dumps(mcwnone) print(xu,type(xu),type(mcwnone)) fx=json.loads(xu) print(fx,type(fx)) 结果输出： {&quot;name&quot;: &quot;mcw&quot;, &quot;age&quot;: 18} &lt;class 'str'&gt; &lt;class 'dict'&gt; ------------1--------------- [1, 2] &lt;class 'str'&gt; &lt;class 'list'&gt; [1, 2] &lt;class 'list'&gt; -------------2-------------- &quot;xiaoma&quot; &lt;class 'str'&gt; &lt;class 'str'&gt; xiaoma &lt;class 'str'&gt; ------------3--------------- 2 &lt;class 'str'&gt; &lt;class 'int'&gt; 2 &lt;class 'int'&gt; ------------4--------------- 2.03 &lt;class 'str'&gt; &lt;class 'float'&gt; 2.03 &lt;class 'float'&gt; --------------5------------- true &lt;class 'str'&gt; &lt;class 'bool'&gt; True &lt;class 'bool'&gt; --------------6------------- null &lt;class 'str'&gt; &lt;class 'NoneType'&gt; None &lt;class 'NoneType'&gt; ","link":"https://Wangrongsheng.github.io/post/ot2W3uFd-/"},{"title":"爬虫的基本原理","content":" 什么是爬虫 #1、什么是互联网？ 互联网是由网络设备（网线，路由器，交换机，防火墙等等）和一台台计算机连接而成，像一张网一样。 #2、互联网建立的目的？ 互联网的核心价值在于数据的共享/传递：数据是存放于一台台计算机上的，而将计算机互联到一起的目的就是为了能够方便彼此之间的数据共享/传递，否则你只能拿U盘去别人的计算机上拷贝数据了。 #3、什么是上网？爬虫要做的是什么？ 我们所谓的上网便是由用户端计算机发送请求给目标计算机，将目标计算机的数据下载到本地的过程。 #3.1 只不过，用户获取网络数据的方式是： 浏览器提交请求-&gt;下载网页代码-&gt;解析/渲染成页面。 #3.2 而爬虫程序要做的就是： 模拟浏览器发送请求-&gt;下载网页代码-&gt;只提取有用的数据-&gt;存放于数据库或文件中 #3.1与3.2的区别在于: 我们的爬虫程序只提取网页代码中对我们有用的数据 #4、总结爬虫 #4.1 爬虫的比喻： 如果我们把互联网比作一张大的蜘蛛网，那一台计算机上的数据便是蜘蛛网上的一个猎物，而爬虫程序就是一只小蜘蛛，沿着蜘蛛网抓取自己想要的猎物/数据 #4.2 爬虫的定义： 向网站发起请求，获取资源后分析并提取有用数据的程序 #4.3 爬虫的价值： 互联网中最有价值的便是数据，比如天猫商城的商品信息，链家网的租房信息，雪球网的证券投资信息等等，这些数据都代表了各个行业的真金白银， 可以说，谁掌握了行业内的第一手数据，谁就成了整个行业的主宰，如果把整个互联网的数据比喻为一座宝藏，那我们的爬虫课程就是来教大家如何来高效地挖掘这些宝藏， 掌握了爬虫技能，你就成了所有互联网信息公司幕后的老板，换言之，它们都在免费为你提供有价值的数据。 爬虫的基本流程 #1、发起请求 使用http库向目标站点发起请求，即发送一个Request Request包含：请求头、请求体等 #2、获取响应内容 如果服务器能正常响应，则会得到一个Response Response包含：html，json，图片，视频等 #3、解析内容 解析html数据：正则表达式，第三方解析库如Beautifulsoup，pyquery等 解析json数据：json模块 解析二进制数据:以b的方式写入文件 #4、保存数据 数据库 文件 请求与响应 #http协议：http://www.cnblogs.com/haiyan123/p/7298967.html #Request：用户将自己的信息通过浏览器（socket client）发送给服务器（socket server） #Response：服务器接收请求，分析用户发来的请求信息，然后返回数据（返回的数据中可能包含其他链接，如：图片，js，css等） #ps：浏览器在接收Response后，会解析其内容来显示给用户，而爬虫程序在模拟浏览器发送请求然后接收Response后，是要提取其中的有用数据。 Request #1、请求方式： 常用的请求方式：GET，POST 其他请求方式：HEAD，PUT，DELETE，OPTHONS ps：用浏览器演示get与post的区别，（用登录演示post） post与get请求最终都会拼接成这种形式：k1=xxx&amp;k2=yyy&amp;k3=zzz post请求的参数放在请求体内： 可用浏览器查看，存放于form data内 get请求的参数直接放在url后 #2、请求url url全称统一资源定位符，如一个网页文档，一张图片 一个视频等都可以用url唯一来确定 url编码 https://www.baidu.com/s?wd=图片 图片会被编码（看示例代码） 网页的加载过程是： 加载一个网页，通常都是先加载document文档， 在解析document文档的时候，遇到链接，则针对超链接发起下载图片的请求 #3、请求头 User-agent：告诉它这是浏览器发过来的请求（请求头中如果没有user-agent客户端配置，服务端可能将你当做一个非法用户）务必加上 host cookies：cookie用来保存登录信息 Referer:上一次的跳转路径 一般做爬虫都会加上请求头 #4、请求体 如果是get方式，请求体没有内容 如果是post方式，请求体是format data ps： 1、登录窗口，文件上传等，信息都会被附加到请求体内 2、登录，输入错误的用户名密码，然后提交，就可以看到post，正确登录后页面通常会跳转，无法捕捉到post Response #1、响应状态 200：代表成功 301：代表跳转 404：文件不存在 403：权限 502：服务器错误 #2、Respone header Location：跳转 set-cookie：可能有多个，是来告诉浏览器，把cookie保存下来 #3、preview就是网页源代码 最主要的部分，包含了请求资源的内容 如网页html，图片 二进制数据等 总结 #1、总结爬虫流程： 爬取---&gt;解析---&gt;存储 #2、爬虫所需工具： 请求库：requests,selenium 解析库：正则，beautifulsoup，pyquery 存储库：文件，MySQL，Mongodb，Redis #3、爬虫常用框架： scrapy ","link":"https://Wangrongsheng.github.io/post/aMeAbA7UC/"},{"title":"Git设置记住账号密码","content":" 最近几次在更新Github项目的时候经常需要在git push 之后输入账号和密码，就很麻烦，特意去网上搜了下教程，没想到还真的有。 记住账号和密码 1、进入我们的项目，并且进入.git 文件，如果不显示.git 文件，你需要进行如下操作： 2、编辑里面的配置文件config 3、在配置文件最后加入： [credential] helper = store ","link":"https://Wangrongsheng.github.io/post/2J_BEdrl0/"},{"title":"蚁群算法（Ant Colony Optimization）","content":" 蚁群算法简介 蚁群算法（Ant Clony Optimization， ACO）是一种群智能算法，它是由一群无智能或有轻微智能的个体（Agent）通过相互协作而表现出智能行为，从而为求解复杂问题提供了一个新的可能性。蚁群算法最早是由意大利学者Colorni A., Dorigo M. 等于1991年提出。经过20多年的发展，蚁群算法在理论以及应用研究上已经得到巨大的进步。 蚁群算法是一种仿生学算法，是由自然界中蚂蚁觅食的行为而启发的。在自然界中，蚂蚁觅食过程中，蚁群总能够按照寻找到一条从蚁巢和食物源的最优路径。下图显示了这样一个觅食的过程。 在图（a）中，有一群蚂蚁，假如A是蚁巢，E是食物源（反之亦然）。这群蚂蚁将沿着蚁巢和食物源之间的直线路径行驶。假如在A和E之间突然出现了一个障碍物（图（b）），那么，在B点（或D点）的蚂蚁将要做出决策，到底是向左行驶还是向右行驶？由于一开始路上没有前面蚂蚁留下的 信息素（pheromone） ，蚂蚁朝着两个方向行进的概率是相等的。但是当有蚂蚁走过时，它将会在它行进的路上释放出信息素，并且这种信息素会议一定的速率散发掉。信息素是蚂蚁之间交流的工具之一。它后面的蚂蚁通过路上信息素的浓度，做出决策，往左还是往右。很明显，沿着短边的的路径上信息素将会越来越浓（图（c）），从而吸引了越来越多的蚂蚁沿着这条路径行驶。 TSP问题描述 蚁群算法最早用来求解TSP问题，并且表现出了很大的优越性，因为它分布式特性，鲁棒性强并且容易与其它算法结合，但是同时也存在这收敛速度慢，容易陷入局部最优（local optimal）等缺点。 TSP问题（Travel Salesperson Problem，即旅行商问题或者称为中国邮递员问题），是一种NP-hard问题，此类问题用一般的算法是很难得到最优解的，所以一般需要借助一些启发式算法求解，例如遗传算法（GA），蚁群算法（ACO），微粒群算法（PSO）等等。 TSP问题（旅行商问题）是指旅行家要旅行n个城市，要求各个城市经历且仅经历一次 然后回到出发城市，并要求所走的路程最短。 一个TSP问题可以表达为：求解遍历图G=(V,E,C)，所有的节点一次并且回到起始节点，使得连接这些节点的路径成本最低。 蚁群算法原理 假如蚁群中所有蚂蚁的数量为m，所有城市之间的信息素用矩阵pheromone表示，最短路径为bestLength，最佳路径为bestTour。每只蚂蚁都有自己的内存，内存中用一个禁忌表（Tabu）来存储该蚂蚁已经访问过的城市，表示其在以后的搜索中将不能访问这些城市；还有用另外一个允许访问的城市表（Allowed）来存储它还可以访问的城市；另外还用一个矩阵（Delta）来存储它在一个循环（或者迭代）中给所经过的路径释放的信息素；还有另外一些数据，例如一些控制参数(α，β，ρ，Q)，该蚂蚁行走玩全程的总成本或距离（tourLength），等等。假定算法总共运行MAX_GEN次，运行时间为t。 蚁群算法计算过程如下： （1）初始化。 （2）为每只蚂蚁选择下一个节点。 （3）更新信息素矩阵。 （4）检查终止条件 如果达到最大代数MAX_GEN，算法终止，转到第（5）步；否则，重新初始化所有的蚂蚁的Delt矩阵所有元素初始化为0，Tabu表清空，Allowed表中加入所有的城市节点。随机选择它们的起始位置（也可以人工指定）。在Tabu中加入起始节点，Allowed中去掉该起始节点，重复执行（2），（3）,(4)步。 （5）输出最优值 代码实现 # -*- coding: utf-8 -*- import random import copy import time import sys import math import tkinter #//GUI模块 import threading from functools import reduce # 参数 ''' ALPHA:信息启发因子，值越大，则蚂蚁选择之前走过的路径可能性就越大 ，值越小，则蚁群搜索范围就会减少，容易陷入局部最优 BETA:Beta值越大，蚁群越就容易选择局部较短路径，这时算法收敛速度会 加快，但是随机性不高，容易得到局部的相对最优 ''' (ALPHA, BETA, RHO, Q) = (1.0,2.0,0.5,100.0) # 城市数，蚁群 (city_num, ant_num) = (50,50) distance_x = [ 178,272,176,171,650,499,267,703,408,437,491,74,532, 416,626,42,271,359,163,508,229,576,147,560,35,714, 757,517,64,314,675,690,391,628,87,240,705,699,258, 428,614,36,360,482,666,597,209,201,492,294] distance_y = [ 170,395,198,151,242,556,57,401,305,421,267,105,525, 381,244,330,395,169,141,380,153,442,528,329,232,48, 498,265,343,120,165,50,433,63,491,275,348,222,288, 490,213,524,244,114,104,552,70,425,227,331] #城市距离和信息素 distance_graph = [ [0.0 for col in range(city_num)] for raw in range(city_num)] pheromone_graph = [ [1.0 for col in range(city_num)] for raw in range(city_num)] #----------- 蚂蚁 ----------- class Ant(object): # 初始化 def __init__(self,ID): self.ID = ID # ID self.__clean_data() # 随机初始化出生点 # 初始数据 def __clean_data(self): self.path = [] # 当前蚂蚁的路径 self.total_distance = 0.0 # 当前路径的总距离 self.move_count = 0 # 移动次数 self.current_city = -1 # 当前停留的城市 self.open_table_city = [True for i in range(city_num)] # 探索城市的状态 city_index = random.randint(0,city_num-1) # 随机初始出生点 self.current_city = city_index self.path.append(city_index) self.open_table_city[city_index] = False self.move_count = 1 # 选择下一个城市 def __choice_next_city(self): next_city = -1 select_citys_prob = [0.0 for i in range(city_num)] #存储去下个城市的概率 total_prob = 0.0 # 获取去下一个城市的概率 for i in range(city_num): if self.open_table_city[i]: try : # 计算概率：与信息素浓度成正比，与距离成反比 select_citys_prob[i] = pow(pheromone_graph[self.current_city][i], ALPHA) * pow((1.0/distance_graph[self.current_city][i]), BETA) total_prob += select_citys_prob[i] except ZeroDivisionError as e: print ('Ant ID: {ID}, current city: {current}, target city: {target}'.format(ID = self.ID, current = self.current_city, target = i)) sys.exit(1) # 轮盘选择城市 if total_prob &gt; 0.0: # 产生一个随机概率,0.0-total_prob temp_prob = random.uniform(0.0, total_prob) for i in range(city_num): if self.open_table_city[i]: # 轮次相减 temp_prob -= select_citys_prob[i] if temp_prob &lt; 0.0: next_city = i break # 未从概率产生，顺序选择一个未访问城市 # if next_city == -1: # for i in range(city_num): # if self.open_table_city[i]: # next_city = i # break if (next_city == -1): next_city = random.randint(0, city_num - 1) while ((self.open_table_city[next_city]) == False): # if==False,说明已经遍历过了 next_city = random.randint(0, city_num - 1) # 返回下一个城市序号 return next_city # 计算路径总距离 def __cal_total_distance(self): temp_distance = 0.0 for i in range(1, city_num): start, end = self.path[i], self.path[i-1] temp_distance += distance_graph[start][end] # 回路 end = self.path[0] temp_distance += distance_graph[start][end] self.total_distance = temp_distance # 移动操作 def __move(self, next_city): self.path.append(next_city) self.open_table_city[next_city] = False self.total_distance += distance_graph[self.current_city][next_city] self.current_city = next_city self.move_count += 1 # 搜索路径 def search_path(self): # 初始化数据 self.__clean_data() # 搜素路径，遍历完所有城市为止 while self.move_count &lt; city_num: # 移动到下一个城市 next_city = self.__choice_next_city() self.__move(next_city) # 计算路径总长度 self.__cal_total_distance() #----------- TSP问题 ----------- class TSP(object): def __init__(self, root, width = 800, height = 600, n = city_num): # 创建画布 self.root = root self.width = width self.height = height # 城市数目初始化为city_num self.n = n # tkinter.Canvas self.canvas = tkinter.Canvas( root, width = self.width, height = self.height, bg = &quot;#EBEBEB&quot;, # 背景白色 xscrollincrement = 1, yscrollincrement = 1 ) self.canvas.pack(expand = tkinter.YES, fill = tkinter.BOTH) self.title(&quot;TSP蚁群算法(n:初始化 e:开始搜索 s:停止搜索 q:退出程序)&quot;) self.__r = 5 self.__lock = threading.RLock() # 线程锁 self.__bindEvents() self.new() # 计算城市之间的距离 for i in range(city_num): for j in range(city_num): temp_distance = pow((distance_x[i] - distance_x[j]), 2) + pow((distance_y[i] - distance_y[j]), 2) temp_distance = pow(temp_distance, 0.5) distance_graph[i][j] =float(int(temp_distance + 0.5)) # 按键响应程序 def __bindEvents(self): self.root.bind(&quot;q&quot;, self.quite) # 退出程序 self.root.bind(&quot;n&quot;, self.new) # 初始化 self.root.bind(&quot;e&quot;, self.search_path) # 开始搜索 self.root.bind(&quot;s&quot;, self.stop) # 停止搜索 # 更改标题 def title(self, s): self.root.title(s) # 初始化 def new(self, evt = None): # 停止线程 self.__lock.acquire() self.__running = False self.__lock.release() self.clear() # 清除信息 self.nodes = [] # 节点坐标 self.nodes2 = [] # 节点对象 # 初始化城市节点 for i in range(len(distance_x)): # 在画布上随机初始坐标 x = distance_x[i] y = distance_y[i] self.nodes.append((x, y)) # 生成节点椭圆，半径为self.__r node = self.canvas.create_oval(x - self.__r, y - self.__r, x + self.__r, y + self.__r, fill = &quot;#ff0000&quot;, # 填充红色 outline = &quot;#000000&quot;, # 轮廓白色 tags = &quot;node&quot;, ) self.nodes2.append(node) # 显示坐标 self.canvas.create_text(x,y-10, # 使用create_text方法在坐标（302，77）处绘制文字 text = '('+str(x)+','+str(y)+')', # 所绘制文字的内容 fill = 'black' # 所绘制文字的颜色为灰色 ) # 顺序连接城市 #self.line(range(city_num)) # 初始城市之间的距离和信息素 for i in range(city_num): for j in range(city_num): pheromone_graph[i][j] = 1.0 self.ants = [Ant(ID) for ID in range(ant_num)] # 初始蚁群 self.best_ant = Ant(-1) # 初始最优解 self.best_ant.total_distance = 1 &lt;&lt; 31 # 初始最大距离 self.iter = 1 # 初始化迭代次数 # 将节点按order顺序连线 def line(self, order): # 删除原线 self.canvas.delete(&quot;line&quot;) def line2(i1, i2): p1, p2 = self.nodes[i1], self.nodes[i2] self.canvas.create_line(p1, p2, fill = &quot;#000000&quot;, tags = &quot;line&quot;) return i2 # order[-1]为初始值 reduce(line2, order, order[-1]) # 清除画布 def clear(self): for item in self.canvas.find_all(): self.canvas.delete(item) # 退出程序 def quite(self, evt): self.__lock.acquire() self.__running = False self.__lock.release() self.root.destroy() print (u&quot;\\n程序已退出...&quot;) sys.exit() # 停止搜索 def stop(self, evt): self.__lock.acquire() self.__running = False self.__lock.release() # 开始搜索 def search_path(self, evt = None): # 开启线程 self.__lock.acquire() self.__running = True self.__lock.release() while self.__running: # 遍历每一只蚂蚁 for ant in self.ants: # 搜索一条路径 ant.search_path() # 与当前最优蚂蚁比较 if ant.total_distance &lt; self.best_ant.total_distance: # 更新最优解 self.best_ant = copy.deepcopy(ant) # 更新信息素 self.__update_pheromone_gragh() print (u&quot;迭代次数：&quot;,self.iter,u&quot;最佳路径总距离：&quot;,int(self.best_ant.total_distance)) # 连线 self.line(self.best_ant.path) # 设置标题 self.title(&quot;TSP蚁群算法(n:随机初始 e:开始搜索 s:停止搜索 q:退出程序) 迭代次数: %d&quot; % self.iter) # 更新画布 self.canvas.update() self.iter += 1 # 更新信息素 def __update_pheromone_gragh(self): # 获取每只蚂蚁在其路径上留下的信息素 temp_pheromone = [[0.0 for col in range(city_num)] for raw in range(city_num)] for ant in self.ants: for i in range(1,city_num): start, end = ant.path[i-1], ant.path[i] # 在路径上的每两个相邻城市间留下信息素，与路径总距离反比 temp_pheromone[start][end] += Q / ant.total_distance temp_pheromone[end][start] = temp_pheromone[start][end] # 更新所有城市之间的信息素，旧信息素衰减加上新迭代信息素 for i in range(city_num): for j in range(city_num): pheromone_graph[i][j] = pheromone_graph[i][j] * RHO + temp_pheromone[i][j] # 主循环 def mainloop(self): self.root.mainloop() #----------- 程序的入口处 ----------- if __name__ == '__main__': TSP(tkinter.Tk()).mainloop() ","link":"https://Wangrongsheng.github.io/post/AEHJ7fQro/"},{"title":"YOLOv4 的各种新实现、配置、测试、训练资源汇总","content":" document.getElementById(\"spkj\").style.height=document.getElementById(\"spkj\").scrollWidth*0.76+\"px\"; 实现 近日最火的莫过于 YOLOv4 的横空出世，这里整理关于 YOLOv4 的一些资源。原 YOLOv4 是基于 DarkNet 框架的，已经有不少其他版本的实现： 1、YOLOv4 的 TensorFlow 2.0 实现。 https://github.com/xiao9616/yolo4_tensorflow2 2、YOLOv4 的 TensorFlow 实现。 https://github.com/rrddcc/YOLOv4_tensorflow 3、YOLOv4 的 TensorFlow 实现。 https://github.com/klauspa/Yolov4-tensorflow 4、YOLOv4 的 PyTorch 实现。 https://github.com/GZQ0723/YoloV4 5、YOLOv4（TensorFlow后端）的 Keras 实现。 https://github.com/Ma-Dan/keras-yolo4 6、YOLOv4 的 PyTorch 实现。 https://github.com/Tianxiaomo/pytorch-YOLOv4 7、YOLOv4-QtGUI：Windows 10环境下，YOLOv4-QtGUI是用QT和OpenCV开发可视化目标检测界面,可简单选择本地图片、或摄像头输入来展示检测结果。 https://github.com/scutlrr/Yolov4-QtGUI 8、将 YOLOv4 模型转换到 tflite 中使用，将 .weights 转换为 .tflite 格式以获取 tensorflow lite。 https://github.com/hunglc007/tensorflow-yolov4-tflite 配置、训练、教程 1、YOLOv4训练自己的数据模型。 https://blog.csdn.net/yapifeitu/article/details/105749693 2、linux下配置运行YOLOv4！基本环境：cuda=10.0，cudnn&gt;=7.0， opencv&gt;=2.4 。 https://blog.csdn.net/ly_twt/article/details/105748280#comments_12014895 3、linux下在pascal voc数据集上训练YOLOv4！ https://blog.csdn.net/ly_twt/article/details/105761312 4、windows10+vs2017+opencv3.4.1配置YOLOv4。 https://blog.csdn.net/weixin_39954922/article/details/105785460?fps=1&amp;locationNum=2 5、YOLOv4在windows下的安装配置。 http://www.luyixian.cn/news_show_354767.aspx ","link":"https://Wangrongsheng.github.io/post/CJbIDO1IG/"},{"title":"基于百度AI开发平台的智能写诗 & 智能春联","content":" 智能写诗 &amp; 智能春联 百度 AI 目前提供了智能写作的接口，主要包括智能写诗接口与智能春联接口。具体的使用说明可以参考文档 http://ai.baidu.com/docs#/IntelligentWriting-API/f85d34cc 。 智能写作接口说明 智能春联接口 智能春联是指根据用户输入的命题关键词自动生成一副春联，包括上联、下联和横批。 智能春联的请求参数如下表： 参数 是否必选 类型 描述 text 是 string 字符串（限5字符数以内）即春联的主题 index 否 int 整数 默认为数值为0，即第一幅春联。每换一次，数值加1即可，一定数量后会返回之前的春联结果。 上面两个字符段是接口的输入，text 字数小于 5，是春联的主题。 index 可以用来指定生成的对联，不同的 index 可能会生成不同的对联。 智能春联的返回参数如下表： 参数 类型 描述 couplets object object嵌套结构，对应返回的春联 +first string 春联上联：成7-9个字的上联 +second string 春联下联：生成7-9个字的春联下联 +center string 春联横批：生成4个字的春联横批 其输出为 json 字符串。例如：“春节”对应的一个输出为 {'couplets': {'center': '迎春接福', 'first': '春节迎春新世纪', 'second': '福音报福小康年'}} 智能写诗接口 智能写诗是指根据用户输入的命题关键词自动生成一首7言绝句。 智能写诗的请求参数如下表： 参数 是否必选 类型 描述 text 是 string 字符串（限5字符数以内，）即作诗的主题 index 否 int 整数 默认为数值为0，即第一首诗。每换一次，数值加1即可，一定数量后会返回之前的作诗结果 这两个输入字段和智能春联的两个输入字段相同，只是，text 代表诗的主题 智能写诗的返回参数如下表： 参数 类型 描述 poem array 数组结构，元素对应7言绝句诗 +title string 诗名，即用户输入作诗主题 +content string 作诗结果：为一首7言绝句 其输出也是 json 字符串，例如：“百度”对应的一个输出为 {'poem': [{'content': '神州崛起宏图展\\t华夏腾飞巨浪狂\\t万里江山添锦绣\\t千秋百度铸辉煌\\t', 'title': '百度'}]} 错误码说明 错误码 错误信息 描述 52000 成功 无 52001 请求超时 重试 52002 系统错误 重试 52003 未授权用户 检查您的appid是否正确 52004 输入解析失败 检查输入编码格式，有无特殊字符，是否是json格式 52005 输入字段有误 是否包含text字段 52006 输入文本长度有误 输入不能超过5个字符 52007 输入文本包含政治&amp;黄色内容 换输入文本 52008 后台服务返回错误 重试 54003 访问频率受限 请降低您的调用频率 54100 查询接口参数为空 检查是否少传参数 54102 无写诗结果 重试 2 后端连接超时 重试 代码实现 本文使用 python3 来调用智能春联和智能写诗接口，接下来一步一步进行说明。 创建应用 首先进入到控制台，然后在“总览”下找到“产品服务” -&gt; “人工智能” -&gt; “自然语言处理”。 然后点击创建应用，填写好“应用名称”、“应用描述”，其他默认就行，然后点击“创建”。 创建好应用之后，进入“应用列表”，就能看到应用的相关信息，我们需要的是 API Key 和 Secret Key。 获取 access token 通过 API Key 和 Secret Key 获取的 access_token。更多关于 access_token 的获取方法参考 http://ai.baidu.com/docs#/Auth/top。 下面代码是 python3 获取 access_token 的代码 # 获取 token def get_token_key(): token_key = '' # client_id 为官网获取的AK， client_secret 为官网获取的SK client_id = '【百度云应用的AK】' client_secret = '【百度云应用的SK】' host = f'https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials' \\ f'&amp;client_id={client_id}&amp;client_secret={client_secret}' request = Request(host) request.add_header('Content-Type', 'application/json; charset=UTF-8') response = urlopen(request) token_content = response.read() if token_content: token_info = json.loads(token_content) token_key = token_info['access_token'] return token_key token_content 中包含很多信息，例如输出如下(为了我个人信息安全，部分内容用 * 代替)： {'access_token': '****************************************', 'expires_in': 2592000, 'refresh_token': '*******************************************', 'scope': 'brain_nlp_sentiment_classify_custom public nlp_simnet nlp_wordemb ' 'nlp_comtag nlp_dnnlm_cn brain_nlp_lexer brain_all_scope ' 'brain_nlp_comment_tag brain_nlp_dnnlm_cn brain_nlp_word_emb_vec ' 'brain_nlp_word_emb_sim brain_nlp_sentiment_classify ' 'brain_nlp_simnet brain_nlp_depparser brain_nlp_wordembedding ' 'brain_nlp_dnnlm_cn_legacy brain_nlp_simnet_legacy ' 'brain_nlp_comment_tag_legacy brain_nlp_lexer_custom ' 'brain_nlp_keyword brain_nlp_topic brain_nlp_ecnet brain_nlp_emotion ' 'brain_nlp_comment_tag_custom wise_adapt lebo_resource_base ' 'lightservice_public hetu_basic lightcms_map_poi kaidian_kaidian ' 'ApsMisTest_Test权限 vis-classify_flower lpq_开放 cop_helloScope ' 'ApsMis_fangdi_permission smartapp_snsapi_base iop_autocar ' 'oauth_tp_app smartapp_smart_game_openapi oauth_sessionkey ' 'smartapp_swanid_verify smartapp_opensource_openapi', 'session_key': '*****************************', 'session_secret': '*******************************'} 而我们需要的只是 access_token ，因此只需获取该字段就行。 调用智能春联接口 调用智能春联接口的 python3 实现代码如下： # 调用百度 AI 智能春联接口（用于测试） def get_couplets(text, token_key, index=0): &quot;&quot;&quot; 调用百度AI智能春联接口，并生成横批、上联和下联 :param text: 智能春联的主题（官方限制不超过5个字） :param token_key: 通过调用 get_token_key() 获取的 token :param index: 不同的 index 会生成不同的春联 :return: 调用智能春联生成的数据 &quot;&quot;&quot; request_url = 'https://aip.baidubce.com/rpc/2.0/nlp/v1/couplets' params_d = dict() params_d['text'] = text params_d['index'] = index params = json.dumps(params_d).encode('utf-8') access_token = token_key request_url = request_url + &quot;?access_token=&quot; + access_token request = Request(url=request_url, data=params) request.add_header('Content-Type', 'application/json') response = urlopen(request) content = response.read() if content: data = json.loads(content) return data # 解析生成的春联 def parse_couplets(data): &quot;&quot;&quot; 解析调用智能春联生成的数据 :param data: 调用智能春联生成的有效数据 :return: 横批（center）、上联（first）和下联（second） &quot;&quot;&quot; center = data['couplets']['center'] first = data['couplets']['first'] second = data['couplets']['second'] # print(f'上联：{first}') # print(f'下联：{second}') # print(f'横批：{center}') return center, first, second get_couplets 函数调用接口得到返回的值，parse_couplets 函数解析调用智能春联生成的有效数据。这里所说的有效数据是指调用接口没有发生错误的情况。在正确调用接口时，data 输出示例如下： {'couplets': {'center': '迎春接福', 'first': '春节迎春新世纪', 'second': '福音报福小康年'}} 是一个字典型数据，直接进行解析就能得到横批、上联和下联。如果想要获取同一主题不同的对联，可以尝试不同的 index。 当调用接口失败时，就会得到无效的 data，通过解析 data，能够获得错误信息，下面是解析错误的代码，能够返回对应错误的中文描述。 # 错误代码 ERROR_DICT = { '2': '后端连接超时请重试', '52001': '请求超时请重试', '52002': '系统错误请重试', '52003': '未授权用户', '52004': '输入解析失败', '52005': '输入字段有误', '52006': '输入文本长度不超过5', '52007': '输入文本包含政治&amp;黄色内容', '52008': '后台服务返回错误请重试', '54003': '访问频率受限', '54100': '查询接口参数为空', '54102': '无写诗结果请重试' } # 解析是否调用接口错误，如果有返回对应的提示，没有返回None def parse_error(data): &quot;&quot;&quot; 解析是否调用接口错误 :param data: 调用接口生成的数据 :return: 如果出错，返回对应的错误信息，否则返回None &quot;&quot;&quot; if 'error_code' in data: code = data['error_code'] error = ERROR_DICT[str(code)] return error return None 调用智能写诗接口 调用智能写诗接口的 python3 实现代码如下： # 调用百度 AI 智能写诗接口（用于测试） def get_poem(text, token_key, index=0): &quot;&quot;&quot; 调用百度AI智能写诗接口，并生成七言诗 :param text: 智能写诗的主题（官方限制不超过5个字） :param token_key: 通过调用 get_token_key() 获取的 token :param index: 不同的 index 会生成不同的七言诗 :return: 调用智能写诗生成的数据 &quot;&quot;&quot; request_url = 'https://aip.baidubce.com/rpc/2.0/nlp/v1/poem' params_d = dict() params_d['text'] = text params_d['index'] = index params = json.dumps(params_d).encode('utf-8') access_token = token_key request_url = request_url + &quot;?access_token=&quot; + access_token request = Request(url=request_url, data=params) request.add_header('Content-Type', 'application/json') response = urlopen(request) content = response.read() if content: data = json.loads(content) return data # 解析生成的诗句 def parse_poem(data): &quot;&quot;&quot; 解析调用智能写诗生成的数据 :param data: 调用智能写诗生成的有效数据 :return: 诗的题目（title）和诗的内容（content） &quot;&quot;&quot; title = data['poem'][0]['title'] poem = data['poem'][0]['content'].replace('\\t', '\\n') # print(title) # print(poem) return title, poem 在正确调用接口时，data 输出如下: {'poem': [{'content': '神州崛起宏图展\\t华夏腾飞巨浪狂\\t万里江山添锦绣\\t千秋百度铸辉煌\\t', 'title': '百度'}]} 是一个字典型数据，直接进行解析就能得到题目和内容。如果想要获取同一主题不同的诗，可以尝试不同的 index。 案例应用 本文进一步通过网页的形式将上述功能进行实现，使用 Flask 来部署。 首先创建一个文件夹 flaskr ，该文件夹下有一个名为 static 的文件夹，用于存放css 样式和背景图片，还有一个文件夹名为 templates 用于存放 html 网页，另外还有一个 python 文件，用于执行 flask 。 以下是 Flask 相关代码 from flask import Flask, render_template, request, redirect, url_for, session from flaskr.poem import nlp_result, parse_error, parse_couplets, parse_poem import random app = Flask(__name__) token_key = '【你获取的token】' @app.route(&quot;/&quot;, methods=('GET', 'POST')) def index(): if request.method == 'POST': couplets = request.form.get('couplets') if couplets is not None: return redirect(url_for('get_couplets')) poem = request.form.get('poem') if poem is not None: return redirect(url_for('get_poem')) return render_template('couplets/index.html') @app.route(&quot;/couplets&quot;, methods=('GET', 'POST')) def get_couplets(): if request.method == 'POST': center = None first = None second = None title = request.form.get('theme') back = request.form.get('back') if back == '返回': return redirect(url_for('index')) index = random.randint(0, 10) data = nlp_result(title, token_key, index, way='couplets') error = parse_error(data) if not error: center, first, second = parse_couplets(data) return render_template('couplets/show.html', center=center, first=first, second=second, title=title, error=error) return render_template('couplets/base.html') @app.route(&quot;/poem&quot;, methods=('GET', 'POST')) def get_poem(): if request.method == 'POST': title = None poem = None title = request.form.get('theme') back = request.form.get('back') if back == '返回': return redirect(url_for('index')) index = random.randint(0, 10) data = nlp_result(title, token_key, index, way='poem') error = parse_error(data) if not error: title, poem = parse_poem(data) return render_template('couplets/poem_show.html', title=title, poem=poem, error=error) return render_template('couplets/poem_index.html') if __name__ == '__main__': app.run(debug=True) 该代码中有三个函数，分别对应三个界面，如果运行地址为 http://127.0.0.1:5000/ ，那么三个界面对应的网址分别为 http://127.0.0.1:5000/ 、http://127.0.0.1:5000/couplets 和 http://127.0.0.1:5000/poem 。表示主页、对联页和写诗页。 其效果展示如下： 处理错误信息的效果展示如下： ","link":"https://Wangrongsheng.github.io/post/8BnJ8IzJ-/"},{"title":"Linear Regression","content":" 本文只讲一元线性回归！ 回归分析 回归分析是一种预测性的建模技术，它研究的是因变量（目标）和自变量（预测器）之间的关系。这种技术通常用于预测分析，时间序列模型以及发现变量之间的因果关系。通常使用曲线/线来拟合数据点，目标是使曲线到数据点的距离差异最小 。 线性回归概述 线性回归是回归问题中的一种，线性回归假设目标值与特征之间线性相关，即满足一个多元一次方程。通过构建损失函数，来求解损失函数最小时的参数w和b。通长我们可以表达成如下公式： y^\\hat{y}y^​ 为预测值，自变量x和因变量y是已知的，而我们想实现的是预测新增一个x，其对应的y是多少。因此，为了构建这个函数关系，目标是通过已知数据点，求解线性模型中w和b两个参数。 线性回归算法步骤 1）给定数据集，进行初始输入。 2）获得目标/损失函数。 求解最佳参数，需要一个标准来对结果进行衡量，为此我们需要定量化一个目标函数式，使得计算机可以在求解过程中不断地优化。针对任何模型求解问题，都是最终都是可以得到一组预测值 y^\\hat{y}y^​ ，对比已有的真实值 y ，数据行数为 n ，可以将损失函数定义如下： 即预测值与真实值之间的平均的平方距离，统计中一般称其为MAE(mean square error)均方误差 。把之前的函数式代入损失函数，并且将需要求解的参数w和b看做是函数L的自变量，可得： 在统计中，除了MAE之外，还有：MSE、RMSE，具体可自行百度 现在的任务是求解最小化L时w和b的值，即核心目标优化式为： 3）对损失函数进行求导，求解过程是使用最小二乘法(least square method)。 求解 w 和 b 是使损失函数最小化的过程，在统计中，称为线性回归模型的最小二乘“参数估计”(parameter estimation)。我们可以将 L(w,b) 分别对 w 和 b 求导，得到： 令上述两式为0，可得到 w 和 b 最优解的闭式(closed-form)解： 4）梯度下降，更新参数。 梯度下降手工推导 代码实现 python import numpy as np from matplotlib import pylab as pl # 定义训练数据 x = np.array([1,3,2,1,3]) y = np.array([14,24,18,17,27]) # 回归方程求取函数 def fit(x,y): if len(x) != len(y): return numerator = 0.0 denominator = 0.0 x_mean = np.mean(x) y_mean = np.mean(y) for i in range(len(x)): numerator += (x[i]-x_mean)*(y[i]-y_mean) denominator += np.square((x[i]-x_mean)) print('numerator:',numerator,'denominator:',denominator) b0 = numerator/denominator b1 = y_mean - b0*x_mean return b0,b1 # 定义预测函数 def predit(x,b0,b1): return b0*x + b1 # 求取回归方程 b0,b1 = fit(x,y) print('Line is:y = %2.0fx + %2.0f'%(b0,b1)) # 预测 x_test = np.array([0.5,1.5,2.5,3,4]) y_test = np.zeros((1,len(x_test))) for i in range(len(x_test)): y_test[0][i] = predit(x_test[i],b0,b1) # 绘制图像 xx = np.linspace(0, 5) yy = b0*xx + b1 pl.plot(xx,yy,'k-') pl.scatter(x,y,cmap=pl.cm.Paired) pl.scatter(x_test,y_test[0],cmap=pl.cm.Paired) pl.show() sklearn import numpy as np from sklearn.linear_model import LinearRegression import matplotlib.pyplot as plt x = [1,3,2,1,3] x = np.reshape(x,newshape=(5,1)) y = [14,24,18,17,27] y = np.reshape(y,newshape=(5,1)) # 调用模型 lr = LinearRegression() # 训练模型 lr.fit(x,y) # 计算R平方 print(lr.score(x,y)) # 计算y_hat y_hat = lr.predict(x) # 打印出图 plt.scatter(x,y) plt.plot(x, y_hat) plt.show() 线性回归特点 优点 （1）思想简单，实现容易。建模迅速，对于小数据量、简单的关系很有效。 （2）是许多强大的非线性模型的基础。 （3）线性回归模型十分容易理解，结果具有很好的可解释性，有利于决策分析。 （4）蕴含机器学习中的很多重要思想。 （5）能解决回归问题。 缺点 （1）对于非线性数据或者数据特征间具有相关性多项式回归难以建模. （2）难以很好地表达高度复杂的数据。 ","link":"https://Wangrongsheng.github.io/post/Mw4WwCezN/"},{"title":"Attention Model-基础","content":" 为什么要引入注意力机制？ 计算能力的限制 当要记住更多的“信息”时，模型变得更复杂，然而目前计算能力依然是限制神经网络发展的瓶颈。 优化算法的限制 虽然局部连接，权重共享以及池化等优化操作可以让神经网络变得简单一些，有效缓解模型复杂度和表达能力之间的矛盾；但是，如循环神经网络（RNN）中的长距离依赖问题，信息“记忆”能力并不高。 因此，人们参照人脑处理信息过载的方式 ，例如注意力机制可以提高神经网络处理信息的能力。 关于人脑处理信息： 对于一张图片，我们人眼对整张图片不会全面观察，只会观察集中的一部分 ，然后再依次向外逐渐发散观察；对于几行字，加入我们要对这几行字进行翻译，如果是机器，它就会全面的进行扫描，而这增大了任务难度或者说降低了效果，参照我们人类的习惯，我们将会对几行字，逐行进行观察 ，这就可以有效的优化我们的机器模型。 注意力机制有哪些？ 当用神经网络来处理大量的输入信息时，也可以借鉴人脑的注意力机制，只选择一些关键的信息输入进行处理，来提高神经网络的效率。按照认知神经学中的注意力，可以总体上分为两类： 聚焦式（focus）注意力 ：自上而下的有意识的注意力，主动注意--是指有预定目的的、依赖任务的、主动有意识的聚焦于某一对象的注意力； 显著性（saliency-based）注意力 ：自下而上的有意识的注意力，被动注意--基于显著性的注意力是由外界刺激驱动的注意，不需要主动干预，也和任务无关；可以将最大池化和门控（gating）机制 来近似看作是自下而上的基于显著性的注意力机制。 在人工神经网络中，注意力机制一般就特指聚焦式注意力 。 无注意力机制 普通的Encoder-Decoder（seq2seq） 结构：（基于RNN ） x 是输入序列 Encoder 是编码器；Decoder 是解码器 语义编码C是对输入的高度概括，是输入的核心总结 y 是输出 其概括形式： 在这个过程当中，我们的语义编码使用的是相同的值。那么，所有的预测输出 y1y_{1}y1​ 、 y2y_{2}y2​ 、 y3y_{3}y3​ ...都完全依赖于同一个语义编码C来决定，真的科学吗？ 注意力机制 以机器翻译为例： 在翻译“汤姆”时，原句中的三个词对其贡献度不同，关联度最高的应该是“Tom”。同样，于“追逐”关联度最高的是“chase”，与“杰瑞”关联度最高的是“Jerry”。 在C中，所有词的对应权重是相同 的。并且固定编码C能表示的信息有限 ，尤其是在长句子中。 提出注意力机制 ，使得在翻译时不同词时，注意到各个词的贡献（相关性）。 很明显，这里我们就会冒出一个问题：权重如何计算？ 在计算中，如果 h1h_{1}h1​ 与 H1H_{1}H1​ 的相似度值越大，那么赋予的权值越大。 在赋予权值之前，我们需要用Softmax 进行归一化处理 例子 Tom chase Jerry =&gt; 汤姆 追逐 杰瑞 假设汤姆对应的隐藏层向量：[10,5,10] import numpy as np tom_init = np.array([10,5,10]) tom_hidden = np.array([5,0,1]) chase_hidden = np.array([0,1,1]) jerry_hidden = np.array([1,1,0]) print(&quot;score：&quot;) print(np.multiply(tom_init, tom_hidden)) print(np.multiply(tom_init, chase_hidden)) print(np.multiply(tom_init, jerry_hidden)) 在翻译“汤姆”时的注意力权重分布矩阵为：[3.15,0.3,0.75] 总结 注意力机制就是通过学习得到一个权重分布，再把这个权重分布施加到原来的特征上面。以获取更多所需要关注目标的细节信息，而抑制其他无用信息。是一种资源分配方式。 参考 动画图解Attention机制 ","link":"https://Wangrongsheng.github.io/post/GKDlX69Cx/"},{"title":"把PPT放入浏览器中","content":" 简介 会议、演讲离不开幻灯片，它可以有效地辅助演讲者进行表达。目前一些流行的工具，比如Windows 平台上的PowerPoint 、Mac 平台上的Keynote 等工具，使得幻灯片的制作变得简单。但是这些幻灯片取决于特定的工具才能演示，且不利于传播。 随着HTML5 技术的发展，现在JavaScirpt 也可以用来制作幻灯片，直接使用浏览器就可以播放，这样你只需给别人发一个链接即可。 js幻灯片 Name Demo Code Deck.js 查看 下载 Tacion.js 查看 下载 Fathom.js 查看 下载 Impress.js 查看 下载 Reveal.js 查看 下载 Presenteer.js 查看 下载 Jmpress.js 查看 下载 DZ Slides 查看 下载 slides 查看 下载 Slides Google Code 查看 下载 Perkele.js 查看 下载 HTML Slidy 查看 下载 参考 https://blog.csdn.net/j9y6f315/article/details/50054035 ","link":"https://Wangrongsheng.github.io/post/OJDdcBtKP/"},{"title":"混淆矩阵","content":" 在得到模型后，你需要借助一些指标来评估这个模型的好坏。人在学习后，会通过考试来评价学习效果，最终会评出优等生、差等生。机器学习也是一样的。区别只是机器学习会根据问题的不同，用不同的指标来进行模型效果的评估。对于分类问题，混淆矩阵是一种直观的模型效果分析方法。假设有个二分类模型，可以对一件事的正（P）负（N）作出判断。这样，在一次判断中，存在真实结果 y^\\hat{y}y^​ 和预则结果y。如果二者相等，也就是本次预测结果正确；反之则错误。假设有100个不同的测试用例，就会有以下四种可能性： 本来是P的用例被预测为P； 本来为P的用例被预测为N； 本来是N的用例被预测为P； 本来为N的用例被预测为N。 我们把这四种情况进行统计，就得到了这样的一个表格，这就是混滴矩阵。 在这个表中，横向表示预测结果，纵向表示真实结果。我们用TP、FP、FN、TN表示上面的四种可能性。这里面的T和F表示正确预测（true）或错误预测（false）；而P和N是被T或F修饰的正负，显然这是预测值，因为只有预测值才有对错之分。那么，首先，TP为True Positive，含义为真的正样本。也就是预测值为P，真实值也是P的情况。这个例子中，共有20个样本属于TP。其次，FP为False Positive，含义为假的正样本，也就是预测值为P真实值为N的情况。这里共有8个样本属于FP。接下来，FN为False Negative，含义为假的负样本，也就是预测值为N真实值为P的情况。这里共有6个样本属于FN。最后的TN为True Negative，含义为真的负样本，也就是预测值和真实值都为N的情况。这里共有66个样本属于TN。有了混滴矩阵后，就能计算一些模型的统计量指标了。 ","link":"https://Wangrongsheng.github.io/post/0ptSo1T-y/"},{"title":"RSS个人订阅管理","content":" FreshRSS 订阅器，免费，界面很美观，支持导入/导出为OPML 文件，过滤、标记、搜索等，有助于轻松查找和阅读文章，也可以多用户使用，还可以安装很多拓展和更换不同的主题，而且查看10万篇文章都不会卡。 官方网站：https://freshrss.org 官方Github：https://github.com/FreshRSS/FreshRSS 演示 演示地址：http://rss.sqdxwz.com/ 演示图： 安装 在宝塔下进行安装！ 1、去官网 下载最新的安装包 2、上传安装包到宝塔上 3、然后打开你的网站yoursite/ 进行安装 可能遇到的问题 如果提示缺少某个函数 ，你只需要在宝塔里面找到你的PHP -&gt; 设置 -&gt; 禁用函数 ，把禁用的函数删除就可以 安装的某一步中，可能会填写数据库等信息，填写示例： ","link":"https://Wangrongsheng.github.io/post/ZZuyOCXTf/"},{"title":"什么是机器学习","content":" 机器学习 机器学习从字面来看可以理解为是“让机器去学习”。我们人类，从小到大一直都在不停地学习与进步。最终用学来的知识造福整个社会。如果让某台机器也去学习，那么它将会具备和人类类似的思维方式。也就是可以实现让机器去造福人类社会，这无疑就是时代的进步。那么，机器学习到底是要让机器学会什么呢？要回答这个问题，就需要从人类的学习讲起。我们回想一下学生时代。在课本中，告诉了我们加法的计算方法和一些例题。有了这些输入后，我们就去学习并掌握了关于加法的知识点。那么在考试中，即使我们没有见过101+205的例题，也可以轻松回答出答案是306。讲到这里，你可以思考这样的一个问题。如果能把人类学习的过程进行抽象，凝练成一些固定的方法；再用某个机器（程序、软件、或计算机）去批量化执行这些方法，那么这个机器是否能和人类一样具备学习能力，并最终掌握某项知识呢？这个问题就是机器学习这门学科要解决的问题，也是机器学习的初衷。 有了这个初哀后，机器学习要解决的首要问题就是如何把人类学习的过程进行抽象，并凝练成固定的方法。为了回答这个问题，就需要从人类的学习的过程入手。我们知道，几乎每一本教材都会有例题和习题，这就说明了，在学习某个知识时，最不可或缺的就是做题。人通过做题，对做题结果进行校验，并总结、归纳结果做对或做错的原因，逐渐地就掌握了某项知识。这个凝练的过程就是做题、校验、归纳这三个步骤。 三把金钥匙 人类学习是通过做题、校验、归纳，逐渐掌握某项知识。那么如果能把这些过程凝练成固定的方法和规则，机器就一定也可以具备学习的能力。对标人类的学习，机器学习也一定包含类似于“做题、校验、归纳”这样的三个步骤。在机器学习的知识体系中，我喜欢称之为机器学习的3把金钥匙，这3把金钥匙分别命名为“模型、策略、算法”。接下来，我们分别看一下这3把金钥匙是怎么一回事。 模型 3把金钥匙之一的模型对标人类学习过程中的做题。做题就是根据题目信息，输出答案的过程。如果用数学语言来描述就是一个函数y=f(w,x)。其中，x代表的是题目的输入信息，通常也叫作特征向量（feature vector）。y就是模型给出的答案，通常也叫作预测值。而模型要计算答案依赖某些参数，这里用W来统一代替。因此，上面的公式就是机器学习的第一把金钥匙。 策略 3把金钥匙之二的策略对标人类做题后得到结果的校验过程。校验就是拿计算的答案和标准答案比对的过程。对于机器学习也是一样的。先前的第一把金钥匙已经给了我们预测值y，而且每个特征向量对应的标准答案（真实值 y^\\hat{y}y^​ ）也是已知的。这样就可以通过某个函数，来衡呈预测值与真实值的距离，也就是结果有多对、或者有多错。在机器学习中，这个函数称为损失函数（Loss Function），用l（wW）来表示。如果用更泛化的数学语言来描述，就是 对于这个通式而言，x和 y^\\hat{y}y^​ 是已知呈。因此，损失函数是关于模型参数w的函数。这就是第二把金钥匙的数学表达式。 算法 3把金钥匙之三的算法，对标人类做题后，分析结果做对或做错的原因。根据第一把金钥匙，不难发现，题目做对或做错的关键原因在于W。第二把金钥匙又衡量了做对或做错的程度。那么，就可以通过调整w，让结果不断向做对的趋势前进。如果用数学语言来描述，那就是我们在第一课时中老生常谈的求极值。也就是说，学习的目标就是要找到让损失函数最小的W的值。因此，算法的数学表达式为 表达的意思是 w 可以让损失函数 L(w) 取得最小值。 我们对机器学习的3把金钥匙进行了梳理。你可能听说过线性回归、逻辑回归、决策树、神经网络等不同的机器学习模型，甚至还被这些模型不同的建模方法搞得晕头转向。但本质上，这些模型都会遵循上面所说的3把金钥匙。3把金钥匙对应3个数学表达式，也就是3个方程。你甚至可以简单粗暴地理解为机器学习就是解方程。只要你把这3个方程都解开，自然就学会了机器学习这门技术。 在讲述第二把金钥匙的时候，我们曾说特征向呈对应的标准答案（真实值 y^\\hat{y}y^​ ）是已知的。这句话在绝大多数的场景都是正确的，但在某些场景中并不成立。也就是说，在某些机器学习问题中，代表标准答案的真实值是未知的。在处理这些问题时，由于没有真实值，损失函数也就变得没有意义了。第二把金钥匙失效后，第三把金钥匙也就没有意义了。那么是否可以说，这类问题机器学习就无从下手了呢？其实，这一类问题叫做无监督学习。在机器学习中，真实值也被称作标签。按照学习的对象是否包含标签，可以将机器学习划分为两类。 对于标签未知的问题，叫作无监督学习； 对于标签已知的问题，叫作监督学习。 标签已知的问题，自然遵循了3把金钥匙的框架。而标签未知的无监督学习则不再遵循。回想一下人类的学习，如果标准答案未知，你的学习深度一定会非常浅，最多也就是对题目本身的信息做一些统计上的分析，比如，这道题符号很多，是数学题；另一道题都是之乎者也，是语文题。至于题目的答案，在没有知识储备的情况下，你就不知道了。自然的没有标准答案的学习效果会非常差。因此，无监督学习的效果是不如监督学习的效果的。 在监督学习中最具代表性的问题，是分类问题和回归问题。分类问题是对输入数据预测其归属于某个类别的过程，即预测结果为离散值。例如，预测某场足球寒的胜负关系，你可以理解为分类问题是选择题。回归问题是对输入数据预测其具体值的过程，即预测结果为连续值。例如，预测明天本市的降水量，你可以理解为回归问题就是填空题。绝大多数的监督学习问题，都可以被归属于这两个问题之一。对于无监督学习，问题可能会比较多变。 ","link":"https://Wangrongsheng.github.io/post/sEyjh6ssm/"},{"title":"python创建虚拟环境","content":" 创建虚拟环境是为了让项目运行在一个独立的局部的Python 环境中，使得不同环境的项目互不干扰。 1、安装虚拟环境的第三方包 virtualenv pip install virtualenv 使用清华源安装：pip install virtualenv -i https://pypi.python.org/simple/ 2、创建虚拟环境 cd 到存放虚拟环境光的地址 virtualenv ENV 在当前目录下创建名为ENV 的虚拟环境（如果第三方包virtualenv 安装在python3 下面，此时创建的虚拟环境就是基于python3 的） virtualenv -p /usr/local/bin/python2.7 ENV2 参数 -p 指定python 版本创建虚拟环境 virtualenv --system-site-packages ENV 参数 --system-site-packages 指定创建虚拟环境时继承系统三方库 3、激活/退出虚拟环境 cd ~/ENV 跳转到虚拟环境的文件夹 activate 激活虚拟环境 pip list 查看当前虚拟环境下所安装的第三方库 deactivate 退出虚拟环境 4、删除虚拟环境 直接删除虚拟环境所在目录即可 ","link":"https://Wangrongsheng.github.io/post/TVONRWeGa/"},{"title":"机器学习之统计学","content":" 本次我们学习与机器学习相关的统计学相关知识，主要包括统计量、中心极限定理、均值假设检验、AB 实验方法等内容。 根据现状，很多从事机器学习工作相关的人并没有太多统计学的知识储备。不得不说，缺乏统计学的知识，并不会阻碍你用机器学习技术去建立模型。那么为什么还要在此强调统计学的重要性呢？甚至还专门用一个课时来说明它呢？原因主要在于模型灰度或应用阶段的评估。我们知道，机器学习是以数据分析、预测为基础，来优化业务决策的一门技术。那么，在模型灰度测试时，如果你不具备基础的统计学知识，就无法分辨模型带来的效果提升是随机波动还是真实收益。因此这一课时，我们就来铺垫与机器学习相关的基础统计学知识。 统计量 统计量是指用来描述一大堆数字性质的数值，例如均值、中位数、方差、标准差，等等。假设从1~9这9个数字中进行抽样，得到如图所示的结果，其中每个绿色的点代表一个采样样本。若想描述清楚这些样本的数值性质，肯定是不能把每个样本都说一遍的，那么就需要借助统计量来进行描述了。 首先是均值，就是所有采样值的平均值。公式为： 接着是中位数，它是按顺序排列的一组数据中居于最中间位置的数。 方差是衡量一组数据离散程度的度量。计算方法是每个样本值与均值之差平方的均值。公式为 最后，标准差5。它和方差非常相似，只需要对方差开平方即可，就不再熬述其公式了。 这些统计量中最重要的要算均值和标准差了，会在后续频繁使用。有了这些统计量，我们就可以来描述样本的数值大小情况、样本与均值的离散程度等统计上的数值信息了。 例题 假设有个小团队的leader，他有9个员工。现在这个leader想以双倍的加班工资，让员工周六也来公司加班。但是他不确定员工对这个决策是否支持。因此，他决定调研所有的9名员工对这个政策的支持度。在回收到了表中的9份调研结果后，问题出现了。他如何从9份回答中，提取出具有代表性的结果并作出决策呢？ 这时，统计量的作用就发挥了价值。首先计算均值，9个数值求平均数，结果为3.4。接着看一下中位数。把这9个数字按照大小顺序排列，找到中间第5大的数字，得到中位数是4。再接着，计算方差。根据公式计算得到方差为2.7。开个根号，就得到了标准差1.6。经过这些统计量的分析就能得到下面的结论。首先，均值3.4分、中位数4分都大于了代表无所谓的3分，说明更多的员工是支持这项决策的。然而，方差和标准差都比较大，反映出员工的支持度波动比较大。也就是说存在部分员工特别支持这个决策，同时部分员工特别抵触这个决策。因此，决策的落地执行风险比较大。 通过这个例子我们会发现，在面对大量数据时，你仅仅通过一些统计量信息，就能把大量数据背后隐藏的性质、规律描述清楚，并形成某些结论，辅助你作出更客观、稳健的决策。 中心极限定理 从前面的例子可以发现，只要计算出某个分布的统计量，就能解决统计学面临的绝大多数问题。然而挑战在于，在很多场景下，你根本拿不到全部的样本数据。前面的例子比较简单，这个leader只有9个员工，全部调研一遍是完全可行的。但换个问题，情况可能完全不一样。例如，调研全国男女人口比例是多少。难道我们要把全国13亿人都问一遍吗？显然不可能。这个时候，就需要对13亿人进行采样，得到采样集合。接着可以计算采样集合中的统计量。那么问题来了，有了采样、有了采样集合的统计量，如何对总体的统计量进行估计呢？此时，就需要统计学中的圣经级定理——中心极限定理了。 极限定理能解决的问题很明确，即对于一个未知的总体，如何通过某些手段计算出总体的统计量。 中心极限定理的内容为，假设从均值为μ，方差为σ2的任意一个总体中，抽取样本量为n的样本。当n充分大时，样本均值 xˉ\\bar{x}xˉ 的分布近似服从均值为、方差为σ2/n的正态分布。其在统计学中，通常认为n&gt;=30即为大样本。 中心极限定理有几个要素： 它不需要总体满足什么分布的条件，哪怕不是正态分布的任意某个分布都适用。 它要求采样n至少为30。 中心极限定理的价值在于，它从统计量上，构建了总体和抽样之间的联系。别忘了，我们的现实世界中，上帝视角只是理论存在，因此由“抽样估计总体”必然是永恒的模式。 例题 假定现在我们是“上帝”，“上帝”是知道总体分布的。假设总体是在09之间均匀分布的整型随机数，那么均值就是4.5，方差为8.25。接着我们回归凡人。现在我们不知道这个总体是怎样的分布；只知道，这个总体会产生09的某个整数。于是，我们利用中心极限定理，去计算出总体的均值和方差。现在，我们从总体里抽取n个数，n=40，计算样本均值 xˉ\\bar{x}xˉ 。这样就得到了一次抽样的结果。中心极限定理关注的是，样本均值i的均值和方差。那么，就需要多次重复上述采样的过程。 假设我们重复了1万次，这样就得到了1万次采样，每次采样40个样本的数据集。 由于结果有随机性而且数据量非常大，我们尝试用Python进行仿真。这段代码中包含了两层循环。其中外层是1万次的采样循环，内层是每次采样获得40个样本的循环。每次获得40个样本后，我们需要计算这40个样本的均值。打印出来后，就得到了1万个均值。经过计算这1万个均值的均值和方差，得到均值为4.5033，方差为0.2058。最终，利用中心极限定理，我们可以对总体进行估计，得到总体的均值为4.5033，总体的方差为0.2058×40=8.2320。 均值假设检验 计算完统计量是就需要去作出精准的决策了。例如，前面双倍工资加班的例子，就需要根据计算的统计量结果，去决策是否执行这个政策，以及执行风险有多大。根据统计量做决策就需要用到均值假设检验的相关方法了。 均值假设检验的目的在于，验证抽样得到的均值是否显著。显著的意义是，结果是真实客观的规律，并非偶然得到。那么假设检验的流程是，先对均值u的值提出一个假设，然后利用样本信息去检验这个假设是否成立。检验的方法是确定检验统计量，并计算数值，根据数值大小查表得到显著性p。通常显著性p&lt;0.05为显著性。 当总体的标准差σ已知，且样本量n较大，则采用Z统计量，计算公式为 当总体标准差未知，可以用样本标准差 s 代替，公式改写为 例题 假设某机床厂加工一种零件，根据经验知道，该厂加工零件的椭圆度服从正态分布，起总体均值为0.081mm，今另换一种新机床进行加工，取200个零件进行检验，得到椭圆度均值为0.076mm，样本标准差为0.025mm，问新机床加工零件的椭圆度总体均值与以前有无显著差别？ 在这个例子中，发现抽样得到的均值比总体均值小，问题的本质是在问，这个减小是偶然得到的，还是真实存在的，解题思路如图所示。 根据定义，统计量的值为-2.83。我们用p表示显著性水平，通常取p&lt;0.05为显著。当显著性为0.05时查询Z统计的表，可得到临界值为士1.96。我们发现此处的统计量绝对值为2.83，比1.96要大。Z的绝对值越大，对应p值越小，因此p&lt;0.05，二者有显著相关，并非是偶然得到。此处关于假设检验的更多细节，我们不再展开。你需要建立的核心意识是，可以通过计算Z统计量，并通过查表得到显著性p值。根据p值就可以判断结果是偶然得到的还是真实存在的。 AB实验 到这里，与机器学习强相关的统计学知识就已经准备妥当了。接下来看这些知识到底会在机器学习的哪个环节产生作用。 来看一个完整的机器学习项目。我们先粗略拆分一个机器学习项目为定义需求、建立模型、测试模型，即为什么做模型、怎么做的模型、以及如何测试模型效果这三个部分。统计学知识，更多是在“如何测试模型效果”这个环节中生效。也就是我们常说的开展AB实验的环节。 例如，你在今日头条工作，并开发了一个推荐系统。然后你需要验证这个推荐系统会使用户阅读文章的总数有所提高。那么你需要把用户拆分为无差别的两组。一组不施测推荐系统，另一组施测推荐系统。并观察两组用户阅读量的变化情况。接着你可能发现施测推荐系统的用户阅读量比另一组高，这样得到“推荐系统有效”的结论，那么这个结论就会被人质疑是否是偶然间得到的。为了让结果更有说服力，就需要用均值假设检验的知识来分析结果。你得到了抽样的结果，需要通过中心极限定理估计未知总体的统计量，然后根据假设检验的方法计算结果的显著性。如果显著，那么你的结果就是置信的、可靠的。最后，你就可以申请让你的模型从灰度测试到全量上线，创造更大范围的商业价值啦。这就是这些知识在机器学习中的作用。 ","link":"https://Wangrongsheng.github.io/post/8rvrLSChK/"},{"title":"Ubuntu 解压与压缩命令","content":" .tar 文件 # 仅打包，并非压缩 tar -xvf FileName.tar # 解包 tar -cvf FileName.tar DirName # 将DirName和其下所有文件（夹）打包 .gz文件 # .gz gunzip FileName.gz # 解压1 gzip -d FileName.gz # 解压2 gzip FileName # 压缩，只能压缩文件 .tar.gz文件、 .tgz文件 # .tar.gz 和 .tgz tar -zxvf FileName.tar.gz # 解压 tar -zcvf FileName.tar.gz DirName # 将DirName和其下所有文件（夹）压缩 tar -C DesDirName -zxvf FileName.tar.gz # 解压到目标路径 .zip文件 # 感觉.zip占用空间比.tar.gz大 unzip FileName.zip # 解压 zip FileName.zip DirName # 将DirName本身压缩 zip -r FileName.zip DirName # 压缩，递归处理，将指定目录下的所有文件和子目录一并压缩 .rar文件 # mac和linux并没有自带rar，需要去下载 rar x FileName.rar # 解压 rar a FileName.rar DirName # 压缩 ","link":"https://Wangrongsheng.github.io/post/xAiErfzbT/"},{"title":"深度学习之手势识别（一）环境搭建","content":" 简介 最近突然想实现一个全流程的深度学习过程，权衡之下，选择了做手势识别，我的思路很清晰，大致流程为： 环境搭建 数据集获取与标注 模型训练 模型导出 模型部署 基于以上流程，我们今天先来搭建我们所需要的环境。 注意：我们所有的操作默认在电脑D盘下运行！ 基础环境搭建 我先放出总的环境信息： python==3.6.5 # 下载地址：https://www.python.org/ftp/python/3.6.5/ tensorflow==1.12.0 opencv-python==4.2.0.34 python安装 直接去官网 下载，并确认设置了环境变量 。 注意安装的时候选择 Add to PATH 了就不需要再配置环境变量！ tensorflow安装 安装tensorflow ： pip install --upgrade --ignore-installed tensorflow==1.12.0 安装完成后，我们确认下是否安装成功？ 进入我们的python环境，然后： import tensorflow as tf print(tf.__version__) 如果可以正常输出你的tf版本为1.12.0 ，即为安装完成。 opencv安装 python -m pip install opencv-python python -m pip install Cython python -m pip install contextlib2 python -m pip install pillow python -m pip install lxml python -m pip install jupyter python -m pip install matplotlib tf的API框架搭建 tensorflow模型下载 我们打开自己的Git ，用来下载tensorflow 的模型： git clone -b r1.12.0 https://github.com/tensorflow/models.git D:/tensorflow/models 注意：注意，使用其他tensorflow 版本的同学，记得下载的模块版本分支要与tensorflow 版本一致 ，否则会出现很多奇奇怪怪的问题； protoc 下载 链接：https://wangrongsheng.lanzous.com/ibjuonc 使用protoc生成python文件 C:\\&gt;cd /d D:\\tensorflow\\models\\research D:\\tensorflow\\models\\research&gt;D:/tensorflow/protoc-3.4.0-win32/bin/protoc object_detection/protos/*.proto --python_out=. API测试准备 找到python的安装路径，我的虚拟环境路径：E:\\python365\\Lib\\site-packages； 在该文件夹下新建一个txt文件，打开该txt文件，输入以下三条路径 D:\\tensorflow\\models\\research D:\\tensorflow\\models\\research\\slim D:\\tensorflow\\models\\research\\object_detection 将该文件命名为tensorflow_model.pth 储存即可。 API测试 回到cmd ，输入： cd /d D:\\tensorflow\\models\\research python object_detection/builders/model_builder_test.py 得到ok，测试成功！此时tensorflow object detection API 框架搭建完成。 至此，我们要完成一个手势识别的环境搭建完成了！ ","link":"https://Wangrongsheng.github.io/post/1hH_BlSx0/"},{"title":"B站AI学习资源汇总","content":" AI入门了解 Crash Course AI https://space.bilibili.com/276373762/channel/detail?cid=101907 课程介绍：该课程出自Crash Course，首发YouTube，单个视频时长均在10分钟左右。视频节奏非常好，语速偏快，适合下饭时间入门了解。主讲很擅长深入浅出的讲清复杂的概念，一集信息量很大甚至评论区还会有课代表帮你总结才能稍稍消化。 数学基础 Up主：3Blue1Brown的数学基础 https://space.bilibili.com/88461692 课程介绍：用动画讲述数学专业知识，其视频涵盖了线性代数、微积分、拓扑学等领域，每门课都配有直观生动的动画演示，帮助观众加深对数学概念定理的理解。 数学分析 https://www.bilibili.com/video/av8042121 课程介绍：复旦陈纪修老师的数学分析视频课程，共214讲。陈纪修老师主持编写了21世纪课程教材——《数学分析》。 数学建模 www.bilibili.com/video/av8824879 课程介绍：清华大学数学建模公开课，共84讲。教材用的是《数学模型》姜启源 。 统计学 https://www.bilibili.com/video/av7199273 课程介绍：可汗学院公开课，将统计学所有内容都涵盖了。共85讲。 可视化 Python数据可视化分析 https://www.bilibili.com/video/av6989413 课程介绍：麦子学院的公开课，共31讲。 Matplotlib Python 画图教程 https://www.bilibili.com/video/av16378354 课程介绍：莫烦Python的课程内容，共19讲。 数据分析 Python 数据分析与展示(北京理工大学 ) https://www.bilibili.com/video/av10101509 课程介绍：北京理工大学MOOC课程，共65讲。 Numpy &amp; Pandas https://www.bilibili.com/video/av16378934 课程介绍：莫烦 Python 数据处理教程，主要讲解Numpy、Pandas两个包的使用。共18讲。 【数据分析】SQL数据库入门到精通，最干净易懂的小白必备教程10小时完整版 https://www.bilibili.com/video/av77541375 课程介绍：英文课程，中文字幕，很多同学表示这是看过最好的课程，通俗易懂。 数据挖掘 清华大学-数据挖掘：理论与算法 https://www.bilibili.com/video/BV154411Q7mGfrom=search&amp;seid=4187357852637700624 课程介绍：本课程完整覆盖数据挖掘领域的各项核心技术，包括数据预处理、分类、聚类、回归、关联、推荐、集成学习、进化计算等。强调在知识的广度、深度和趣味性之间寻找最佳平衡点，在生动幽默中讲述数据挖掘的核心思想、关键技术以及一些在其它相关课程和教科书中少有涉及的重要知识点，适合对大数据和数据科学感兴趣的各专业学生以及工程技术人员学习。 机器学习 [中英字幕]吴恩达机器学习系列课程 https://www.bilibili.com/video/BV164411b7dxfrom=search&amp;seid=13732295711057612613 课程介绍：这是个视频是转自吴恩达老师在Coursera上的公开课视频，内容偏向理论而并非实战，适合初学机器学习、深度学习的同学。需要视频配套资料的可以看看这里https://zhuanlan.zhihu.com/p/84214338这是国内黄博士为吴老师课程配的全套资料，包括视频字幕，对应python代码，原版PPT，中文版笔记等等 林轩田机器学习基石(国语) https://www.bilibili.com/video/av12463015/ 课程介绍：台湾大学林轩田老师的《机器学习基石》课程由浅入深、内容全面，基本涵盖了机器学习领域的很多方面。其作为机器学习的入门和进阶资料非常适合。而且林老师的教学风格也很幽默风趣，总让读者在轻松愉快的氛围中掌握知识。 机器学习技法（林轩田） https://www.bilibili.com/video/av85508326?p=1 课程介绍：同样是台大林轩田老师课程，通常学完基石的同学会继续学习这一门课程。 李宏毅机器学习(2017) https://www.bilibili.com/video/av10590361 课程介绍：台大教授李宏毅制作的，经常被认为机器学习中文课程的首选，而且课程风格诙谐幽默，这就让枯燥的课程变的有趣许多。而且最重要的是，课程中布置了很多作业，而万能的网友更是找出了作业答案，并将其公布在了留言区，可以说太良心了，简直是没钱报班学习者的福音。 up主：shuhuai008 【机器学习】【白板推导系列】 https://www.bilibili.com/video/av70839977 课程介绍：这个up主来自清华，他做的这一套机器学习白板推导的视频讲解系列目前出到第33集流模型。这个视频系列最大的特点是给出了整体的框架，再用单章去分解里面的重点，力求做到简洁易懂，很有中国特色。对比国外普遍一个视频2小时的课程，更适合国人。 机器学习教程【强烈推荐】 https://www.bilibili.com/video/av46180067/ 课程介绍：这门课程来自邹博老师的《机器学习与数学分析》，风格同样是深入浅出、通俗易懂，对于有基础和没基础的同学，都能让你轻易入门。 机器学习算法-2017邹博最新（Python版） https://www.bilibili.com/video/av23585080 课程介绍：这门课程同样来自邹博老师，适合配合上一部一起观看。 (上海交通大学张志华)机器学习导论 https://www.bilibili.com/video/av76230791/ 课程介绍：张志华老师的这门课讲的很深入，适合学习机器学习和深度学习的研究者深入学习，内容比较偏向理论，需要一定的数学基础。 Scikit-learn (sklearn) 优雅地学会机器学习 (莫烦 Python 教程) https://www.bilibili.com/video/av17003173 课程介绍：莫烦的机器学习教程汇集了很多近些年来比较流行的 python 模块教程。课程内容有趣，没有机器学习背景的朋友们也能产生兴趣，对机器学习的每种方法都能迅速理解。另外，对于已经入门了的同学们, 这门课程也是一个提升自己应用机器学习的好地方, 因为里面同时也介绍了很多种机器学习的技巧方法, 能大大帮助提升学习效果。 Stanford : Statistical Learning 斯坦福大学：统计学习 https://www.bilibili.com/video/av19775701 课程介绍：这门课程来自统计学两位超级大佬，全英文字幕，是公认的统计学系入门课程，使用的教材是Introduction to statistical learning，极力避免深奥的公式推导和复杂的概念，对于数学基础不好的人非常友好。 深度学习 【中英字幕】吴恩达深度学习课程 第一课 — 神经网络与深度学习 https://www.bilibili.com/video/av66314465 课程介绍：这门课程的目标是为同学们介绍深度学习的基础知识。学完这门课，你将能够：理解驱动深度学习的主要技术趋势；能够搭建、训练并且运用全连接的深层神经网络；了解如何实现高效的（向量化）的神经网络；理解神经网络架构中的关键参数。 第二课 — 改善深层神经网络：超参数调试、正则化以及优化 https://www.bilibili.com/video/av66524657/ 课程介绍：这门课程将学会理解业界构建深度神经网络应用最有效的做法；能够高效地使用神经网络通用的技巧，包括初始化、L2和dropout正则化、Batch归一化、梯度检验；能够实现并应用各种优化算法，例如mini-batch、Momentum、RMSprop和Adam，并检查它们的收敛程度；理解深度学习时代关于如何构建训练/开发/测试集以及偏差/方差分析最新最有效的方法；能够用TensorFlow实现一个神经网络。 第三课 — 结构化机器学习项目 https://www.bilibili.com/video/av87949453?p=24 课程介绍：这门课程将学会理解如何诊断机器学习系统中的错误；能够优先减小误差最有效的方向；理解复杂ML设定，例如训练/测试集不匹配，比较并/或超过人的表现；知道如何应用端到端学习、迁移学习以及多任务学习。 第四课 — 卷积神经网络 https://www.bilibili.com/video/av66646276 课程介绍：这门课程将学会理解如何搭建一个神经网络，包括最新的变体，例如残余网络；知道如何将卷积网络应用到视觉检测和识别任务；知道如何使用神经风格迁移生成艺术；能够在图像、视频以及其他2D或3D数据上应用这些算法。 第五课 — 序列模型 https://www.bilibili.com/video/av66647398/ 课程介绍：这门课程将学会理解如何构建并训练循环神经网络（RNN），以及一些广泛应用的变体，例如GRU和LSTM；能够将序列模型应用到自然语言问题中，包括文字合成；能够将序列模型应用到音频应用，包括语音识别和音乐合成。 up主：周博磊 强化学习纲要 https://space.bilibili.com/511221970 课程介绍：最近，香港中文大学信息工程系助理教授周博磊也开始当up主，上传自己的《强化学习》课程。整个课程共分为基础课程和高阶课程两大部分，主要面向大三、大四或研一的学生，参加课程的学生需要具备相关背景知识，包括线性代数、概率论、机器学习（数据挖掘、模式识别、深度学习）等。此外，由于该课程有不少实践内容，所以参加课程的同学最好有一些编程经验，会用 Python、PyTorch。除了直播和课程视频之外，周博磊还会同步更新课程的代码，使用的编程语言为 Python，深度学习框架则是 TensorFlow 和 PyTorch 皆可（PyTorch 为主）。和常规的课程一样，《强化学习纲要》也会在每节课后留下一些作业。 深度学习框架Tensorflow学习与应用 https://www.bilibili.com/video/av20542427 课程介绍：这门课程来自炼数成金。课程内容基本上是以代码编程为主，也会有少量的深度学习理论内容。课程会从Tensorflow最基础的图(graphs),会话(session),张量(tensor),变量(Variable)等一些最基础的知识开始讲起，逐步讲到Tensorflow的基础使用，以及在Tensorflow中CNN和LSTM的使用。在课程的后面会带着大家做几个实际的项目，比如训练自己的模型去进行图像识别，使用Tensorflow进行验证码的识别，以及Tensorflow在NLP中的使用。 PyTorch 动态神经网络 (莫烦 Python 教学) https://www.bilibili.com/video/av15997678 课程介绍：这套视频比较适合有一些机器学习课程基础的同学。 Numpy &amp; Pandas (莫烦 Python 数据处理教程) https://www.bilibili.com/video/av16378934 课程介绍：这门课程汇集了在 Python 中最重要的数据处理，科学计算模块: Numpy 和 Pandas。 Matplotlib Python 画图教程 (莫烦Python) https://www.bilibili.com/video/av16378354/ 课程介绍：Matplotlib 是一个非常强大的 Python 画图工具;这门课程可以对比莫烦numpy &amp; pandas &amp; matplotlib同时来学。 tensorflow2.0入门与实战 2019年最通俗易懂的课程 https://www.bilibili.com/video/av62215565?p=17 课程介绍：本课程是关于Tensorflow与深度学习实战的一门课程。该课用通俗易懂的实例，系统讲解了Tensorflow2.0的使用，可以说是目前最新最系统的 Tensorflow 2.0 教程。其中讲解了Tensorflow中各种概念、操作和使用方法，针对Tensorflow的基础知识，在传统数据分析中应用进行详细讲解，并且给出了丰富的深度学习模型实战。 斯坦福2017季CS231n深度视觉识别课程视频 https://www.bilibili.com/video/av13260183/?p=1 课程介绍：本课程是斯坦福大学关于计算机视觉的课程，全英文字幕，老师是Fei-Fei Li, Justin Johnson, Serena Yeung。 【北京大学】人工智能实践：Tensorflow笔记 https://www.bilibili.com/video/av22530538 课程介绍：这是人工智能入门课，将用八次课帮你梳理人工智能概念、机器学习方法、深度学习框架。 Keras 快速搭建神经网络 (莫烦 Python 教程) https://www.bilibili.com/video/av16910214 课程介绍：这门课程包括对Keras的介绍以及如何搭建各种神经网络。 李宏毅对抗生成网络(GAN)国语教程(2018) https://www.bilibili.com/video/av24011528 课程介绍：这门课程内容详略得当，不想推公式的同学可以跳过推导，并不影响后续课程。 课程的项目和论文都很新，同时也很生动，可以迅速的接触一些最新的东西。另外，为了讲清楚一个概念或技术，PPT的可视化做的非常用心，简洁易懂。 李宏毅深度强化学习(国语)课程(2018) https://www.bilibili.com/video/av24724071/ 课程介绍：这门课程每个视频大约40分钟左右，PPT内容为英文，讲授语言为中文。课程内容主打强化学习，涉及理论和论文解读，需要同学们具备一定的强化学习基础。 David Silver 强化学习课程高清版 https://www.bilibili.com/video/av35209257/ 课程介绍：这是David Silver在 UCL 讲授的强化学习入门课程。Silver就是那位来自 DeepMind，在 Nature 上发表了 DQN 论文，紧接着提出 AlphaGo 和 AlphaGo Zero，从此掀起深度强化学习研究浪潮的大神。他的课程深入浅出，在介绍强化学习概念的过程中穿插了很多例子，对初学者非常友好，建议作为第一个观看的入门视频课程。 【中英文字幕】OpenAI - Spinning Up in Deep RL Workshop （Deep Reinforcement Learning） https://www.bilibili.com/video/av45364513/ 课程介绍：对于想上手实践深度强化学习的同学们，这门课程是不错的资源，从 VPG(Vanilla Policy Gradient) 到 TRPO(Trust Region Policy Optimization)、SAC(Soft Actor-Critic) 均有实现，关键是 OpenAI 出品，代码质量高。 斯坦福CS224n深度学习自然语言处理课程 by Chris Manning https://www.bilibili.com/video/av46216519/ 课程介绍：这门自然语言处理课程是值得每个NLPer学习的NLP课程，由 Christopher Manning大神坐镇主讲，在斯坦福大学已经讲授很多年。此次2019年新课，有很多更新，除了增加一些新内容外，最大的一点大概是代码由Tensorflow迁移到PyTorch。这门课程的主要目标是希望学生能学到现代深度学习相关知识，特别是和NLP相关的一些知识点；能从宏观上了解人类语言以及理解和产生人类语言的难度；能理解和用代码（PyTorch)实习NLP中的一些主要问题和人物，例如词义理解、依存句法分析、机器翻译、问答系统等。 自然语言处理 清华「云上学堂」:刘知远老师闲话AI——自然语言理解难在哪儿 https://www.bilibili.com/video/av90563504 课程介绍：这门课程来自清华大学计算机系刘知远老师。该课程不涉及任何算法及公式，主要是对为什么开展自然语言理解的研究进行介绍，对于想要入门相关领域同学不妨一看。 Python [小甲鱼]零基础入门学Python https://www.bilibili.com/video/av4050443 课程介绍：小甲鱼教学视频全套共96套，课程生动有趣幽默，强烈推荐给零基础学习python的同学，一步一步深入熟知Python。 Python编程 从入门到实践 https://www.bilibili.com/video/av35698354 课程介绍：这门课程还有配套纸质书籍，非常适合初学者入门的python神书，文笔精炼，内容浅显易懂，还有源代码可做练习题。 麻省理工公开课（计算机科学导论及Python编程） https://www.bilibili.com/video/av10497433 课程介绍：这门课是为零基础或编程经验较少的学生设计。适合新手学习编程，掌握基础计算机科学理论知识。 【Python】这可能是你见过的最简洁最没有废话的Python教程 https://www.bilibili.com/video/av5236569 课程介绍：老师雨敲窗表示，由于自己在python的学习道路上摸索了一些方法，也知道小白入门的痛点在哪里，所以这有可能是大家见到的最简洁的python入门教程，每节课视频长度5到10分钟，再花个一两个小时敲一敲代码就足够了。 python全栈开发（入门到放弃） https://www.bilibili.com/video/av13690129 课程介绍：这门课程共616讲，内容非常系统翔实，包含Python 领域方方面面，对基础的讲解非常透彻。 python数据结构与算法系列课程 https://www.bilibili.com/video/av21540971 课程介绍：课程一共44讲，知识点清晰，适合刚入门学习不久的学生，视频中所讲的算法较好理解，没学过python的也能看得懂，里面用得较多的是 if、while循环，涉及python其它的语法的少。另外，该视频还有配套书籍，名称是 《数据结构与算法 Python语言描述 裘宗燕著》。 Python教程_600集Python从入门到精通教程（懂中文就能学会） https://www.bilibili.com/video/BV1ex411x7Em?p=1 课程介绍：这套教程共分为三部分：Linux基础命令；Python基础教程；飞机大战项目演练。从Linux开始讲起是为了照顾真正零基础的同学。 2019 Python教程400集 不定时更新！ https://www.bilibili.com/video/av50240377/ 课程介绍：这套Python课程400集，从零基础开始，全面讲解Python基础，直达可以手写神经网络的境界。 Python 基础教程 (莫烦 Python 教程) https://www.bilibili.com/video/av16926522 课程介绍：Python基础非常适合刚入门, 或者是以前使用过其语言的同学, 每一段视频都不会很长, 节节相连, 对于迅速掌握基础的使用方法很有帮助。 【千锋教育】Python 900集（学完可就业/2019版） https://www.bilibili.com/video/av69060979 课程介绍：这门课程非常全面，很适合自学人群的查漏补缺。 ","link":"https://Wangrongsheng.github.io/post/QtPW6Ygst/"},{"title":"深度学习图像数据标注-LabelImg","content":" LabelImg 这里介绍另外一个图像标注工具-Labelmg ，这个名字是不是跟我的另外一篇文章《深度学习图像数据标注-Labelme 》很相似，但这两种标注工具确实存在不同： LabelImg 是目标检测的标注工具； Labelme 是语义分割的标注工具，和 LabelImg 的不同点是要对目标进行详细 的标绘，然后会生成一个目标的掩膜。 更详细的区别： Labelme LabelImg 打开文件 Open Open 打开文件夹 OpenDir OpenDir 前后帧变换 Next &amp; Prev Image Next &amp; Prev Image 标注方式 聚点分割&amp;矩形框&amp;圆&amp;线 矩形框 保存方式 JSON VOC&amp;YOLO 标注大小 内存占比大 忽略不计 优点 标注类型多（分割和检测）；标注文件另存了原始图像； 存储简单，RCNN、SSD、YOLO指定标注格式，对象明确，模式灵活 适应场景 大部分2D分割任务；少数据量2D检测任务 单目标的2D检测任务；适用于VOC格式的数据 安装使用 安装 在Anaconda Prompt中依次运行以下命令（注意大小写）： pip install PyQt5 -i https://pypi.tuna.tsinghua.edu.cn/simple/（后面这行是国内的清华镜像源，下载速度才会比较快） pip install pyqt5-tools -i https://pypi.tuna.tsinghua.edu.cn/simple/ pip install lxml -i https://pypi.tuna.tsinghua.edu.cn/simple/ pip install labelImg -i https://pypi.tuna.tsinghua.edu.cn/simple/ （Img中的I要大写，注意） 运行： labelImg 使用 关于使用方法，跟Labelme 是相似的，不多介绍。 图像标注工具labelImg使用方法 Windows下深度学习标注工具LabelImg安装和使用指南 简易版本的使用 ","link":"https://Wangrongsheng.github.io/post/iQ4CuLzbk/"},{"title":"第十人理论","content":" “在犹太人的社会中，为了使讨论深化，总有一位成员敢于提出反驳意见，被称为“恶魔拥护者”。他在对讨论的方向与大体的结论表示赞成的同时，敢于提出反面意见，对于解决方法的可行性进行验证，指出其中存在的矛盾与不合理之处。为了发现更好的解决方法，他从不同的角度提出反对意见，对讨论的前提提出质疑。”--百度 解决问题的基本思路是： 当一个人因为主观因素认为一件事是对的时候，第二个人沿着第一个人的思路也会产生相同的看法，以此类推直到第九个人也是产生同样的看法，说明那九个人都是沿着同一思路去看这个问题，第十个人就必须反对前面九人的看法，并尝试从反面来看待这个问题，以此来看这个思路存在的隐患，才能真正全面的考虑。 声明：本人是共产主义的坚定守护者，只是偶尔受到《僵尸世界大战 》这部电影，结合李文亮医生的舍己为人精神所写！ ","link":"https://Wangrongsheng.github.io/post/7ZoTM2JnW/"},{"title":"Tensorflow，CUDA，cuDNN 以及 Python 兼容版本对照表","content":" For Windows 10： Tensorflow Version Python Version cuDNN Version CUDA Version tensorflow_gpu-2.0.0 3.5-3.7 7.4 10 tensorflow_gpu-1.14.0 3.5-3.7 7.4 10 tensorflow_gpu-1.13.0 3.5-3.7 7.4 10 tensorflow_gpu-1.12.0 3.5-3.6 7 9 tensorflow_gpu-1.11.0 3.5-3.6 7 9 tensorflow_gpu-1.10.0 3.5-3.6 7 9 tensorflow_gpu-1.9.0 3.5-3.6 7 9 tensorflow_gpu-1.8.0 3.5-3.6 7 9 tensorflow_gpu-1.7.0 3.5-3.6 7 9 tensorflow_gpu-1.6.0 3.5-3.6 7 9 tensorflow_gpu-1.5.0 3.5-3.6 7 9 tensorflow_gpu-1.4.0 3.5-3.6 6 8 tensorflow_gpu-1.3.0 3.5-3.6 6 8 tensorflow_gpu-1.2.0 3.5-3.6 5.1 8 tensorflow_gpu-1.1.0 3.5 5.1 8 tensorflow_gpu-1.0.0 3.5 5.1 8 ","link":"https://Wangrongsheng.github.io/post/koNv1mB27/"},{"title":"博客嵌入可以自适应的b站视频","content":" 写博客的时候准备插入一个B站视频，发现B站点击分享会提供iframe 嵌入视频，直接复制代码。 &lt;iframe src=&quot;//player.bilibili.com/player.html?aid=80065350&amp;bvid=BV1GJ41147z7&amp;cid=137022787&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt; 添加到了博客里，然而它默认的样式只有很小的一块，还需要手动添加width 和height 属性，手动设置了固定的宽和高之后，显示正常，本以为大功告成。结果发下移动端边框超出。 于是参考网上资料，有直接修改主题样式的，使之外嵌一个class 样式，但是一直测试失败。尝试多次后，才找到合适的解决办法，使用也非常简单。 解决方法 &lt;iframe id=&quot;spkj&quot; src=&quot;https://player.bilibili.com/player.html?aid=80065350&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; width=100%&gt; &lt;/iframe&gt; &lt;script type=&quot;text/javascript&quot;&gt; document.getElementById(&quot;spkj&quot;).style.height=document.getElementById(&quot;spkj&quot;).scrollWidth*0.76+&quot;px&quot;; &lt;/script&gt; 使用方法 只需替换第一行中的数字ID44020824 即可，所以每次只需插入B站视频av/XXXXXX的数字即可。 演示 document.getElementById(\"spkj\").style.height=document.getElementById(\"spkj\").scrollWidth*0.76+\"px\"; ","link":"https://Wangrongsheng.github.io/post/0tY5nYPK2/"},{"title":"什么是区块链？","content":" 区块链 = 区块 + 链 区块 我们假设自己生活在一个村子里，在这个村子，没有实体货币的存在 ，一切交易靠大家记账： 比如，小明是一个卖肉的男孩，有一天老王找小明买了100块钱的肉，于是，老王和小明广播告诉大家老王账目-100 ，小明账目+100 ，这时候大家就会拿出自己的账本来记录上这一笔交易信息。 刚开始，我不明白为什么大家会记录老王 和 小明 的交易记录，后来，当我再看到没有实体货币存在 ，我们就应该明白，这个村子每一次的交易都应该被所有人记录，不然下一次的交易是无法完成，甚至是乱套的！ 举个例子，假设这次老王 和 小明 的交易未被其他人记录，那么下次消费，大家仍然觉得老王还有100块，老王仍然可以花费这100块，这是赤裸裸的犯罪啊！（偷钱消费）；小明明明拥有100块，却不被大家认可，成为了所谓的被害者~ 后来大家发现，随时都在记账是一件非常麻烦的事情，并且大部分的账目和自己无关，于是决定让村长暂时充当记账先生，此后该村子的任何交易都由记账先生（村长）记录，记账先生每天下午的时候都会清算今天的账目并且将这个账目公布出去，供大家检查有没有问题，如果大家公认今天的账目没有问题，就会拿出纸笔抄一份各自带回家，并且写上今天的日期保存起来，这样的话就免去了每个人都在无时无刻记账的麻烦。 按照这个逻辑，这个村子每天都会生成一个账本，例如：2.10日账本、2.11日账本、2.12日账本等等，因为每个账本都是独立存在的，所以每个账本都可以看作成一个区块 ： 2.10日账本-&gt;区块1 2.11日账本-&gt;区块2 2.12日账本-&gt;区块3 区块可以简单粗暴的理解为多条账目的打包，如果是一天公布一次账目，那么今天的所有账目就可以打包为一个区块 ，当然在这里区块的打包时间是可以改变的，比如十分钟打包一次或者指定时间打包一次，对应的就是十分钟生成一个区块...而链 就是将相邻的子帐本联系起来。 链 就这样，记账先生每天进行循环的记账、清算、公布。每天进行账目的公布之后，会出现一个期末余额 ：老王原有1000块，今日打工+150，买肉-100，买酒-20，那么他的期末余额为1030块。 由此，记账先生根据每个人的交易算出每个人的期末余额，到了第二天开始记账的时候，记账先生就会在账本的开端写下大家昨天的余额作为期初余额，今天的交易将会基于昨天的余额。因为昨天的账目和今天的账目是存在联系的，我们可以理解为通过结转余额的方式联系在了一起，而这个余额也自然而然的充当将两个账本连接在一起的链条，也就是类似区块链中的链。 共识机制 但是这个时候突然出现了一个问题，那就是记账先生一直在忙着记账，他的收入来自于哪里呢？没有收入就自然没有人想做记账先生，于是大家商议，每完成一次交易，都将给记账先生1块作为报酬，而这1块也是交易的手续费，目的是用来养活记账先生的。 如果每天该村子的交易数超过500，也就是记账先生每天的收入会达到500块，搬砖的老王对记账先生的收入眼红了，在这样之后，每个人都觉得记账先生的职位好，轻松还高新，大家都想做记账先生。于是大家想出了一种办法，通过抛硬币的方式来决定谁是今天的记账先生，大家觉得很合理，并最终达成共识。 通过抛硬币选举记账先生的方法可以理解为一个选举机制，因为大家是共识的，所以被称为共识机制。在区块链中，我们便是通过共识机制 选出记账者。 P2P的网络路由 现在又出现了一个新的问题，那就是有的人家距离公布账目的地方比较远，不是很方便都到公告栏去抄账目怎么办？ 这很简单，他可以抄邻居的账目，邻居又可以抄邻居的账目，因为可以互相借阅，也就解决了，大量村民一起挤在公告栏旁复制账目的问题。而邻居抄邻居本质上是用户对用户，点对点的信息传播，而用户之间又可以相互联系，最终连接在一起形成一个网络，而这个信息传递的方式也就是区块链的网络路由方式：用户对用户，每个人既是信息的接收者，也是信息的传播者。而在这个信息的传递过程中村子里的每个人都被称为一个节点。 去中心化（难以篡改） 如果现在有人想要篡改这个账本呢？难度其实是很大的，因为每个人的手里都有一个账本，如果想要改变账本数据就意味着需要将每个人手中的账本都改一遍。现实中，账本通过由少数人集中管理，很容易就会进行修改，但在这个村子，因为每个人都有一个每天同步的账本，而且每个人拿到的都一样，并且没有集中的现象，也就是去中心化 ,因此我们可以说在这个此村子，账本是分布式账本。 区块链特征 P2P网络路由； 分布式账本； 共识机制； 难以篡改； ","link":"https://Wangrongsheng.github.io/post/LOQxNbpjT/"},{"title":"搭建私有云cloudreve教程","content":" Cloudreve Cloudreve 能助您以最低的成本快速搭建公私兼备的网盘系统 官网：http://cloudreve.org/ 安装 1、下载安装包 http://cloudreve.org/download.php 2、下载好安装包，上传并解压到自己的网站根目录，这里极力推荐使用面板 ，我使用的是宝塔面板。解压之后原来的安装包就可以删除了。然后我们前往 您的域名/CloudreveInstaller 的安装向导，查看提示环境 如果出现PHP版本不匹配问题，修改PHP版本：宝塔更换PHP版本 ；配置一下URL规则：因为网盘框架是ThinkPHP 所以我们在网站设置里面选择ThinkPHP 的伪静态即可；如果php插件出现了错误我们就去宝塔点击软件商店找到自己选择的php版本点击后面的设置 →安装扩展 点击安装所需要的； 3、刷新安装网页，如果可以就继续下一步 ，如果不可以，请百度 4、填写数据库信息 5、然后点击开始安装 。会弹出一个界面提示信息：里面有你的后台地址 、默认用户名 、默认密码 （自己保存好，一会登录就行） 6、登录成功！ 演示 http://cloudreve.sqdxwz.com/ ","link":"https://Wangrongsheng.github.io/post/kcfk16DSF/"},{"title":"认识百度AI开发平台","content":" 服务平台 AI Studio 网址：https://aistudio.baidu.com/aistudio/index AI Studio 是基于百度深度学习平台飞桨的一站式AI开发平台，提供在线编程环境、免费GPU 算力、海量开源算法和开放数据，帮助开发者快速创建和部署模型。 EasyDL 网址：https://ai.baidu.com/easydl/ 零算法训练模型,无需机器学习专业知识，只需上传并标注需要识别的示例数据即可一键训练模型。EasyDL 是百度大脑推出的定制化AI训练及服务平台，支持面向各行各业有定制AI需求的企业用户及开发者使用。支持从数据管理与数据标注、模型训练、模型部署一站式AI开发流程，通过原始图片、文本、音频、视频类数据经过EasyDL 加工、学习、部署可发布为公有云API 、设备端SDK 、本地化部署及软硬一体产品。EasyDL 产品从目标客户及应用场景的角度分为经典版、专业版、零售版两个核心产品。 经典版面向零算法基础或者追求高效率开发AI的企业用户，现已支持图像分类、物体检测、图像分割、文本分类、视频分类、声音分类六类模型类型定制。 专业版面向AI初学者或AI专业工程师推出的AI模型训练与服务平台，目前支持视觉及自然语言处理两大技术方向，内置百度海量数据训练的预训练模型，可灵活脚本调参，只需少量数据可达到优模型效果。 零售版专门面向零售场景的ISV、零售行业服务商等企业用户提供【商品识别场景】的AI服务获取方案，支持面向货架巡检、自助结算台、无人零售柜等商品检测场景提供定制商品检测训练平台及标准商品检测API两类服务。 EasyEdge 网址：http://ai.baidu.com/easyedge/ 可基于多种深度学习框架、网络结构的模型，快捷生成端计算模型及封装SDK ，适配多种AI芯片与操作系统。基于Paddle Lite 研发的端计算模型生成平台，能够帮助深度学习开发者将自建模型快速部署到设备端。只需上传模型，最快2分种即可生成端计算模型并获取SDK 。 平台支持详情可参见下表： 上传模型支持框架：Caffe (ssd) 、PyTorch (1.4) 、TensorFlow (1.14) 、PaddlePaddle (1.6.2) 上传模型支持网络：VGG16 、InceptionV3/V4 、MobilenetV1 、MobilenetV1-SSD 、YoloV3 等20种 （2020.1.17 新增支持YoloV3 等网络、NNIE 芯片） AI芯片加速支持：通用ARM 芯片、通用x86芯片、英伟达GPU 、高通Snapdragon GPU/DSP 、英特尔Movidius VPU 、华为HiSilicon NPU 、华为海思NNIE 、苹果A-Bionic 工具 AutoDL AutoDL 的Github 链接：https://github.com/PaddlePaddle/AutoDL 一种高效的自动搜索构建最佳网络结构的方法，通过增强学习在不断训练过程中得到定制化高质量的模型。系统由两部分组成，第一部分是网络结构的编码器，第二部分是网络结构的评测器。编码器通常以 RNN 的方式把网络结构进行编码，然后评测器把编码的结果拿去进行训练和评测，拿到包括准确率、模型大小在内的一些指标，反馈给编码器，编码器进行修改，再次编码，如此迭代。经过若干次迭代以后，最终得到一个设计好的模型。 PaddleHub PaddleHub 的Github 链接：https://github.com/PaddlePaddle/PaddleHub 便捷地获取PaddlePaddle 生态下的预训练模型，完成模型的管理和一键预测。配合使用Fine-tune API ，可以基于大规模预训练模型快速完成迁移学习，让预训练模型能更好地服务于用户特定场景的应用。PaddleHub 提供的预训练模型涵盖了图像分类、目标检测、词法分析、语义模型、情感分析、视频分类、图像生成、图像分割、文本审核、关键点检测等主流模型。 PaddleHub 以预训练模型应用为核心具备以下特点： 模型即软件，通过Python API 或命令行实现模型调用，可快速体验或集成飞桨特色预训练模型。 易用的迁移学习，通过Fine-tune API ，内置多种优化策略，只需少量代码即可完成预训练模型的Fine-tuning 。 一键模型转服务，简单一行命令即可搭建属于自己的深度学习模型API服务完成部署。 自动超参优化，内置AutoDL Finetuner 能力，一键启动自动化超参搜索。 PARL PARL 的Github 链接：https://github.com/paddlepaddle/parl 一个高性能、灵活的强化学习框架。 他们提供主流强化学习算法实现，严格地复现了论文对应的指标。 大规模并行支持。框架最高可支持上万个CPU 的同时并发计算，并且支持多GPU 强化学习模型的训练。 可复用性强。用户无需自己重新实现算法，通过复用框架提供的算法可以轻松地把经典强化学习算法应用到具体的场景中。 良好扩展性。当用户想调研新的算法时，可以通过继承提供的基类可以快速实现自己的强化学习算法 ERNIE 持续学习语义理解框架艾尼（ERNIE ）利用百度海量数据和飞桨（PaddlePaddle ）多机多卡高效训练优势，通过深度神经网络与多任务学习等技术，持续学习海量数据和知识。基于该框架的艾尼（ERNIE ）预训练模型，已累计学习10亿多知识，助力各NLP任务显著提升。 PaddleX 网址：https://www.paddlepaddle.org.cn/paddle/paddleX 飞桨全流程开发客户端，集飞桨核心框架、模型库、工具及组件等深度学习开发全流程所需能力于一身，不仅为您提供一键安装的客户端，开源开放的技术内核更方便您根据实际生产需求进行直接调用或二次开发，是提升深度学习项目开发效率的最佳辅助工具。 将深度学习开发从数据接入、模型训练、参数调优、模型评估、预测部署全流程打通，并提供可视化的使用界面， 省去了对各环节间串连的代码开发与脚本调用，极大地提升了开发效率。 Paddle Lite Paddle Lite 的Github 链接：https://github.com/PaddlePaddle/Paddle-Lite 文档：https://paddle-lite.readthedocs.io/zh/latest/ FPGA 部署:https://paddle-lite.readthedocs.io/zh/latest/demo_guides/fpga.html Paddle Lite 致力于提供一套功能完整、易用、高性能的端侧推理引擎，方便广大开发者将应用部署到任何端侧设备之上。对比最初的 beta 版本，正式版在编译、文档、性能、硬件支持、平台支持等方面都有了较大的改进提升。核心用途是将训练出的模型在不同硬件平台场景下快速部署，根据输入数据，执行预测推理得到计算结果，支持实际的业务应用。 PaddleCV PaddleCV 的Github 链接：https://github.com/PaddlePaddle/models/tree/develop/PaddleCV 基于 PaddlePaddle 深度学习框架开发的智能视觉工具，算法，模型和数据的开源项目。百度在 CV 领域多年的深厚积淀为 PaddleCV 提供了强大的核心动力。PaddleCV集成了丰富的CV 模型，涵盖图像分类，目标检测，图像分割，视频分类，动作定位，目标跟踪，图像生成，文字识别，度量学习，关键点检测，3D视觉等 CV 技术。同时，PaddleCV 还提供了实用的工具，PLSC支持超大规模分类，PaddleSlim 和PaddleLite 支持工业级部署，以及 PaddleDetection 、PaddleSeg 面向产业的端到端开发套件，打通了模型开发、压缩、部署全流程。 ","link":"https://Wangrongsheng.github.io/post/FkhiaswhA/"},{"title":"Win10开启沙盒功能和使用","content":" 简介 什么是沙盒？ 在计算机安全领域，沙盒（英语：sandbox，又译为沙箱 ）是一种安全机制，为运行中的程序提供的隔离环境。通常是作为一些来源不可信、具破坏力或无法判定程序意图的程序提供实验之用。沙盒通常严格控制其中的程序所能访问的资源，比如，沙盒可以提供用后即回收的磁盘及内存空间。在沙盒中，网络访问、对真实系统的访问、对输入设备的读取通常被禁止或是严格限制。从这个角度来说，沙盒属于虚拟化 的一种。 沙盒中的所有改动对操作系统不会造成任何损失。通常，这种技术被计算机技术人员广泛用于测试可能带毒的程序或是其他的恶意代码。---------来自百度百科 相比虚拟机和第三方的沙盒软件，Windows Sandbox启用后仅占用100MB硬盘空间，还能与物理机安全地共享部分内存空间。简单来说就是易用、免费、不卡机！ 由于要保证沙盒内的数据不泄露并影响物理系统，所有文件读写都经过了重定向，所以沙盒虚拟化对存储性能影响较大，建议用固态。 注意：1.只有专业版和企业版系统支持沙盒；2.沙盒每次关闭都会自动清零； 开启沙盒 利用win10的搜索功能 -&gt; 直接搜索启用或关闭Windows功能 -&gt; 找到Windows沙盒，勾选它，然后点确定 -&gt; 重启电脑 使用沙盒 打开沙盒（在开始菜单中） 在开始菜单中找到Windows Sandbox ，打开。 使用沙盒 直接将要运行的程序，不确定安全性的程序复制粘贴进沙盒中运行就可以。 关闭后提示： ","link":"https://Wangrongsheng.github.io/post/5eRRX4YpI/"},{"title":"机器学习之线性代数","content":" 简介 我们主要学习与机器学习相关的线性代数知识，主要包括向量和矩阵的乘法、范数、求导等基本运算，及其在机器学习中的应用等内容。 线性代数是数学的一个分支。相信你在大学时，一定学习过这门课程，甚至可能会为通过考试而熬夜苦战。根据我的感受，线性代数这门课并不简单，但是比高等数学还是要容易一些。从机器学习的视角来看，线性代数是必须要了解的，但不需要达到精通的程度。为了不让线性代数成为学习机器学习的绊脚石，你需要掌握向量、矩阵的各种基础运算。值得一提的是，当你掌握线性代数的逻辑和套路时，线性代数就是纸老虎。 既然名字叫作线性代数，那么它一定是线性模型的前置基础知识。线性代数最基本的研究对象是向量，向量的向量又组成了矩阵。有了向量或者矩阵，就能将很多数字用一个向量符号表示，甚至可以将很多高维的数据用一个矩阵来表示。因此，你可以理解为线性代数是处理大数据的基础。 向量的基本运算 我们首先来学习向量的知识。在这里只需学习与机器学习有关的内容。我们在高中时就开始接触向量，它的基本运算并不会困扰我们。向量是一个有方向的量，它的表示形式是斜体加粗的小写字母或者斜体小写字母上加一个向右的箭头。别忘了，在上一课时计算函数的梯度时，梯度也是一个向量，表示的也是一个有方向的量，是函数值变化率最快的方向。 点乘 除了普通的加法以外，向量的另一个重要运算就是点乘了。点乘两个相同维数的向量，可以得到一个常数。点乘的计算方法是两个向量对应项乘积之和。例如，计算向量[1,1]和[-1,2]的点乘，计算过程就是 1*(-1)+1*2，结果等于 1。 矩阵的基本运算 接着我们来看一下矩阵。你应该是上了大学之后才开始接触矩阵的。矩阵可以形象的理解为是向量的向量，通常用加粗大写字母表示。在机器学习中，通常会用一个矩阵来表示一个大数据集。其中每一行是一个样本的不同维度，列方向则是集合中的每一条数据样本。例如如图所示的 3 名同学 3 门课的考试成绩。 用矩阵来表示每人每门课的成绩，则是 特别需要注意的是，当数据集中只有一条数据时，这个矩阵就退化为一个向量。因此，你也可以理解为，向量也是一个特殊的矩阵。 转置 矩阵有一个很重要的运算，就是转置。在矩阵右上角，用大写字母 T 表示。它能让矩阵的行列互换，原本 m x n 的矩阵就变成了 n x m 的新矩阵。 例如原本是 转置后变成了 转置在机器学习中有着非常重要的数学意义。你在学习机器学习时，也很可能会被各种各样的转置符号给弄晕。这是因为在机器学习中，关于向量和矩阵有着默认的规则。在机器学习中，默认所有的向量为列向量。当你必须要表示行向量时，则需要将向量转置。以前面 3 个同学的成绩为例。每个人 3 门课的成绩是个向量。根据列向量的准则，则有 总成绩是个矩阵，它是向量的向量，因此也需要满足列向量的准则。因此有： 此时就需要借助转置符号，变列为行来表示其中每个人的成绩。在这里，我们再次重申一遍，在整个机器学习中，默认所有的向量为列向量。 乘法 矩阵的乘法，在机器学习中被高频使用。我们举个例子来说明如何计算矩阵的乘法。如果有 则： 这里需要注意，矩阵的乘法对维数有严格要求。第一个矩阵的列数必须与第二个的行数相等。维数不匹配的矩阵不可以相乘。 哈达玛积 除了乘法以外，矩阵的基本运算还有哈达玛积。它要求两个矩阵的维数完全相同，计算方式是对应项元素的乘积。例如， 则其哈达玛积的结果为 求逆 关于矩阵，你还需要掌握求逆运算。求逆运算只可以作用在行数等于列数的方阵上，用右上角标 -1 来表示，可以得到一个矩阵的逆矩阵。逆矩阵满足这样的性质，它和原矩阵相乘后，可以得到单位矩阵，即主对角线元素为 1，其他元素为 0 的方阵。例如， 关于求逆，你不需要会各种手动计算的方法，能用 Python 的计算包或者 Matlab 求解就可以了。 线性代数与机器学习 范数 到现在为止的知识点，相信都还难不倒你。那么接下来的内容会渐渐开始有一些挑战。我们先看一下范数。范数可以对矩阵和向量去计算，它是泛函分析中的重要知识。但是从机器学习的视角来看，我们不需要掌握那么复杂的内容。在这里，我们只需要学习向量的 L1 范数和 L2 范数；其他更复杂的内容，如果你感兴趣，可以翻阅相关的数学书籍。 向量的 L1 范数计算方式是各个元素的绝对值之和。向量的 L2 范数计算方式是各个元素平方之和的平方根。例如， 则 也可以表示为 求导 对于矩阵、向量的求导，可能是本课时唯一的难点。这里的知识点，需要你在理解的基础上独立完成求导过程。在机器学习中，对于矩阵的求导用的会比较少，这个知识点并不是必须掌握的。而对于向量a关于向量b的求导，则必须掌握。原因在于机器学习的未知变量通常是模型的系数或系数组，而学习的标签是真实值向量。这个系数组和标签真实值，通常以向量的形式存在，例如线性回归、逻辑回归等模型。其他更复杂的求导，如果你感兴趣可以自己查阅相关资料。 接下来，看一下向量关于向量的求导。向量 y 关于向量 w 的求导结果是向量 y 中每个元素关于向量 w 中每个元素求导结果的矩阵。如果向量 w 的维数为 n x 1，向量 y 的维数是 m x 1，则求导之后的矩阵维数就是 n x m。特别需要注意，当 m=1 时，向量 y 是个常数，此时定义同样成立。 掌握了求导的定义之后，就可以利用它去求解导数啦。我们在这里把后续机器学习建模会用到的内容进行分析。首先看矩阵和向量的乘积结果。 这两个求导结果可以通过简单的推导得到。在此需要你记住求导过程。 总结 本课时，我们对线性代数的复习只是线性代数知识的冰山一角。但是这些知识，对我们突破机器学习已经足够了。我们先复习了矩阵和向量的基本运算，这些是为了讲述范数和求导作准备。当我们掌握了范数和求导法则之后，就具备了突破机器学习中线性代数的能力。 其中，范数的知识，是在机器学习中克服模型过拟合的重要手段。不管是L1还是L2，范数可被用作损失函数的惩罚项，也称作正则项，用来指导模型的学习训练。范数值越大，说明模型参数绝对值整体偏高，则说明模型的复杂度偏高。自然地，过拟合风险也就比较高。关于过拟合的知识，我会在后面专门拿出一个课时来讲解。另外，线性代数作用在线性模型居多。线性回归是回归的入门级算法。 对于线性回归模型的最优化过程，需要大量的向量求导计算。 如果不具备这些基础知识，你可能就会被一个非常简单的入门级算法困扰，这是非常划不来的事情。不过现在好了，这些必备的知识点你都已经突破了。其余线性代数的知识，如果你感兴趣，可以花时间去进行专门、系统地学习。如果你对数学比较抵触，掌握这些内容，已经足够你驰骋机器学习啦。 ","link":"https://Wangrongsheng.github.io/post/jiD0zk0jn/"},{"title":"用Numpy手写各种距离度量","content":" 用Numpy 实现常见的几种距离度量。 欧氏距离(Euclidean distance) def euclidean(x, y): return np.sqrt(np.sum((x - y)**2)) 曼哈顿距离(Manhattan distance) def manhattan(x, y): return np.sum(np.abs(x - y)) 切比雪夫距离(Chebyshev distance) def chebyshev(x, y): return np.max(np.abs(x - y)) 闵可夫斯基距离(Minkowski distance) def minkowski(x, y, p): return np.sum(np.abs(x - y) ** p) ** (1 / p) 汉明距离(Hamming distance) def hamming(x, y): return np.sum(x != y) / len(x) 马氏距离(Mahalanobis Distance) def mahalanobis(x,y): X=np.vstack([x,y]) XT=X.T SI = np.linalg.inv(np.cov(X)) #协方差矩阵的逆矩阵 #马氏距离计算两个样本之间的距离，此处共有10个样本，两两组合，共有45个距离。 n=XT.shape[0] d1=[] for i in range(0,n): for j in range(i+1,n): delta=XT[i]-XT[j] d=np.sqrt(np.dot(np.dot(delta,SI),delta.T)) d1.append(d) return d1 标准化欧氏距离 (Standardized Euclidean distance) def standardized-euclidean(x,y): return np.sqrt(((x - y) ** 2 /np.var(np.vstack([x,y]),axis=0,ddof=1)).sum()) 皮尔逊相关系数(Pearson correlation coefficient) def pearson(x,y): return np.corrcoef(x, y) 余弦相似度(Cosine similarity) def cos_sim(x, y): x = np.mat(x) y = np.mat(y) num = float(np.vstack([x,y]) * y.T) denom = np.linalg.norm(np.vstack([x,y])) * np.linalg.norm(y) cos = num / denom # 因为余弦值的范围是 [-1,+1] ，相似度计算时一般需要把值归一化到 [0,1] sim = 0.5 + 0.5 * cos return sim 杰卡德相似度(Jaccard index) def Jaccrad(x, y): up=np.double(np.bitwise_and((x != y),np.bitwise_or(x != 0, y != 0)).sum()) down=np.double(np.bitwise_or(x != 0, y != 0).sum()) d1=(up/down) return d1 ","link":"https://Wangrongsheng.github.io/post/YHbjyPZKl/"},{"title":"K-means","content":" K-均值算法概述 聚类与分类算法的最大区别在于, 分类的目标类别已知(监督学习), 而聚类的目标类别是未知的(无监督学习)。K-Means算法(K-均值算法)就是无监督算法之一，主要用于样本的聚类。其思想很简单，对于给定的样本集，按照样本与聚类中心之间的距离大小，将样本集划分为K个簇。让簇内的点尽量紧密的连接在一起,让簇间的距离尽量的大。 上图a表达了初始的数据集，假设k=2。在图b中，我们随机选择了两个k类所对应的类别质心，即图中的红色质心和蓝色质心，然后分别求样本中所有点到这两个质心的距离，并标记每个样本的类别为和该样本距离最小的质心的类别，如图c所示，经过计算样本和红色质心和蓝色质心的距离，我们得到了所有样本点的第一轮迭代后的类别。此时我们对我们当前标记为红色和蓝色的点分别求其新的质心，如图4所示，新的红色质心和蓝色质心的位置已经发生了变动。图e和图f重复了我们在图c和图d的过程，即将所有点的类别标记为距离最近的质心的类别并求新的质心。最终我们得到的两个类别如图f。 当然在实际K-Mean算法中，我们一般会多次运行图c和图d，才能达到最终的比较优的类别。 K-均值算法步骤 1）数据准备:需要数值型数据类计算距离, 也可以将标称型数据映射为二值型数据再用于距离计算。 2）对于未聚类数据集，首先随机初始化 K 个（代表拟聚类簇个数）中心点，如图红色五角星所示。 3）每一个样本按照距离自身最近的中心点进行聚类(计算距离)，等效于通过两中心点连线的中垂线划分区域。 4）依据上次聚类结果，移动中心点到个簇的质心位置(新的质心的位置为新簇内点的x和y分别的的平均值)，并将此质心作为新的中心点。 5）反复迭代，直至中心点的变化满足收敛条件（变化很小或几乎不变化），最终得到聚类结果。 距离计算 这里的距离指的是平面上两个点的直线距离。常用：欧氏距离 。 距离计算方法-聚类 K值选择 K-Means算法之K值的选择 传统K-means改进 在学习了传统K-means算法的基础上,我们清楚了K-means的局限性,因此我们将要说一下K-Means的优化变体方法。这其中包括初始化优化K-Means++, 距离计算优化elkan K-Means算法和大数据情况下的优化Mini Batch K-Means算法。 K-means++ 在学习K-means算法时我们提到，k个初始化的质心的位置选择对最后的聚类结果和运行时间都有很大的影响，因此需要选择合适的k个质心。如果仅仅是完全随机的选择，有可能导致算法收敛很慢。K-Means++算法就是对K-Means随机初始化质心的方法的优化。 elkan K-means 在传统的K-Means算法中，我们在每轮迭代时，要计算所有的样本点到所有的质心的距离，这样会比较的耗时。那么，对于距离的计算有没有能够简化的地方呢？elkan K-Means算法就是从这块入手加以改进。它的目标是减少不必要的距离的计算。 Mini Batch K-means 在统的K-Means算法中，要计算所有的样本点到所有的质心的距离。如果样本量非常大，比如达到10万以上，特征有100以上，此时用传统的K-Means算法非常的耗时，就算加上elkan K-Means优化也依旧。在大数据时代，这样的场景越来越多。此时Mini Batch K-Means应运而生。 顾名思义，Mini Batch，也就是用样本集中的一部分的样本来做传统的K-Means，这样可以避免样本量太大时的计算难题，算法收敛速度大大加快。当然此时的代价就是我们的聚类的精确度也会有一些降低。一般来说这个降低的幅度在可以接受的范围之内。 **注意:**此部分为扩展内容,如果你想真正的去优化你的算法,更详细的优化步骤你可以去刘建平Pinard-K-Means聚类算法原理 或者是聚类算法之K-Means及其变种 。 手推实现 下面给大家一个实例,供大家参考: 代码实现 import numpy import random import matplotlib.pyplot as plt def findCentroids(data_get, k): # 随机获取k个质心 return random.sample(data_get, k) def calculateDistance(vecA, vecB): # 计算向量vecA和向量vecB之间的欧氏距离 return numpy.sqrt(numpy.sum(numpy.square(vecA - vecB))) def minDistance(data_get, centroidList): # 计算data_get中的元素与centroidList中k个聚类中心的欧式距离，找出距离最小的 # 将该元素加入相应的聚类中 clusterDict = dict() # 用字典存储聚类结果 for element in data_get: vecA = numpy.array(element) # 转换成数组形式 flag = 0 # 元素分类标记，记录与相应聚类距离最近的那个类 minDis = float(&quot;inf&quot;) # 初始化为最大值 for i in range(len(centroidList)): vecB = numpy.array(centroidList[i]) distance = calculateDistance(vecA, vecB) # 两向量间的欧式距离 if distance &lt; minDis: minDis = distance flag = i # 保存与当前item距离最近的那个聚类的标记 if flag not in clusterDict.keys(): # 簇标记不存在，进行初始化 clusterDict[flag] = list() clusterDict[flag].append(element) # 加入相应的类中 return clusterDict # 返回新的聚类结果 def getCentroids(clusterDict): centroidList = list() for key in clusterDict.keys(): centroid = numpy.mean(numpy.array(clusterDict[key]), axis=0) # 求聚类中心即求解每列的均值 centroidList.append(centroid) return numpy.array(centroidList).tolist() def calculate_Var(clusterDict, centroidList): # 计算聚类间的均方误差 # 将类中各个向量与聚类中心的距离进行累加求和 sum = 0.0 for key in clusterDict.keys(): vecA = numpy.array(centroidList[key]) distance = 0.0 for item in clusterDict[key]: vecB = numpy.array(item) distance += calculateDistance(vecA, vecB) sum += distance return sum def showCluster(centroidList, clusterDict): # 画聚类结果 colorMark = ['or', 'ob', 'og', 'ok', 'oy', 'ow'] # 元素标记 centroidMark = ['dr', 'db', 'dg', 'dk', 'dy', 'dw'] # 聚类中心标记 for key in clusterDict.keys(): plt.plot(centroidList[key][0], centroidList[key][1], centroidMark[key], markersize=12) # 画聚类中心 for item in clusterDict[key]: plt.plot(item[0], item[1], colorMark[key]) # 画类下的点 plt.show() data = [[0.0, 0.0], [3.0, 8.0], [2.0, 2.0], [1.0, 1.0], [5.0, 3.0], [4.0, 8.0], [6.0, 3.0], [5.0, 4.0], [6.0, 4.0], [7.0, 5.0]] if __name__ == '__main__': centroidList = findCentroids(data, 3) # 随机获取3个聚类中心 clusterDict = minDistance(data, centroidList) # 第一次聚类迭代 newVar = calculate_Var(clusterDict, centroidList) # 计算均方误差值，通过新旧均方误差来获得迭代终止条件 oldVar = -0.0001 # 初始化均方误差 print('***** 第1次迭代 *****') for key in clusterDict.keys(): print('聚类中心: ', centroidList[key]) print('对应聚类: ',clusterDict[key]) print('平均均方误差: ', newVar) showCluster(centroidList, clusterDict) # 展示聚类结果 k = 2 while abs(newVar - oldVar) &gt;= 0.0001: # 当连续两次聚类结果差距小于0.0001时，迭代结束 centroidList = getCentroids(clusterDict) # 获得新的聚类中心 clusterDict = minDistance(data, centroidList) # 新的聚类结果 oldVar = newVar newVar = calculate_Var(clusterDict, centroidList) print('***** 第%d次迭代 *****' % k) for key in clusterDict.keys(): print('聚类中心: ', centroidList[key]) print('对应聚类: ', clusterDict[key]) print('平均均方误差: ', newVar) showCluster(centroidList, clusterDict) # 展示聚类结果 k += 1 结果展示 K-均值特点 优点: 属于无监督学习，无须准备训练集； 原理简单，实现起来较为容易； 结果可解释性较好。 缺点: 聚类数目k是一个输入参数。选择不恰当的k值可能会导致糟糕的聚类结果，这也是为什么要进行特征检查来决定数据集的聚类数目了； 可能收敛到局部最小值, 在大规模数据集上收敛较慢； 对于异常点、离群点敏感。 参考 http://home.deib.polimi.it/matteucc/Clustering/tutorial_html/index.html ","link":"https://Wangrongsheng.github.io/post/aYMnsCS39/"},{"title":"机器学习之概率论","content":" 简介 概率论研究的是事物的不确定性。它是大学数学课程之一，是统计学、信息论的前置课程。相对其他数学课而言，概率论的难度系数属中等，毕竟你在高中就学习过如何计算一个随机变量的期望、方差。从机器学习的视角来看，概率论是必须要了解的，但远不需要达到精通的程度。你只需要灵活运用它，去把机器学习世界的不确定性变量算清楚就足够了。因此，当你掌握概率论的窍门后，概率论就是纸老虎。 概率计算的两个原理 加法原理 我们先从计算某个事件的概率说起。概率是对事件发生可能性的刻画，概率越大事件发生的可能性越大。例如，中国国足与巴西国足将会在明天踢一场友谊赛。既有经验告诉我们，巴西国足实力较强，那么巴西队获胜的概率是比较高的。 这是个很简单的问题，然而当事件相对复杂时，计算概率就没那么容易了。对于复杂事件概率的计算方法，本讲介绍加法原理和乘法原理。 先看加法原理。一个事件的发生可能是多种分支路径的某一个，那么这个事件发生的概率就是全部可能分支的概率之和。 举个例子，假设你在和小明玩掷骰子比大小的游戏。某一局游戏，小明掷了4点，求这一局你获胜的概率是多少。你获胜是个事件，这个事件有两个可能的分支路径： 你掷了 6 点，6 大于 4，获胜； 你掷了 5 点，5 大于 4，获胜。 其他的分支就无法获胜了。根据加法原理，你最终获胜的概率就是 1/6 + 1/6，等于 1/3。 乘法原理 接着，我们再来看乘法原理。除了多个分支以外，一个事件的发生，还有可能是多个子事件联合发生的结果。此时最终这个事件发生的概率，就是所有子事件发生概率的乘积，这就是乘法原理。 假设你还在和小明玩掷骰子比大小的游戏。这次不同的是，求某一局游戏中，小明掷 4 点并且你最终获胜的概率是多少。此时要计算的事件，包含两个子事件： 小明掷 4 点； 小明掷 4 点后，你最终获胜。 分析发现，第一个子事件，小明掷4点的概率是1/6。第二个子事件和前面例子一样，概率为1/3。这样根据乘法原理，小明掷4点并且你最终获胜的概率就是1/6×1/3，等于1/18。 加法原理和乘法原理是概率计算的基础，它们可以解决绝大多数事件概率的计算。 极大似然估计原理 核心原理 学会了计算概率的意义是什么呢？其实，概率可以帮助我们决策某个未知的变量。举个例子。假设有两场足球赛在某地同时进行。对阵的双方分别是，巴西队对阵中国队，英国队对阵法国队。我们知道足球赛是户外运动，天气对比赛结果有着重要影响。在此，我们只考虑降水量对比赛结果的影响。 假设在降水量为x时，巴西队获胜的概率是1/(1+2x)，反之巴西队不胜的概率就是2x/(1+2x)；英国队获胜的概率为2x/(1+3x)，英国队不胜的概率为(1+x)/(1+3x)。假设这两场比赛进行时，你在外地出差。比赛结束后，你通过新闻发现结果为巴西胜、英国胜。那么根据乘法原理，你会发现巴西胜、英国胜的概率为 2x/[(1+2x)(1+3x)]。 接下来，你可能会思考，到底比赛那天降水量x这个变量是多少呢？如果我们加一个强约束，即让结果发生可能性最大的变量值，就是真实的值。那么问题就变为，x取值多少时，巴西胜且英国胜的概率2x/[(1+3x)(1+2x)] 能取得最大值。 通过第一讲偏导法或者梯度下降法，我们都能找到当 x= 1/√6 时，这个概率的最大值为 0.2020。所以，在我们没有其他信息输入时，有理由估计出降水量 x=1/√6 是最可信的结果。 用法 上面对降水量的估计，就是极大似然估计的核心原理。不知不觉中，我们已经使用它对未知事件降水量做了一次决策。我们先向它打个招呼。极大似然估计是根据结果，反过来估计过程中某个变量值的过程。因此，从流程上来说，极大似然估计分为两个步骤： 假设未知变量x已知，计算某个事件或组合事件发生的概率，得到一个关于 x 的似然函数 P(x)。 计算似然函数的最大值maxP(x)，并用取得最大值时的x*值，作为真实x的估计值。 机器学习中，极大似然估计在逻辑回归中被用作损失函数，它的用法就是首先假定模型参数已知，并建立样本的似然函数；再对似然函数求解最大值，推导出模型的参数值。关于逻辑回归，我们会在后面深入讲解。 熵 熵的含义 关于基础的概率论知识，我们掌握了极大似然估计就足够在机器学习的世界中呼风唤雨了。除此之外，我们再介绍一下概率论的延伸内容，这就是熵。从学科的边界来说，熵属于信息论的内容。然而，信息论又是以概率论为基础，所以在这门课我们把这两部分内容放在一讲中。刚刚接触熵时，你可能会很蒙，“熵“这个字就让人很困惑费解，生活中很少出现这个字眼。因此，先介绍一下熵的含义。 关于熵，你可以直观地理解为事件结果的不确定性，或者信息量，其单位为bit。举个例子，如果有人告诉你，1+1=2，你可能会说这是“废话“。原因就在于，这个事件的信息量太少、不确定性太低，换个信息论中的说法，就是 1+1=2 的熵太小。有了这个认知后，我们给出熵的计算方法。 熵的计算 熵描述的是个事件的不确定性，如果某个事件有 n 个结果，每个结果的概率为 pn。那么这个事件的熵 H(p) 的定义式为 我们看个例子。假设有这样的足球赛，对阵的双方是巴西队和中国队。假设巴西队获胜的概率为0.9，不胜的概率为0.1。那么这场比赛结果的熵就是，-0.9×log0.9-0.1×log0.1，等于 0.4690。 假设另一场焦点之战，对阵的双方是英国队与法国队。其中英国队获胜或不胜的概率都是0.5。此时比赛结果的熵就是，-0.5×log0.5-0.5×log0.5，等于1。后者的熵比前者大，可见结果的不确定更大，比赛结果的信息量就更大。 条件熵 熵是对事件结果不确定性的度量，但在某些条件下，这个不确定性会变小。例如，烟民大多是男性，女性吸烟者较少。因此，一个人是否吸烟这个事件的不确定性，会随着知道此人的性别而降低。此时，衡量的就是在某个条件 X 下，事件 Y 的不确定性，也叫做条件熵，记作 H(Y|X) 。其定义式为 理解为，X 事件每个可能性的结果的熵乘以发生概率的求和。 关于条件熵，再以足球赛的结果的胜负为例。假设中国队与巴西国足比赛。正常情况下，巴西队获胜的概率几乎为1。但最近巴西的气候不太好，球员有可能患病。假设患病的概率为0.5。而一旦球员患病，则巴西队获胜概率将降低为 0.5。计算比赛结果关于球员身体状况的条件熵。 假设Y为比赛结果，X为球员是否健康。根据定义式，你需要计算巴西球员患病后比赛结果的熵，和巴西球员健康比赛时结果的熵。分别为： H(患病)=-0.5×log0.5-0.5×log0.5=1 H(健康)=-1×log1-0×log0=0 因此，比赛结果关于球员是否患病的条件熵为 0.5×H(患病) + 0.5×H(健康)，结果为 0.5。 信息增益 思考一下熵和条件熵的关系。熵衡量的是事件的不确定性；条件熵衡量的是知道了某个条件后，事件的不确定性。不难发现，对于同一个事件，熵的值肯定是大于或等于条件熵的。原因在于，增加了某个条件后，肯定会辅助降低事件的不确定性，最不济也是让不确定性没有变化。因此，就有了信息增益的概念，写作 g(X,Y)。它的计算方式为熵减去条件熵，如下 继续以足球赛的结果为例。所有条件和前面一样。即正常情况下，巴西队获胜的概率几乎为1。但最近巴西气候不好，导致球员患病的概率为0.5。且一旦球员患病，则巴西队获胜概率将降低为0.5。根据加法原理和乘法原理，巴西队获胜的概率就是0.5×1 + 0.5×0.5，等于 0.75；则巴西队不胜的概率为 0.25。因此，比赛结果的熵为H(Y)=-0.75×log0.75-0.25×log0.25=0.81。 刚刚我们计算过条件熵，为 0.5。因此，球员是否患病对比赛结果的信息增益为 0.81-0.5，等于 0.31；信息增益比为 0.31/0.81，等于 38%。 基尼系数 最后，我们介绍基尼系数。与熵一样，基尼系数表征的也是事件的不确定性，它的计算方法，只需要把熵定义式中的“-logpi”替换为 1-pi 即可。也就是 基尼系数定义式可以做个小的变形，也就是 关于基尼系数，你只需要记住定义式，以及它是表征事件不确定性的另一种方式就够了。 总结 最后，我们对这一讲进行一个总结。按照顺序，这一讲先后学习了计算概率的两个原理，也就是加法原理和乘法原理。 掌握了如何计算概率后，我们学习了极大似然估计的知识。极大似然估计利用使某个结果发生可能性最大的参数值对未知变量进行估计。随后，我们将概率论的知识向信息论方面进行了一定的延伸，学习了描述事件不确定的熵、基尼系数，在某个条件下事件不确定的条件熵，以及这个条件对不确定性降低程度的信息增益和信息增益比。 这些知识只是概率论、信息论中的冰山一角。如果你以为这样就掌握了概率论、信息论，那就大错特错了。但是，有了这些知识，已经足够你在机器学习的世界中驰骋了。以经典模型为例，极大似然估计是逻辑回归计算模型参数的算法。熵、条件熵等内容，可被用作决策树建模时的损失函数。这些知识是掌握逻辑回归，ID3、C4.5、CART 等决策树模型的前置知识。 ","link":"https://Wangrongsheng.github.io/post/hS0QLkW6s/"},{"title":"机器学习之数学基础","content":" 简介 人工智能技术可以让机器帮助人类做出做好的决策 。这个决策是在某些限定条件下的取舍。 例如，小明在填写高考志愿时，需要在多所目标高校中选择最合适自己的那所。假设在这个过程中，小明的决策依据是学校综合实力和被录取可能性的求和。对于北大、北理工、北大青鸟，三所学校的综合实力排名是递减的关系；而对于小明而言，他被录取的可能性是递增的关系。因此，在决策志愿时，就需要综合考虑这两个因素，以保证自己的考学利益最大化。此时，这个问题就是一个最优化决策的数学问题。 这个例子非常简单，可能简单扫一眼，人们就能得到最优决策的结果。能够快速决策的一个重要原因是它的决策变量只有选择某个学校这一个。而对于更加复杂的最优化决策问题，假设其决策变量有成千上万个，而决策结果受这成千上万个变量的共同影响时，人们作出最优决策将会变得非常困难。此时就是人工智能发挥作用的重要场景。 不管是简单还是复杂的最优化决策，其本质都是个数学问题，它与求解一个函数的极大值或极小值非常相似。机器学习的很多初学者可能会对数学具有恐惧心理，但我想告诉大家，当你掌握数学背后的逻辑和套路后，数学就是纸老虎。 极值 假设有这样一个目标函数 y = f(x)，求解极值就是找到在某个定义域下求 y 的最大值或最小值。 例1 目标函数 y = sinx 在定义域 [0,2π] 的区间内，当 x 取值 π/2 时，y 可以达到最大值 1。 对于这样的极值求解问题，相信你一定并不陌生。原因在于高中数学的函数知识就是围绕着这些问题做文章的。高中数学告诉我们，极值的特点是导数为0 。因此，最常规的解法就是求解目标函数的一阶导数，令导数等于0，并求解这个方程。 例2 y=sinx的一阶导数y'=cosx。令导数为0，则cosx=0。在[0,2π]的定义域区间内，我们发现这个方程在x=π/2和3π/2时为 0。这分别对应着极大值和极小值。然后，分别把这两个极值点代入目标函数，你会发现，当 x = π/2 时，目标函数取得极大值 +1；当 x = 3π/2 时，目标函数取得极小值 -1。 例3 求解x1和x2分别为多少时？目标函数y=(x1-1)2+(x2-3)2可以取得最小值。 第二节 偏导数 此时，我们需要分别计算y关于x1和x2的偏导，并令这两个导函数为 0，求解这个方程组。根据计算你会得到两个方程，分别是 2(x1 - 1) = 0 和 2(x2 - 3) = 0。最终解得，当 x1 = 1、x2 = 3 时，函数取得最小值。 高中解法简单粗暴，适用于绝大多数的极值求解问题。然而，现实中常常会遇到方程求解复杂的情况，这就是高中数学解法的局限性 。 例4 求解x为多少时，目标函数是y=sinx+5x2+2可取得最小值。 那么，你在求解一阶导数后得到y'=cosx+10x并令其为0。到这里都没有问题，只是最后的方程求解过程可能会让你不知所措。面对这种情况，我推荐使用梯度下降法 来解决问题。 梯度下降 我们看一下函数的梯度的概念。关于函数的梯度，需要你记住以下 4 点。 梯度的计算方式是求解函数关于每个变量的一阶偏导； 梯度的标记为反三角 ▽； 梯度是个向量； 梯度表示函数变化率最大的方向。 例1 计算函数 y = (x1 - 1)2 + (x2 - 3)2 的梯度。 根据定义，求解函数关于每个变量的一阶偏导 分别计算 y 关于 x1 和 x2 的偏导，则有 我们发现梯度向量是个关于原函数自变量 x1 和 x2 的函数，毕竟函数的导数也是个函数。特别需要注意，我们对于某组自变量 x1 = 1、x2 = 2，则在这个点的梯度为 这就表示在对于点 (1,2)，方向 [0,-2] 是变化率最快的。 梯度的计算方式虽然很简单，但它对于求解极值的作用却非常大。我们以爬山到山顶为例。为了最快到达山顶，你一定会选择走海拔变化最快的路径。最终不断前进到达了山顶。这个山顶就是海拔的最大值。梯度下降法就是借鉴这个思想来求解极值的，它也是最优化问题中最常用的优化算法。 梯度的计算流程是这样的： 梯度下降法会随机初始化一组自变量。 计算目标函数在这个自变量上的梯度，并用梯度方向去更新自变量。通过不断循环执行第二步，最终得到极值。 这个流程形象来说，就是在山上随机初始化一个点，然后找到这个点的上山最快的方向并沿着这个方向前走一小步。通过重复多轮尝试找到最快的方向并走一小步，最终可以抵达山顶。通常更新自变量的过程会设置一个系数α，叫作学习率。那么更新的方程式就是 值得说明的是，如果求解的是极大值，那么学习率 α 大于 0；如果求解的是极小值，那么 α 为负。 例2 假设目标函数是y=sinx+5x2+2，求解这个函数的最小值。利用高中方法，你可能会卡在最后的方程求解上。现在我们利用梯度下降法来计算。因为求解极小值，所以设置学习率为-0.1。 首先随机初始化 x，假设为 0。此时目标函数为单变量函数，所以梯度是个单变量的向量。根据梯度定义，计算梯度为 cosx + 10x。 第1轮循环，0点的梯度值为1。根据公式更新结果为0-0.1×1=-0.1。 第2轮循环，计算-0.1处的梯度为-0.0050，更新结果为-0.1－0.1×(-0.0050)=-0.0995。 第3轮循环，计算-0.0995处的梯度已经约等于0了。因此，我们得到结果，在x=-0.0995时，函数一阶偏导为 0.00005 约等于 0，目标函数值取得极小值，为 1.95。 例3 利用梯度下降法，计算 y = (x1 - 1)2 + (x2 - 3)2 的极小值。 此时为多变量的目标函数，因此梯度是个向量，为 由于求解极小值，故设置学习率为负数 -0.4。 首先，随机初始化自变量，假设为 [0,0]。接着进入梯度下降的循环。 第1轮循环，计算[0,0]处的梯度值，为[-2,-6]；更新参数的结果为[0,0]-0.4×[-2,-6]=[0.8,2.4]。 第2轮循环，计算[0.8,2.4]处的梯度值，为[-0.4,-1.2]；更新参数的结果为[0.96,2.88]。 第3轮循环，计算[0.96,2.88]处的梯度值，为[-0.08,-0.24]；更新参数的结果为 [0.99,2.98]。 第4轮循环，计算 [0.96,2.88] 处的梯度值，为 [-0.02,-0.05]；更新参数的结果为 [1.0,3.0]。 后续继续循环，结果不再发生改变，得到目标函数的最小值。 梯度下降法是求解极值问题中，最常用、最经典的算法。也是机器学习中，逻辑回归、神经网络中常用的优化方法。 ","link":"https://Wangrongsheng.github.io/post/HOiLdlZ6T/"},{"title":"Python判断身份证是否输入正确","content":" 简介 从1999年10月1日起，全国实行公民身份证号码制度，居民身份证编号由原15位升至18位： 前6位为地址码； 第7位至14位为出生日期码，其中年份用4位数表示； 第15位至17位为顺序码； 第18位为校验码，主要是为了校验计算机输入公民身份证号码的前17位数字是否正确，其取值范围是0至10，当值等于10时，用罗马数字符X 表示。 校验码的计算方法 将前面的身份证号码17位数分别乘以不同的系数。从第1位到第17位的系数分别为：7－9－10－5－8－4－2－1－6－3－7－9－10－5－8－4－2。 将这17位数字和系数相乘的结果相加。 用加出来和除以11，看余数是多少？ 余数只可能有0－1－2－3－4－5－6－7－8－9－10这11个数字。其分别对应的最后一位身份证的号码为1－0－X－9－8－7－6－5－4－3－2。 通过上面得知如果余数是2，就会在身份证的第18位数字上出现罗马数字的Ⅹ。如果余数是10，身份证的最后一位号码就是2。 代码实现 lis = list(input('请输入身份证号码：')) ten = ['X', 'x', 'Ⅹ'] ID = [&quot;10&quot; if x in ten else x for x in lis] #将罗马数字Ⅹ和字母X替换为10 W = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2] Checkcode = [1, 0, 'X', 9, 8, 7, 6, 5, 4, 3, 2] sum = 0 for i in range(17): #https://blog.zeruns.tech sum = sum + int(ID[i]) * W[i] if Checkcode[sum % 11] == int(ID[17]): print('输入正确') else: print('输入错误') ","link":"https://Wangrongsheng.github.io/post/aUOkhjt9Q/"},{"title":"学生优惠权益","content":" 简介 每年高考过去，每个人都将迎来不同于以往的大学生活，大学或许对之前的12年管制式生活来说是解放了，不过每个人也知道的，解放后面是什么，脱离了父母和老师的管束以及适当的财务自主，你的生活并不会就无比精彩。 让自己的大学生活过得积极而精彩： 多参加校级、省级、国家级的比赛，你的比较对象就不会是同班同学了而是同龄人，视野更大。 多上台讲讲，第一次第二次第三次可能会小心脏砰砰跳，后面真的就见怪不怪了，会自信很多。 不要再默默无闻了，让老师们注意到你，都大学了上课还不敢举个手？ 做点义工，为社会做点贡献，工作了就真没时间了。 做人做事记得留个证据，留个发票，留个单子。 多向长辈们问候问候，偶尔放个长假了就去看看。 那么就期待着9月开启你的上当受骗之旅吧，不过可能在6月买电脑买手机的时候就已经上当受骗。（逃～） 学生包 各类学生优惠项目经过许多年的发展，很多学生包已经不单单只通过 edu 邮箱验证身份了，而且使用 @edu.cn 反而会降低申请成功率。 建议使用学生证、入学通知书等有学院官方标志和日期的工具来证明自己的身份。 Github 学生包，高质量的开发工具集合，并提供 DIgitalocean 的 50美元代金券，免费域名一枚。 Microsoft Imagine 学生包，免费使用微软的开发软件，包括 Windows Server 系统，以及 Azure 学生订阅。 AWS 学生包，亚马逊云计算的学生包，可以获得至少 $40 的优惠和教育培训。 Autodesk 学生包，旗下 AutoCAD , 3DMAX , Maya 等软件，其（教育版）免费试用期可延长至三年。 JetBrains 学生包，免费使用各类开发工具和集成工具。 G Suite for Education，为教育用户提供的谷歌生产力工具套件（大陆不在申请区之内）。 LINGO Educational Research License, LINGO 教育授权，著名线性与非线性求解器，求解优化模型的最佳选择，数学建模必备。 学生优惠 Office in Education，微软家提供的免费 Office 365 教育优惠，中国大多数学校无缘申请。 阿里云+云翼计划，118元/年，阿里云ECS+OSS+域名+机器学习API+Clouder认证。 24岁以下实名认证即可获得，无需验证学生身份!! 腾讯云+校园计划，10元一个月的云服务器租用，免费域名、云储存，需要抢购。 华为云+云创校园计划，9元/月 24岁及以下免学生认证，实名认证即可购买，需要抢购。 百度云启航校园计划，云服务器半年124元 苹果教育商店，苹果设备优惠，Music和 Pro APP 优惠，暑假还会有学生优惠大促销。 微软教育商店，9折购买微软旗下的各种硬件设备。 OnTheHub 教育商店，PD 和 VMware 的虚拟机优惠，以及更多软件优惠。 SiteGroud 学生计划，WP 官方推荐的主机托管商提供 $1.99/月 高性能 CP 托管。 Spotify 学生优惠，Spotify Premium学生订阅半价优惠。 Pantheon 学生版，专业高性能网站托管的学生优惠。 大疆教育优惠，大疆产品的教育折扣。 Todoist教育优惠，强大的任务、思路整理工具提供半价教育优惠。 SetAPP教育优惠，macOS 应用合集订阅包半价优惠，非常适合MAC学生党，每月4.99刀 Eagle教育优惠, Win/Mac系统，设计师图片管理工具，支持试用一个月，原价199，优惠价139，需提供身份和证件信息。优秀的本地图片管理工具，搭配学生版OneDrive进行同步管理，美滋滋。（目前已支持图片、视频、字体等类型文件的管理） 实用干货 CreativeMarket Free Goods，每周免费六款设计资源，电商、前端必备。 Axure， 原型设计工具，产品、运营必备，学生、教师免费。 Adobe XD，原型设计工具，没想到吧我Adobe也有免费的东西啦XD 官网直接提供免费版，奋起直追Mac的Sketch，Win党难得的福利。此外Adobe还提供对XD插件设计的奖励，可参与设计开发可供XD使用的插件。 Minecraft， 我的世界教育免费版 ，仅支持邮箱。 Mathematica， 现代科学计算软件，3折优惠 50刀，添加购物车后显示。 Tableau， 数据可视化分析软件，对学生、教室以及教育组织提供免费使用。 推荐软件 CloudConvert，转码神器，格式齐全的在线转码利器。 Smallpdf，专业文档转PDF，PDF转文档神器。 Canvas File Sync，Syncs Canvas-LMS课程文件 推荐阅读 少数派：在校师生福利：Apple、微软、Adobe 等产品如何通过教育优惠购买 少数派：学生专属福利，你可能还不知道这些常用服务其实可以更便宜 ","link":"https://Wangrongsheng.github.io/post/Ct8tl_5H2/"},{"title":"开启QQ邮箱日历提醒","content":" 简介 之前一直苦于因为家族每人生日的不同而总是遭到忽视，甚至自己的生日也会忘记，偶然发现 QQ 邮箱有日历的功能，而且可以设置农历并且每年邮件 + 短信 + 微信提醒 。 使用 1、打开自己的QQ邮箱 ，并且选择日历 ； 2、进入之后，点击右上角 的提醒 ； 3、添加需要提醒的事项； 4、再次点击到右上角 的设置 ； 5、选择性打开邮件、短信、微信提醒（建议重要的事情一定要都打开）； ","link":"https://Wangrongsheng.github.io/post/g1r0Q3OA9/"},{"title":"基于 Github 和 jsDelivr 的在线图床","content":" 简介 在之前我已经提到了使用 jsDelivr 和 Github 作为图床：jsDelivr ＋ Github ＝图床，但是在移动端使用的体验并不好，最近发现了两款可以在线提供服务的程序。 Picee Picee 原为支持 GitHub 图床的 Chrome Extension，经 tangkaichuan 修改，可以在线使用并使用 jsDelivr CDN。 项目地址：picee 演示站：https://guguga.cn/image 使用方法： Access token 在 Github 生成自己的 Token，步骤如下： Settings → Developer settings → Personal access tokens → Generate new token 勾选 write:packages ，生成 Token 。在生成的页面中复制 Token ，粘贴到 Access Token 中点击 Auth 即可食用。 Account &amp; Password 输入自己的 Github 帐号及密码即可使用。 配置相关信息： Repo 中填入 Username/Reponame ，Folder 中填入仓库路径（默认不填 ），然后打勾。在菜单中还有更多的自定义选项，可以自行探究~ auto PicCdn 搭建个人更为简洁的上传Github仓库图片 ","link":"https://Wangrongsheng.github.io/post/Uz5MOCN7i/"},{"title":"jsDelivr＋Github＝图床","content":" jsDelivr jsDelivr 是在中国大陆唯一有 license 的公有 CDN ，更多内容请移步官网：https://www.jsdelivr.com/ jsDelivr + Github Github 可以作为图片的存储桶，而 jsDelivr 可以对其进行全国的 CDN 加速（由网宿科技运营，速度还是很快的）。 Github 和 jsDelivr 都是大厂，不用担心跑路的问题，而且图片控制权在自己手里，不用担心被 ban。 测试图片如下： https://cdn.jsdelivr.net/gh/wangrongsheng/pic@master/avatar.jpg 图片上传到 Github 后得到的直链如下： https://cdn.jsdelivr.net/gh/username/Repository@master/file.jpg username 是 Github 的用户名 Repository 是相应的仓库名 master 是对应的分支（默认即为 master） file.jpg 是相应的图片（文件）名 jsDelivr + Github + PicGo GitHub+jsDelivr+PicGo搭建免费图床 ","link":"https://Wangrongsheng.github.io/post/RoBGEjnfs/"},{"title":"动态展示K-means","content":" 数据集及其源代码 下载 代码 import numpy as np import matplotlib import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation class KMeans(object): def __init__(self, data): ''' data: 要分类的数据，二维数组，每一行是一个样本，列数为样本特征数 ''' self.data = data self.calc_classes = np.frompyfunc( # 自定义ufunc，将所有样本分类 self.calc_distance, data.shape[1], 1) self.fig, self.ax = plt.subplots() def calc_distance(self, *features): ''' 计算单个样本与每个中心的距离，然后将其归于最近的一类 features: 样本的特征值 返回样本新的类别 ''' x = np.array(features) # 将样本的特征转换为一个向量 return np.argmin(np.square(self.center - x).sum(axis=1)) def clustering(self, k): ''' k: 要聚类的数量 ''' self.k = k self.sizes = np.linspace(40, 100, num=k) choices = np.random.randint(0, self.data.shape[0], size=k) self.center = np.copy(self.data[choices]) # 从data中随机选取k行作为随机中心 anim = FuncAnimation(self.fig, # 设置动画 func=self.update, # 回调函数，FuncAnimation会在每一帧都调用该函数 frames=np.arange(8), # 帧数 init_func=self.setup, # 动画初始化 interval=1000) # 每帧间隔 anim.save('clustering.gif', dpi=80, writer='pillow') def setup(self, colors=['r', 'g', 'b', 'k']): ''' 动画初始化函数 ''' cs = self.get_classified_sample() tmp = [] for i in np.arange(self.k): # 绘制已分类的样本 tmp.append(self.ax.scatter(cs[i][:,0], cs[i][:,1], c=colors[i], animated=True)) for i in np.arange(self.k): # 绘制中心 tmp.append(self.ax.scatter(self.center[i,0], self.center[i,1], c=colors[i], s=150, marker='x', animated=True)) self.sc = tuple(tmp) # 必须转换为元组 for i in np.arange(self.k): # 更新每个簇的中心 self.center[i,:] = cs[i].mean(axis=0) return self.sc # 返回必须是元组 def get_classified_sample(self): ''' 将所有样本分为k类 返回一个列表，列表中的每个元素是被归于同一类的样本 ''' cols = list(self.data.T) self.classes = self.calc_classes(*cols) # 计算所有样本的类别 return [self.data[self.classes==i] for i in np.arange(self.k)] def update(self, j): print(j) cs = self.get_classified_sample() for i in np.arange(self.k): self.sc[i].set_offsets(cs[i]) # 更新每个簇的点的坐标 self.sc[i]._sizes[0] = self.sizes[(i+j) % self.k] # 动态调增点的大小，增加视觉对比 self.sc[i+self.k].set_offsets(self.center[i]) # 更新每个簇中心的坐标 for i in np.arange(self.k): # 更新每个簇的中心 self.center[i,:] = cs[i].mean(axis=0) return self.sc # 返回必须是元组 if __name__ == &quot;__main__&quot;: data = np.loadtxt('./test.txt') km = KMeans(data) km.clustering(4) 动画展示 ","link":"https://Wangrongsheng.github.io/post/QxJ32Afq3/"},{"title":"KNN","content":" KNN算法概述 KNN可以说是最简单的分类算法之一，同时，它也是最常用的分类算法之一，注意KNN算法是有监督学习中的分类算法，它看起来和另一个机器学习算法K-means有点像（K-means是无监督学习算法），但却是有本质区别的。 KNN算法介绍 KNN的全称是K Nearest Neighbors，意思是K个最近的邻居，从这个名字我们就能看出一些KNN算法的蛛丝马迹了。K个最近邻居，毫无疑问，K的取值肯定是至关重要的。那么最近的邻居又是怎么回事呢？其实啊，KNN的原理就是当预测一个新的值x的时候，根据它距离最近的K个点是什么类别来判断x属于哪个类别 。 图中绿色的点就是我们要预测的那个点，假设K=3。那么KNN算法就会找到与它距离最近的三个点（这里用圆圈把它圈起来了），看看哪种类别多一些，比如这个例子中是蓝色三角形多一些，新来的绿色点就归类到蓝三角了。 但是，当K=5的时候，判定就变成不一样了 。这次变成红圆多一些，所以新来的绿点被归类成红圆。从这个例子中，我们就能看得出K的取值是很重要的。 明白了大概原理后，我们就来说一说细节的东西吧，主要有两个，K值的选取和点距离的计算 。 距离计算 要度量空间中点距离的话，有许多几种度量方式，比如常见的曼哈顿距离计算，欧式距离计算等等。不过通常KNN算法中使用的是欧式距离，这里只是简单说一下，拿二维平面为例，二维空间 两个点的欧式距离计算公式如下： 这个高中应该就有接触到的了，其实就是计算（x1,y1）和（x2,y2）的距离。拓展到多维空间，则公式变成这样： 这样我们就明白了如何计算距离，KNN算法最简单粗暴的就是将预测点与所有点距离进行计算，然后保存并排序，选出前面K个值看看哪些类别比较多。但其实也可以通过一些数据结构来辅助，比如最大堆，这里就不多做介绍，有兴趣可以百度最大堆相关数据结构的知识。 各种度量方式：https://blog.csdn.net/m0_37075274/article/details/90273692 K值选择 通过上面那张图我们知道K的取值比较重要，那么该如何确定K取多少值好呢？答案是通过交叉验证（将样本数据按照一定比例，拆分出训练用的数据和验证用的数据，比如6：4拆分出部分训练数据和验证数据），从选取一个较小的K值开始，不断增加K的值，然后计算验证集合的方差，最终找到一个比较合适的K值。 通过交叉验证计算方差后你大致会得到下面这样的图： 这个图其实很好理解，当你增大k的时候，一般错误率会先降低，因为有周围更多的样本可以借鉴了，分类效果会变好。但注意，和K-means不一样，当K值更大的时候，错误率会更高。这也很好理解，比如说你一共就35个样本，当你K增大到30的时候，KNN基本上就没意义了。 所以选择K点的时候可以选择一个较大的临界K点，当它继续增大或减小的时候，错误率都会上升，比如图中的K=10。 代码实现 python #引库 import numpy as np import matplotlib.pyplot as plt from math import sqrt %matplotlib inline #原始数据 data = [[1,0.9],[1,1],[0.1,0.2],[0,0.1]] labels = [&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;] test_data = [[0.1,0.3]] #绘制原始数据散点图 print(&quot;===============================数据准备================================&quot;) print(&quot;原始数据图像绘制...&quot;) for i in range(len(data)): plt.scatter(data[i][0],data[i][1],color = &quot;b&quot;) plt.scatter(test_data[0][0],test_data[0][1],color='r') plt.show() #测试数据x=(0.1,0.3) #采用欧式距离进行计算 print(&quot;===============================距离计算================================&quot;) x = [[0.1,0.3]] distance = [] labels_wz = [] for i in range(len(data)): d = 0 d = sqrt((x[0][0]-data[i][0])**2 + (x[0][1]-data[i][1])**2) distance.append(d) labels_wz.append(i) print(&quot;计算的距离为:\\n&quot;,distance) print(&quot;现在对应的标签位置为:\\n&quot;,labels_wz) #按照升序排序,并取距离较小的前3个 print(&quot;===============================距离排序================================&quot;) for i in range(len(data)-1): for j in range(i+1,len(data)): if distance[i] &gt; distance[j]: distance[i],distance[j] = distance[j],distance[i] labels_wz[i],labels_wz[j] = labels_wz[j],labels_wz[i] print(&quot;排序后的距离为:\\n&quot;,distance) print(&quot;对应的标签的位置为:\\n&quot;,labels_wz) print(&quot;取距离最近的3个值:&quot;,distance[0:3]) #进行投票表决 print(&quot;===============================表决投票================================&quot;) A = 0 B = 0 for i in range(len(labels_wz[0:3])): if labels[labels_wz[i]] == &quot;A&quot;: A+=1 else: B+=1 print(&quot;投票为A的数量为:&quot;,A) print(&quot;投票为B的数量为:&quot;,B) print(&quot;\\n对照初始图中红色点(测试点)与前两个标签为A的离的最近,所以我们的计算与图中所呈现的结果一致!&quot;) sklearn import numpy as np import sklearn from sklearn import datasets from sklearn.neighbors import KNeighborsClassifier X_train = np.array([[1,0.9],[1,1],[0.1,0.2],[0,0.1]]) #这里是数组形式哦，要注意哦，如果输入的dataframe（因为一般我们导入文件的话都是使用csv模式，导入进来一般是形成dataframe模式，我们需要在fit()函数中使用 X_train.values,y_train.values） y_train=['A','A','B','B'] knn=KNeighborsClassifier(n_neighbors=1) knn.fit(X_train,y_train) knn.predict([[0.1,0.3]])#要注意，预测的时候也要上使用数组形式的 KNN特点 优点 1）简单好用，容易理解，精度高，理论成熟，既可以用来做分类也可以用来做回归； 2）可用于数值型数据和离散型数据； 3）训练时间复杂度为O(n)；无数据输入假定； 4）对异常值不敏感。 缺点 1）计算复杂性高；空间复杂性高； 2）样本不平衡问题（即有些类别的样本数量很多，而其它样本的数量很少）； 3）一般数值很大的时候不用这个，计算量太大。但是单个样本又不能太少，否则容易发生误分； 4）最大的缺点是无法给出数据的内在含义。 至于什么时候应该选择使用KNN算法，sklearn的这张图给了我们一个答案： 英文不懂？？看中文： 简单的说，当需要使用分类算法且数据比较大的时候就可以尝试使用KNN算法进行分类了。 ","link":"https://Wangrongsheng.github.io/post/SiSIwI3rq/"},{"title":"修改Github仓库中项目语言类型","content":" 简介 众所周知，当我们使用Github 的时候，我们的项目语言很大程度上会影响别人的搜索和自己的强迫症被逼犯，那么我们是不是可以对我们的Github 项目的编程语言进行修改或者进行自主标明呢？ 修改 在Github 中，采用Linguist 来自动识别代码语言 。 我们要做的就是对linguist-language 进行赋值，强制它识别某一种语言文件为我们想要它显示的语言。 我们需要在仓库的根目录下添加.gitattributes文件:并写入 *.js linguist-language=python 这行代码的意思是：将文件中所有的.js 结尾的文件固定为python 语言。当然，我们也可以指定其它文件和其它语言。 显示的结果就更为： ","link":"https://Wangrongsheng.github.io/post/HeZrzoRYB/"},{"title":"基于Word+Github制作个人网站","content":" 简介 Word是一个文档软件？？？能写个静态网页你不晓得吧，哈哈~ 制作 1、新建一个文件夹，然后在里面新建一个word，取个名字叫 index ； 2、打开，点击右下角，Web版式视图，这样后面编辑内容即是网页看到的样子； 3、然后运用你Word技能做出一个个人网站即可； 4、另存为html格式 5、然后文件夹里出现了index.html 文件和index.files 文件夹，这个文件夹保存网页中的图片 部署 利用Github 的博客或者gh-pages 部署即可：利用gh-pages展示项目 如果上传后出现乱码，请在index.html 文件头部添加&lt;!DOCTYPE html&gt; ","link":"https://Wangrongsheng.github.io/post/72mXxz8BY/"},{"title":"利用百度地图绘制3D轨迹演示","content":" 简介 百度地图很强大，也为开发者提供很好的开发接口。今天用3D地图上路线轨迹可视化的小功能。 使用 第一步：申请ak ak申请介绍 创建的时候选择浏览器端~ 第二步：填写ak 有了 ak 后，复制下面的 hellomap.html 文件到 templates 文件夹里，并在hellomap.html 文件写入你申请的ak &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0, user-scalable=no&quot; /&gt; &lt;style type=&quot;text/css&quot;&gt; body, html,#allmap {width: 100%;height: 100%;overflow: hidden;margin:0;font-family:&quot;微软雅黑&quot;;} &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//api.map.baidu.com/api?type=webgl&amp;v=1.0&amp;ak=（此处填写申请的ak）&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//api.map.baidu.com/library/TrackAnimation/src/TrackAnimation_min.js&quot;&gt;&lt;/script&gt; &lt;title&gt;绘制轨迹&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;allmap&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;script type=&quot;text/javascript&quot;&gt; // GL版命名空间为BMapGL // 按住鼠标右键，修改倾斜角和角度 var bmap = new BMapGL.Map(&quot;allmap&quot;); // 创建Map实例 bmap.centerAndZoom(new BMapGL.Point(116.297611, 40.047363), 17); // 初始化地图,设置中心点坐标和地图级别 bmap.enableScrollWheelZoom(true); // 开启鼠标滚轮缩放 bmap.setTilt(50); // 设置地图初始倾斜角 var path = [{ 'lng': 116.297611, 'lat': 40.047363 }, { 'lng': 116.302839, 'lat': 40.048219 }, { 'lng': 116.308301, 'lat': 40.050566 }, { 'lng': 116.305732, 'lat': 40.054957 }, { 'lng': 116.304754, 'lat': 40.057953 }, { 'lng': 116.306487, 'lat': 40.058312 }, { 'lng': 116.307223, 'lat': 40.056379 }]; var point = []; for (var i = 0; i &lt; path.length; i++) { var poi = new BMapGL.Point(path[i].lng, path[i].lat); point.push(poi); var marker = new BMapGL.Marker(poi); //创建标注 bmap.addOverlay(marker); //将标注添加到地图中 } var pl = new BMapGL.Polyline(point,{strokeColor:&quot;blue&quot;, strokeWeight:6, strokeOpacity:0.5}); var trackAni = new BMapGLLib.TrackAnimation(bmap, pl, { overallView: true, // 动画完成后自动调整视野到总览 tilt: 30, // 轨迹播放的角度，默认为55 duration: 20000, // 动画持续时长，默认为10000，单位ms delay: 3000 // 动画开始的延迟，默认0，单位ms }); trackAni.start(); &lt;/script&gt; 第三步：Flask 部署 from flask import Flask from flask import render_template App = Flask(__name__) @App.route('/') def index(): return render_template('hellomap.html') if __name__ == &quot;__main__&quot;: App.run(debug=True) 拓展 如果你想要制作自己的轨迹地图，你就要获取你想要的经纬度，获取的方式为： 百度地图API -&gt; 坐标拾取工具 记录下来你的经纬度并且填入到hellomap.html 中就可以了~ 提示：hellomap.html 中的 'lng'代表经度；'lat'代表纬度~ 错误 因为采用Flask 框架部署网页，因此必须要有一定的规范，你的文件夹的格式应该遵循： . ├── test.py ├── templates └── hellomap.html ","link":"https://Wangrongsheng.github.io/post/4bYTuHx0A/"},{"title":"Matplotlib画图实用技巧","content":" 1. 添加标题-title import numpy as np import matplotlib.pyplot as plt # 显示中文 plt.rcParams['font.sans-serif'] = [u'SimHei'] plt.rcParams['axes.unicode_minus'] = False %matplotlib inline x=np.arange(0,10) plt.title('这是一个示例标题') plt.plot(x,x*x) plt.show() 2. 添加文字-text 设置坐标和文字即可 import numpy as np import matplotlib.pyplot as plt # 显示中文 plt.rcParams['font.sans-serif'] = [u'SimHei'] plt.rcParams['axes.unicode_minus'] = False %matplotlib inline x=np.arange(-10,11,1) y=x*x plt.plot(x,y) plt.title('这是一个示例标题') # 添加文字 plt.text(-2.5,30,'function y=x*x') plt.show() 3. 添加注释-annotate xy：为备注的坐标点 xytext：备注文字的坐标(默认为xy的位置) arrowprops：在xy和xytext之间绘制一个箭头 import numpy as np import matplotlib.pyplot as plt # 显示中文 plt.rcParams['font.sans-serif'] = [u'SimHei'] plt.rcParams['axes.unicode_minus'] = False %matplotlib inline x=np.arange(-10,11,1) y=x*x plt.title('这是一个示例标题') plt.plot(x,y) # 添加注释 plt.annotate('这是一个示例注释',xy=(0,1),xytext=(-2,22),arrowprops={'headwidth':10,'facecolor':'r'}) plt.show() 4. 设置坐标轴名称-xlabel/ylabel import numpy as np import matplotlib.pyplot as plt # 显示中文 plt.rcParams['font.sans-serif'] = [u'SimHei'] plt.rcParams['axes.unicode_minus'] = False %matplotlib inline x=np.arange(1,20) plt.xlabel('示例x轴') plt.ylabel('示例y轴') plt.plot(x,x*x) plt.show() 5. 添加图例-legend import numpy as np import matplotlib.pyplot as plt # 显示中文 plt.rcParams['font.sans-serif'] = [u'SimHei'] plt.rcParams['axes.unicode_minus'] = False %matplotlib inline plt.plot(x,x) plt.plot(x,x*2) plt.plot(x,x*3) plt.plot(x,x*4) # 直接传入legend plt.legend(['生活','颜值','工作','金钱']) plt.show() 6.调整颜色-color 传颜色参数，支持以下几种方式 import numpy as np import matplotlib.pyplot as plt %matplotlib inline x=np.arange(1,5) #颜色的几种方式 plt.plot(x,color='g') plt.plot(x+1,color='0.5') plt.plot(x+2,color='#FF00FF') plt.plot(x+3,color=(0.1,0.2,0.3)) plt.show() 7.切换线条样式-marker import numpy as np import matplotlib.pyplot as plt %matplotlib inline x=np.arange(1,5) plt.plot(x,marker='o') plt.plot(x+1,marker='&gt;') plt.plot(x+2,marker='s') plt.show() 8.显示数学公式-mathtext 格式如下： 作为开始和结束符，如\\omega $，中间的将解析出公式中的符号 import numpy as np import matplotlib.pyplot as plt %matplotlib inline plt.title('chenqionghe') plt.xlim([1,8]) plt.ylim([1,5]) plt.text(2,4,r'$ \\alpha \\beta \\pi \\lambda \\omega $',size=25) plt.text(4,4,r'$ \\sin(0)=\\cos(\\frac{\\pi}{2}) $',size=25) plt.text(2,2,r'$ \\lim_{x \\rightarrow y} \\frac{1}{x^3} $',size=25) plt.text(4,2,r'$ \\sqrt[4]{x}=\\sqrt{y} $',size=25) plt.show() 9. 显示网格-grid import numpy as np import matplotlib.pyplot as plt %matplotlib inline x='a','b','c','d' y=[15,30,45,10] plt.grid() # 也可以设置颜色、线条宽度、线条样式 # plt.grid(color='g',linewidth='1',linestyle='-.') plt.plot(x,y) plt.show() 10. 调整坐标轴刻度-locator_params 同时调整x轴和y轴：plt.locator_params(nbins=20)只调整x轴： plt.locator_params(‘'x',nbins=20)只调整y轴：plt.locator_params(‘'y',nbins=20) import numpy as np import matplotlib.pyplot as plt %matplotlib inline x=np.arange(0,30,1) plt.plot(x,x) # x轴和y轴分别显示20个 plt.locator_params(nbins=20) plt.show() 11. 调整坐标轴范围-axis/xlim/ylim axis：[0,5,0,10]，x从0到5，y从0到10 xlim：对应参数有xmin和xmax，分别能调整最大值最小值 ylim：同xlim用法 import numpy as np import matplotlib.pyplot as plt %matplotlib inline x=np.arange(0,30,1) plt.plot(x,x*x) #显示坐标轴，plt.axis(),4个数字分别代表x轴和y轴的最小坐标，最大坐标 #调整x为10到25 plt.xlim(xmin=10,xmax=25) plt.plot(x,x*x) plt.show() 12. 调整日期自适应-autofmt_xdate 有时候显示日期会重叠在一起，非常不友好，调用plt.gcf().autofmt_xdate()，将自动调整角度 import numpy as np import pandas as pd import matplotlib.pyplot as plt %matplotlib inline x=pd.date_range('2020/01/01',periods=30) y=np.arange(0,30,1) plt.plot(x,y) plt.gcf().autofmt_xdate() plt.show() 13. 添加双坐标轴-twinx import numpy as np import matplotlib.pyplot as plt %matplotlib inline x=np.arange(1,20) y1=x*x y2=np.log(x) plt.plot(x,y1) # 添加一个坐标轴，默认0到1 plt.twinx() plt.plot(x,y2,'r') plt.show() 14. 填充区域-fill/fill_beween fill填充函数区域 import numpy as np import matplotlib.pyplot as plt # 显示中文 plt.rcParams['font.sans-serif'] = [u'SimHei'] plt.rcParams['axes.unicode_minus'] = False %matplotlib inline x=np.linspace(0,5*np.pi,1000) y1=np.sin(x) y2=np.sin(2*x) plt.plot(x,y1) plt.plot(x,y2) # 填充 plt.fill(x,y1,'g') plt.fill(x,y2,'r') plt.title('这是一个示例标题') plt.show() fill_beween填充函数交叉区域 import numpy as np import matplotlib.pyplot as plt # 显示中文 plt.rcParams['font.sans-serif'] = [u'SimHei'] plt.rcParams['axes.unicode_minus'] = False %matplotlib inline plt.title('这是一个示例标题') x=np.linspace(0,5*np.pi,1000) y1=np.sin(x) y2=np.sin(2*x) plt.plot(x,y1) plt.plot(x,y2) # 填充 plt.fill_between(x,y1,y2,where=y1&gt;y2,interpolate=True) plt.show() 15. 画一个填充好的形状-matplotlib.patche import numpy as np import matplotlib.pyplot as plt import matplotlib.patches as mptaches %matplotlib inline xy1=np.array([0.2,0.2]) xy2=np.array([0.2,0.8]) xy3=np.array([0.8,0.2]) xy4=np.array([0.8,0.8]) fig,ax=plt.subplots() #圆形,指定坐标和半径 circle=mptaches.Circle(xy1,0.15) ax.add_patch(circle) #长方形 rect=mptaches.Rectangle(xy2,0.2,0.1,color='r') ax.add_patch(rect) #多边形 polygon=mptaches.RegularPolygon(xy3,6,0.1,color='g') ax.add_patch(polygon) # 椭圆 ellipse=mptaches.Ellipse(xy4,0.4,0.2,color='c') ax.add_patch(ellipse) ax.axis('equal') plt.show() 16.切换样式-plt.style.use matplotlib支持多种样式，可以通过plt.style.use切换样式，例如：plt.style.use('ggplot')输入 plt.style.available 可以查看所有的样式: import matplotlib.pyplot as plt plt.style.available ['bmh', 'classic', 'dark_background', 'fast', 'fivethirtyeight', 'ggplot', 'grayscale', 'seaborn-bright', 'seaborn-colorblind', 'seaborn-dark-palette', 'seaborn-dark', 'seaborn-darkgrid', 'seaborn-deep', 'seaborn-muted', 'seaborn-notebook', 'seaborn-paper', 'seaborn-pastel', 'seaborn-poster', 'seaborn-talk', 'seaborn-ticks', 'seaborn-white', 'seaborn-whitegrid', 'seaborn', 'Solarize_Light2', 'tableau-colorblind10', '_classic_test'] import numpy as np import matplotlib.pyplot as plt import matplotlib.patches as mptaches %matplotlib inline plt.style.use('ggplot') # 新建4个子图 fig,axes=plt.subplots(2,2) ax1,ax2,ax3,ax4=axes.ravel() # 第一个图 x,y=np.random.normal(size=(2,100)) ax1.plot(x,y,'o') # 第二个图 x=np.arange(0,10) y=np.arange(0,10) colors=plt.rcParams['axes.prop_cycle'] length=np.linspace(0,10,len(colors)) for s in length: ax2.plot(x,y+s,'-') # 第三个图 x=np.arange(5) y1,y2,y3=np.random.randint(1,25,size=(3,5)) width=0.25 ax3.bar(x,y1,width) ax3.bar(x+width,y2,width) ax3.bar(x+2*width,y3,width) # 第四个图 for i,color in enumerate(colors): xy=np.random.normal(size=2) ax4.add_patch(plt.Circle(xy,radius=0.3,color=color['color'])) ax4.axis('equal') plt.show() ","link":"https://Wangrongsheng.github.io/post/pL-BHw_Pp/"},{"title":"如何写好一个Github项目文档","content":"一、什么是Github？ Github是通过Git进行版本控制的软件源代码托管服务平台。 Github除了Git代码仓库托管及基本的Web管理界面以外，它还提供了一些方便社会化共同软件开发的功能，即一般人口中的社群功能，包括允许用户追踪其他用户、组织、软件库的动态，对软件代码的改动和bug提出评论等。 作为一个优秀的学习者，我们摆脱不掉Github ，更为重要的是，我们不仅要学习使用别人的代码，更要向这个美好的网站贡献我们的开源精神，那么，我们如何更好的写一份项目文档呢？ 二、写好项目文档 1、使用Markdown语法 Markdown基础语法 2、使用Emoji表情 People :bowtie: :bowtie: 😄 :smile: 😆 :laughing: 😊 :blush: 😃 :smiley: ☺️ :relaxed: 😏 :smirk: 😍 :heart_eyes: 😘 :kissing_heart: 😚 :kissing_closed_eyes: 😳 :flushed: 😌 :relieved: 😆 :satisfied: 😁 :grin: 😉 :wink: 😜 :stuck_out_tongue_winking_eye: 😝 :stuck_out_tongue_closed_eyes: 😀 :grinning: 😗 :kissing: 😙 :kissing_smiling_eyes: 😛 :stuck_out_tongue: 😴 :sleeping: 😟 :worried: 😦 :frowning: 😧 :anguished: 😮 :open_mouth: 😬 :grimacing: 😕 :confused: 😯 :hushed: 😑 :expressionless: 😒 :unamused: 😅 :sweat_smile: 😓 :sweat: 😥 :disappointed_relieved: 😩 :weary: 😔 :pensive: 😞 :disappointed: 😖 :confounded: 😨 :fearful: 😰 :cold_sweat: 😣 :persevere: 😢 :cry: 😭 :sob: 😂 :joy: 😲 :astonished: 😱 :scream: :neckbeard: :neckbeard: 😫 :tired_face: 😠 :angry: 😡 :rage: 😤 :triumph: 😪 :sleepy: 😋 :yum: 😷 :mask: 😎 :sunglasses: 😵 :dizzy_face: 👿 :imp: 😈 :smiling_imp: 😐 :neutral_face: 😶 :no_mouth: 😇 :innocent: 👽 :alien: 💛 :yellow_heart: 💙 :blue_heart: 💜 :purple_heart: ❤️ :heart: 💚 :green_heart: 💔 :broken_heart: 💓 :heartbeat: 💗 :heartpulse: 💕 :two_hearts: 💞 :revolving_hearts: 💘 :cupid: 💖 :sparkling_heart: ✨ :sparkles: ⭐️ :star: 🌟 :star2: 💫 :dizzy: 💥 :boom: 💥 :collision: 💢 :anger: ❗️ :exclamation: ❓ :question: ❕ :grey_exclamation: ❔ :grey_question: 💤 :zzz: 💨 :dash: 💦 :sweat_drops: 🎶 :notes: 🎵 :musical_note: 🔥 :fire: 💩 :hankey: 💩 :poop: 💩 :shit: 👍 :+1: 👍 :thumbsup: 👎 :-1: 👎 :thumbsdown: 👌 :ok_hand: 👊 :punch: 👊 :facepunch: ✊ :fist: ✌️ :v: 👋 :wave: ✋ :hand: ✋ :raised_hand: 👐 :open_hands: ☝️ :point_up: 👇 :point_down: 👈 :point_left: 👉 :point_right: 🙌 :raised_hands: 🙏 :pray: 👆 :point_up_2: 👏 :clap: 💪 :muscle: 🤘 :metal: 🖕 :fu: 🚶 :walking: 🏃 :runner: 🏃 :running: 👫 :couple: 👪 :family: 👬 :two_men_holding_hands: 👭 :two_women_holding_hands: 💃 :dancer: 👯 :dancers: 🙆 :ok_woman: 🙅 :no_good: 💁 :information_desk_person: 🙋 :raising_hand: 👰 :bride_with_veil: 🙎 :person_with_pouting_face: 🙍 :person_frowning: 🙇 :bow: :couplekiss: :couplekiss: 💑 :couple_with_heart: 💆 :massage: 💇 :haircut: 💅 :nail_care: 👦 :boy: 👧 :girl: 👩 :woman: 👨 :man: 👶 :baby: 👵 :older_woman: 👴 :older_man: 👱 :person_with_blond_hair: 👲 :man_with_gua_pi_mao: 👳 :man_with_turban: 👷 :construction_worker: 👮 :cop: 👼 :angel: 👸 :princess: 😺 :smiley_cat: 😸 :smile_cat: 😻 :heart_eyes_cat: 😽 :kissing_cat: 😼 :smirk_cat: 🙀 :scream_cat: 😿 :crying_cat_face: 😹 :joy_cat: 😾 :pouting_cat: 👹 :japanese_ogre: 👺 :japanese_goblin: 🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil: 💂 :guardsman: 💀 :skull: 🐾 :feet: 👄 :lips: 💋 :kiss: 💧 :droplet: 👂 :ear: 👀 :eyes: 👃 :nose: 👅 :tongue: 💌 :love_letter: 👤 :bust_in_silhouette: 👥 :busts_in_silhouette: 💬 :speech_balloon: 💭 :thought_balloon: :feelsgood: :feelsgood: :finnadie: :finnadie: :goberserk: :goberserk: :godmode: :godmode: :hurtrealbad: :hurtrealbad: :rage1: :rage1: :rage2: :rage2: :rage3: :rage3: :rage4: :rage4: :suspect: :suspect: :trollface: :trollface: Nature ☀️ :sunny: ☔️ :umbrella: ☁️ :cloud: ❄️ :snowflake: ⛄️ :snowman: ⚡️ :zap: 🌀 :cyclone: 🌁 :foggy: 🌊 :ocean: 🐱 :cat: 🐶 :dog: 🐭 :mouse: 🐹 :hamster: 🐰 :rabbit: 🐺 :wolf: 🐸 :frog: 🐯 :tiger: 🐨 :koala: 🐻 :bear: 🐷 :pig: 🐽 :pig_nose: 🐮 :cow: 🐗 :boar: 🐵 :monkey_face: 🐒 :monkey: 🐴 :horse: 🐎 :racehorse: 🐫 :camel: 🐑 :sheep: 🐘 :elephant: 🐼 :panda_face: 🐍 :snake: 🐦 :bird: 🐤 :baby_chick: 🐥 :hatched_chick: 🐣 :hatching_chick: 🐔 :chicken: 🐧 :penguin: 🐢 :turtle: 🐛 :bug: 🐝 :honeybee: 🐜 :ant: 🐞 :beetle: 🐌 :snail: 🐙 :octopus: 🐠 :tropical_fish: 🐟 :fish: 🐳 :whale: 🐋 :whale2: 🐬 :dolphin: 🐄 :cow2: 🐏 :ram: 🐀 :rat: 🐃 :water_buffalo: 🐅 :tiger2: 🐇 :rabbit2: 🐉 :dragon: 🐐 :goat: 🐓 :rooster: 🐕 :dog2: 🐖 :pig2: 🐁 :mouse2: 🐂 :ox: 🐲 :dragon_face: 🐡 :blowfish: 🐊 :crocodile: 🐪 :dromedary_camel: 🐆 :leopard: 🐈 :cat2: 🐩 :poodle: 🐾 :paw_prints: 💐 :bouquet: 🌸 :cherry_blossom: 🌷 :tulip: 🍀 :four_leaf_clover: 🌹 :rose: 🌻 :sunflower: 🌺 :hibiscus: 🍁 :maple_leaf: 🍃 :leaves: 🍂 :fallen_leaf: 🌿 :herb: 🍄 :mushroom: 🌵 :cactus: 🌴 :palm_tree: 🌲 :evergreen_tree: 🌳 :deciduous_tree: 🌰 :chestnut: 🌱 :seedling: 🌼 :blossom: 🌾 :ear_of_rice: 🐚 :shell: 🌐 :globe_with_meridians: 🌞 :sun_with_face: 🌝 :full_moon_with_face: 🌚 :new_moon_with_face: 🌑 :new_moon: 🌒 :waxing_crescent_moon: 🌓 :first_quarter_moon: 🌔 :waxing_gibbous_moon: 🌕 :full_moon: 🌖 :waning_gibbous_moon: 🌗 :last_quarter_moon: 🌘 :waning_crescent_moon: 🌜 :last_quarter_moon_with_face: 🌛 :first_quarter_moon_with_face: 🌔 :moon: 🌍 :earth_africa: 🌎 :earth_americas: 🌏 :earth_asia: 🌋 :volcano: 🌌 :milky_way: ⛅️ :partly_sunny: :octocat: :octocat: :squirrel: :squirrel: Objects 🎍 :bamboo: 💝 :gift_heart: 🎎 :dolls: 🎒 :school_satchel: 🎓 :mortar_board: 🎏 :flags: 🎆 :fireworks: 🎇 :sparkler: 🎐 :wind_chime: 🎑 :rice_scene: 🎃 :jack_o_lantern: 👻 :ghost: 🎅 :santa: 🎄 :christmas_tree: 🎁 :gift: 🔔 :bell: 🔕 :no_bell: 🎋 :tanabata_tree: 🎉 :tada: 🎊 :confetti_ball: 🎈 :balloon: 🔮 :crystal_ball: 💿 :cd: 📀 :dvd: 💾 :floppy_disk: 📷 :camera: 📹 :video_camera: 🎥 :movie_camera: 💻 :computer: 📺 :tv: 📱 :iphone: ☎️ :phone: ☎️ :telephone: 📞 :telephone_receiver: 📟 :pager: 📠 :fax: 💽 :minidisc: 📼 :vhs: 🔉 :sound: 🔈 :speaker: 🔇 :mute: 📢 :loudspeaker: 📣 :mega: ⌛️ :hourglass: ⏳ :hourglass_flowing_sand: ⏰ :alarm_clock: ⌚️ :watch: 📻 :radio: 📡 :satellite: ➿ :loop: 🔍 :mag: 🔎 :mag_right: 🔓 :unlock: 🔒 :lock: 🔏 :lock_with_ink_pen: 🔐 :closed_lock_with_key: 🔑 :key: 💡 :bulb: 🔦 :flashlight: 🔆 :high_brightness: 🔅 :low_brightness: 🔌 :electric_plug: 🔋 :battery: 📲 :calling: ✉️ :email: 📫 :mailbox: 📮 :postbox: 🛀 :bath: 🛁 :bathtub: 🚿 :shower: 🚽 :toilet: 🔧 :wrench: 🔩 :nut_and_bolt: 🔨 :hammer: 💺 :seat: 💰 :moneybag: 💴 :yen: 💵 :dollar: 💷 :pound: 💶 :euro: 💳 :credit_card: 💸 :money_with_wings: 📧 :e-mail: 📥 :inbox_tray: 📤 :outbox_tray: ✉️ :envelope: 📨 :incoming_envelope: 📯 :postal_horn: 📪 :mailbox_closed: 📬 :mailbox_with_mail: 📭 :mailbox_with_no_mail: 🚪 :door: 🚬 :smoking: 💣 :bomb: 🔫 :gun: 🔪 :hocho: 💊 :pill: 💉 :syringe: 📄 :page_facing_up: 📃 :page_with_curl: 📑 :bookmark_tabs: 📊 :bar_chart: 📈 :chart_with_upwards_trend: 📉 :chart_with_downwards_trend: 📜 :scroll: 📋 :clipboard: 📆 :calendar: 📅 :date: 📇 :card_index: 📁 :file_folder: 📂 :open_file_folder: ✂️ :scissors: 📌 :pushpin: 📎 :paperclip: ✒️ :black_nib: ✏️ :pencil2: 📏 :straight_ruler: 📐 :triangular_ruler: 📕 :closed_book: 📗 :green_book: 📘 :blue_book: 📙 :orange_book: 📓 :notebook: 📔 :notebook_with_decorative_cover: 📒 :ledger: 📚 :books: 🔖 :bookmark: 📛 :name_badge: 🔬 :microscope: 🔭 :telescope: 📰 :newspaper: 🏈 :football: 🏀 :basketball: ⚽️ :soccer: ⚾️ :baseball: 🎾 :tennis: 🎱 :8ball: 🏉 :rugby_football: 🎳 :bowling: ⛳️ :golf: 🚵 :mountain_bicyclist: 🚴 :bicyclist: 🏇 :horse_racing: 🏂 :snowboarder: 🏊 :swimmer: 🏄 :surfer: 🎿 :ski: ♠️ :spades: ♥️ :hearts: ♣️ :clubs: ♦️ :diamonds: 💎 :gem: 💍 :ring: 🏆 :trophy: 🎼 :musical_score: 🎹 :musical_keyboard: 🎻 :violin: 👾 :space_invader: 🎮 :video_game: 🃏 :black_joker: 🎴 :flower_playing_cards: 🎲 :game_die: 🎯 :dart: 🀄️ :mahjong: 🎬 :clapper: 📝 :memo: 📝 :pencil: 📖 :book: 🎨 :art: 🎤 :microphone: 🎧 :headphones: 🎺 :trumpet: 🎷 :saxophone: 🎸 :guitar: 👞 :shoe: 👡 :sandal: 👠 :high_heel: 💄 :lipstick: 👢 :boot: 👕 :shirt: 👕 :tshirt: 👔 :necktie: 👚 :womans_clothes: 👗 :dress: 🎽 :running_shirt_with_sash: 👖 :jeans: 👘 :kimono: 👙 :bikini: 🎀 :ribbon: 🎩 :tophat: 👑 :crown: 👒 :womans_hat: 👞 :mans_shoe: 🌂 :closed_umbrella: 💼 :briefcase: 👜 :handbag: 👝 :pouch: 👛 :purse: 👓 :eyeglasses: 🎣 :fishing_pole_and_fish: ☕️ :coffee: 🍵 :tea: 🍶 :sake: 🍼 :baby_bottle: 🍺 :beer: 🍻 :beers: 🍸 :cocktail: 🍹 :tropical_drink: 🍷 :wine_glass: 🍴 :fork_and_knife: 🍕 :pizza: 🍔 :hamburger: 🍟 :fries: 🍗 :poultry_leg: 🍖 :meat_on_bone: 🍝 :spaghetti: 🍛 :curry: 🍤 :fried_shrimp: 🍱 :bento: 🍣 :sushi: 🍥 :fish_cake: 🍙 :rice_ball: 🍘 :rice_cracker: 🍚 :rice: 🍜 :ramen: 🍲 :stew: 🍢 :oden: 🍡 :dango: 🥚 :egg: 🍞 :bread: 🍩 :doughnut: 🍮 :custard: 🍦 :icecream: 🍨 :ice_cream: 🍧 :shaved_ice: 🎂 :birthday: 🍰 :cake: 🍪 :cookie: 🍫 :chocolate_bar: 🍬 :candy: 🍭 :lollipop: 🍯 :honey_pot: 🍎 :apple: 🍏 :green_apple: 🍊 :tangerine: 🍋 :lemon: 🍒 :cherries: 🍇 :grapes: 🍉 :watermelon: 🍓 :strawberry: 🍑 :peach: 🍈 :melon: 🍌 :banana: 🍐 :pear: 🍍 :pineapple: 🍠 :sweet_potato: 🍆 :eggplant: 🍅 :tomato: 🌽 :corn: Places 🏠 :house: 🏡 :house_with_garden: 🏫 :school: 🏢 :office: 🏣 :post_office: 🏥 :hospital: 🏦 :bank: 🏪 :convenience_store: 🏩 :love_hotel: 🏨 :hotel: 💒 :wedding: ⛪️ :church: 🏬 :department_store: 🏤 :european_post_office: 🌇 :city_sunrise: 🌆 :city_sunset: 🏯 :japanese_castle: 🏰 :european_castle: ⛺️ :tent: 🏭 :factory: 🗼 :tokyo_tower: 🗾 :japan: 🗻 :mount_fuji: 🌄 :sunrise_over_mountains: 🌅 :sunrise: 🌠 :stars: 🗽 :statue_of_liberty: 🌉 :bridge_at_night: 🎠 :carousel_horse: 🌈 :rainbow: 🎡 :ferris_wheel: ⛲️ :fountain: 🎢 :roller_coaster: 🚢 :ship: 🚤 :speedboat: ⛵️ :boat: ⛵️ :sailboat: 🚣 :rowboat: ⚓️ :anchor: 🚀 :rocket: ✈️ :airplane: 🚁 :helicopter: 🚂 :steam_locomotive: 🚊 :tram: 🚞 :mountain_railway: 🚲 :bike: 🚡 :aerial_tramway: 🚟 :suspension_railway: 🚠 :mountain_cableway: 🚜 :tractor: 🚙 :blue_car: 🚘 :oncoming_automobile: 🚗 :car: 🚗 :red_car: 🚕 :taxi: 🚖 :oncoming_taxi: 🚛 :articulated_lorry: 🚌 :bus: 🚍 :oncoming_bus: 🚨 :rotating_light: 🚓 :police_car: 🚔 :oncoming_police_car: 🚒 :fire_engine: 🚑 :ambulance: 🚐 :minibus: 🚚 :truck: 🚋 :train: 🚉 :station: 🚆 :train2: 🚅 :bullettrain_front: 🚄 :bullettrain_side: 🚈 :light_rail: 🚝 :monorail: 🚃 :railway_car: 🚎 :trolleybus: 🎫 :ticket: ⛽️ :fuelpump: 🚦 :vertical_traffic_light: 🚥 :traffic_light: ⚠️ :warning: 🚧 :construction: 🔰 :beginner: 🏧 :atm: 🎰 :slot_machine: 🚏 :busstop: 💈 :barber: ♨️ :hotsprings: 🏁 :checkered_flag: 🎌 :crossed_flags: 🏮 :izakaya_lantern: 🗿 :moyai: 🎪 :circus_tent: 🎭 :performing_arts: 📍 :round_pushpin: 🚩 :triangular_flag_on_post: 🇯🇵 :jp: 🇰🇷 :kr: 🇨🇳 :cn: 🇺🇸 :us: 🇫🇷 :fr: 🇪🇸 :es: 🇮🇹 :it: 🇷🇺 :ru: 🇬🇧 :gb: 🇬🇧 :uk: 🇩🇪 :de: Symbols 1️⃣ :one: 2️⃣ :two: 3️⃣ :three: 4️⃣ :four: 5️⃣ :five: 6️⃣ :six: 7️⃣ :seven: 8️⃣ :eight: 9️⃣ :nine: 🔟 :keycap_ten: 🔢 :1234: 0️⃣ :zero: #️⃣ :hash: 🔣 :symbols: ◀️ :arrow_backward: ⬇️ :arrow_down: ▶️ :arrow_forward: ⬅️ :arrow_left: 🔠 :capital_abcd: 🔡 :abcd: 🔤 :abc: ↙️ :arrow_lower_left: ↘️ :arrow_lower_right: ➡️ :arrow_right: ⬆️ :arrow_up: ↖️ :arrow_upper_left: ↗️ :arrow_upper_right: ⏬ :arrow_double_down: ⏫ :arrow_double_up: 🔽 :arrow_down_small: ⤵️ :arrow_heading_down: ⤴️ :arrow_heading_up: ↩️ :leftwards_arrow_with_hook: ↪️ :arrow_right_hook: ↔️ :left_right_arrow: ↕️ :arrow_up_down: 🔼 :arrow_up_small: 🔃 :arrows_clockwise: 🔄 :arrows_counterclockwise: ⏪ :rewind: ⏩ :fast_forward: ℹ️ :information_source: 🆗 :ok: 🔀 :twisted_rightwards_arrows: 🔁 :repeat: 🔂 :repeat_one: 🆕 :new: 🔝 :top: 🆙 :up: 🆒 :cool: 🆓 :free: 🆖 :ng: 🎦 :cinema: 🈁 :koko: 📶 :signal_strength: :u5272: :u5272: :u5408: :u5408: :u55b6: :u55b6: :u6307: :u6307: :u6708: :u6708: :u6709: :u6709: 🈵 :u6e80: :u7121: :u7121: :u7533: :u7533: :u7a7a: :u7a7a: :u7981: :u7981: 🈂️ :sa: 🚻 :restroom: 🚹 :mens: 🚺 :womens: 🚼 :baby_symbol: 🚭 :no_smoking: 🅿️ :parking: ♿️ :wheelchair: 🚇 :metro: 🛄 :baggage_claim: 🉑 :accept: 🚾 :wc: 🚰 :potable_water: 🚮 :put_litter_in_its_place: ㊙️ :secret: ㊗️ :congratulations: Ⓜ️ :m: 🛂 :passport_control: 🛅 :left_luggage: 🛃 :customs: 🉐 :ideograph_advantage: 🆑 :cl: 🆘 :sos: 🆔 :id: 🚫 :no_entry_sign: 🔞 :underage: 📵 :no_mobile_phones: 🚯 :do_not_litter: 🚱 :non-potable_water: 🚳 :no_bicycles: 🚷 :no_pedestrians: 🚸 :children_crossing: ⛔️ :no_entry: ✳️ :eight_spoked_asterisk: ✴️ :eight_pointed_black_star: 💟 :heart_decoration: 🆚 :vs: 📳 :vibration_mode: 📴 :mobile_phone_off: 💹 :chart: 💱 :currency_exchange: ♈️ :aries: ♉️ :taurus: ♊️ :gemini: ♋️ :cancer: ♌️ :leo: ♍️ :virgo: ♎️ :libra: ♏️ :scorpius: ♐️ :sagittarius: ♑️ :capricorn: ♒️ :aquarius: ♓️ :pisces: ⛎ :ophiuchus: 🔯 :six_pointed_star: ❎ :negative_squared_cross_mark: 🅰️ :a: 🅱️ :b: 🆎 :ab: 🅾️ :o2: 💠 :diamond_shape_with_a_dot_inside: ♻️ :recycle: 🔚 :end: 🔛 :on: 🔜 :soon: 🕐 :clock1: 🕜 :clock130: 🕙 :clock10: 🕥 :clock1030: 🕚 :clock11: 🕦 :clock1130: 🕛 :clock12: 🕧 :clock1230: 🕑 :clock2: 🕝 :clock230: 🕒 :clock3: 🕞 :clock330: 🕓 :clock4: 🕟 :clock430: 🕔 :clock5: 🕠 :clock530: 🕕 :clock6: 🕡 :clock630: 🕖 :clock7: 🕢 :clock730: 🕗 :clock8: 🕣 :clock830: 🕘 :clock9: 🕤 :clock930: 💲 :heavy_dollar_sign: ©️ :copyright: ®️ :registered: ™️ :tm: ❌ :x: ❗️ :heavy_exclamation_mark: ‼️ :bangbang: ⁉️ :interrobang: ⭕️ :o: ✖️ :heavy_multiplication_x: ➕ :heavy_plus_sign: ➖ :heavy_minus_sign: ➗ :heavy_division_sign: 💮 :white_flower: 💯 :100: ✔️ :heavy_check_mark: ☑️ :ballot_box_with_check: 🔘 :radio_button: 🔗 :link: ➰ :curly_loop: 〰️ :wavy_dash: 〽️ :part_alternation_mark: 🔱 :trident: :black_square: :black_square: :white_square: :white_square: ✅ :white_check_mark: 🔲 :black_square_button: 🔳 :white_square_button: ⚫️ :black_circle: ⚪️ :white_circle: 🔴 :red_circle: 🔵 :large_blue_circle: 🔷 :large_blue_diamond: 🔶 :large_orange_diamond: 🔹 :small_blue_diamond: 🔸 :small_orange_diamond: 🔺 :small_red_triangle: 🔻 :small_red_triangle_down: :shipit: :shipit: 3、书写清晰Github项目名称 好的名称不仅可以让我们更好的寻找到自己需要的项目，也可以让别人快速了解到你的项目。 我不说，大家都懂... 4、使用GitHub Badge 什么是Github Badge？ 又称为GitHub 徽章，是用来标识项目情况、功能等信息的标签。 获取徽章的方法就是在线制作： GitHub Badges 项目地址：https://github.com/ddavison/github-badges 工具地址：http://githubbadges.com Shields 项目地址：https://github.com/badges/shields 工具地址：https://shields.io For the Badge 项目地址：https://github.com/BraveUX/for-the-badge 工具地址：https://forthebadge.com/ 5、管理好项目细节 Description 写好一个简单的描述，要简洁，使人快速了解相关项目内容 Website 如果对应该项目有项目文档网站，您可以进行书写 Manage topics 设置好标签描述，可以让人快速知道代码语言或者内容标签 6、选择开源协议 GitHub开源协议的解释 7、写好文件夹目录 . ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes 参考Hexo文件夹格式，可以根据每次情况进行修改和说明！ ","link":"https://Wangrongsheng.github.io/post/8p75dssZg/"},{"title":"利用gh-pages展示项目","content":" 简介 很多人觉得Github不就是一个代码托管所吗，如何能展示项目呢？其实完全可以借助Github的gh-pages打造出自己的一个作品集，无论是对自己的提升整合还是日后的面试都大有裨益。 那可能有人会不解，既然 Github用户名.github.io 已经能展示页面了，那gh-pages是什么作用呢？ 答：大家不会只有一个项目要展示的吧，万一你和楼主一样把 Github用户名.github.io 作为博客了，那不就没地方展示项目了吗？所以就有了gh-pages这个东东。 使用 如果你有Git和Github的操作基础，你才能看懂接下来的操作哦： 1、用`git symbolic-ref`命令将当前工作分支由`master`切换到一个尚不存在的分支`gh-pages` ；【重要】 git symbolic-ref HEAD refs/heads/gh-pages 2、上传你的.html或者展示的项目文件到你的github本地文档中； 3、 添加到本地 git add . 4、添加描述 git commit -m &quot;描述内容&quot; 5、 执行推送命令，在github远程版本库创建分支gh-pages； git push -u origin gh-pages 以后如果再更新文件的话，直接确认在gh-pages 分支下时，git push 即可~ 参考 如何用Github的gh-pages分支展示自己的项目 ","link":"https://Wangrongsheng.github.io/post/-cgYyiYs0/"},{"title":"一个短视频播放单页源码","content":" 简介 代码简单，页面简洁，支持自动连续播放，兼容微信不用全屏就能播放，第一次打开手动点击播放； 视频链接添加到ks.txt文件中，每行一条链接地址，源码包内提供了6000条视频链接，自行添加即可； 代码 index.html - 入口页面 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charSet=&quot;utf-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt; &lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-transform&quot; /&gt; &lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt; &lt;meta name=&quot;referrer&quot; content=&quot;never&quot;&gt; &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot; /&gt; &lt;title&gt; XJJ &lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;section id=&quot;main&quot;&gt; &lt;video id=&quot;player&quot; src=&quot;video.php&quot; controls webkit-playsinline playsinline&gt;&lt;/video&gt; &lt;/section&gt; &lt;section id=&quot;buttons&quot;&gt; &lt;button id=&quot;switch&quot;&gt;连续: 开&lt;/button&gt; &lt;button id=&quot;next&quot;&gt;播放下一个&lt;/button&gt; &lt;/section&gt; &lt;script&gt; (function (window, document) { if (top != self) { window.top.location.replace(self.location.href); } var get = function (id) { return document.getElementById(id); } var bind = function (element, event, callback) { return element.addEventListener(event, callback); } var auto = true; var player = get('player'); var randomm = function () { player.src = 'video.php?_t=' + Math.random(); player.play(); } bind(get('next'), 'click', randomm); bind(player, 'error', function () { randomm(); }); bind(get('switch'), 'click', function () { auto = !auto; this.innerText = '连续: ' + (auto ? '开' : '关'); }); bind(player, 'ended', function () { if (auto) randomm(); }); })(window, document); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; video.php - 随机获取视频地址 &lt;?php function read(...$filelist) { $list = []; foreach ($filelist as $file) { $handle = fopen($file, 'r'); while (($line = fgets($handle)) !== false) { array_push($list, trim($line)); } fclose($handle); } return $list; } $list = read('ks.txt'); $url = $list[array_rand($list)]; header(&quot;Location: {$url}&quot;); style.css - 样式 * { border: 0; margin: 0; padding: 0; outline: none; box-sizing: border-box; } body { background: #000; width: 100vw; height: 100vh; overflow: hidden; display: flex; flex-direction: column; align-items: center; } #main { height: calc(100vh - 60px); display: flex; justify-content: center; align-items: center; } #player { width: 100%; height: auto; max-height: 100%; } #buttons { height: 60px; padding: 10px; } #switch, #next { background: #FFF; background: linear-gradient(to bottom, #FF2,#FB0); color: #AF2E08; font-size: 16px; font-weight: bold; height: 40px; padding: 0px 20px; margin: 0px 5px; border-radius: 20px; } ks.txt - 视频列表 http://alimov2.a.yximgs.com/upic/2017/11/05/03/BMjAxNzExMDUwMzMyMjNfMTY5OTgwMzlfMzc2OTA5MDYwOV8xXzM=_b.mp4 http://txmov2.a.yximgs.com/upic/2019/05/18/18/BMjAxOTA1MTgxODA4MTVfMTExNTkxMjA4Ml8xMzE4MTQ2NTUwOV8xXzM=_b_B9779e00de57a95b32ce7c7f1a6f5d344.mp4 http://txmov2.a.yximgs.com/upic/2019/05/18/18/BMjAxOTA1MTgxODMxMzZfMjIyNDUxMTY2XzEzMTgyNDUzOTExXzFfMw==_b_B8d23190ec90818e7b12bfaa1062a518c.mp4 http://txmov2.a.yximgs.com/upic/2019/06/10/12/BMjAxOTA2MTAxMjExNDFfNTQwMDU2NDBfMTM5MzQyMDAxNjBfMV8z_b_B83123c2961cad47d1a7214ea2524c32d.mp4 http://hwmov.a.yximgs.com/upic/2019/07/10/21/BMjAxOTA3MTAyMTI1NTFfNDM3ODZfMTUwMjY0MzU3MzJfMV8z_b_B276364034fb4756323028e2c0bc3c3e7.mp4 …… 后面自行补充 演示 Github项目地址 在线体验 扫码体验： ","link":"https://Wangrongsheng.github.io/post/pnxF_eUya/"},{"title":"Python制作云图","content":" 简介 当我们想快速了解书籍、小说、电影剧本中的内容时，可以绘制 WordCloud 词云图，显示主要的关键词（高频词），可以非常直观地看到结果。 一般的云图可以利用在线的云图制作工具就可以满足，例如：TAGUL 、图悦 、Tagxedo 、Tocloud 等。 如果我们想要有一个好的云图展示，就需要进行 分词 ，比较好的分词工具有：Pullword 、jieba 等。 词云制作 现在，我们就利用python 生成一个云图！ 首先我们先安装我们所需要的python第三方库： numpy jieba matplotlib wordcloud 完整实现代码： from wordcloud import WordCloud import matplotlib.pyplot as plt import jieba from PIL import Image import numpy as np # 生成词云函数 def create_word_cloud(words): # 使用结巴分词 text = &quot; &quot;.join(jieba.cut(words,cut_all=False, HMM=True)) wc = WordCloud( # 字体样式 font_path=r'C:\\Windows\\Fonts\\simfang.ttf', max_words=100, width=2000, height=1200, ) wordcloud = wc.generate(text) # 写词云图片 wordcloud.to_file(&quot;wordcloud.jpg&quot;) # 显示词云文件 plt.imshow(wordcloud) plt.axis(&quot;off&quot;) plt.show() 测试内容为： # 第一种：文件读入方式 # s = open(&quot;test.txt&quot;).read() # 第二种：直接copy方式 s= &quot;&quot;&quot; life lies in movement sport is the source of all life to keep on, day after day practice go down, and only activities to keep the enthusiasm of adequate training and improve motor skills activity is the basis of life people's sound, not only by foods, especially to rely on motion the olympic motto is &quot;higher, faster, stronger.&quot; the health of the body for motionless and destruction, for sports practice and keep for a long time WangRongsheng WangRongsheng WangRongsheng WangRongsheng WangRongsheng WangRongsheng baiyunwei baiyunwei baiyunwei baiyunwei baiyunwei 1、希望睡前可以轻吻你，希望睡时可以抱着你，希望醒来可以看见你！一直都这样希望，直到永远。 2、你知道吗？我对你的思念像风一样跟随著你，无论你到哪就如同我再你身边一般，你感觉的到吗？ 3、月光这么美，我睡不着；抖落心事，擦干心情；把梦，一件件晾在风竽上；远方的你让我好牵挂。 4、我的爱，每一个诗人都爱美，你的美更令诗人神飞心醉。但是美是变动的呀，我爱你永远无涯岸。 5、世界上最深沉的不是大海，而是你的心灵。我把自已整个都抛下，却不见泛起一丝涟漪！我好想你！ 6、这样黑的夜里，我多想偎依在你的温暖的被窝里，享受那炽热的爱，美妙的感受沐浴在你的爱意中！ 7、你是如此出众，从春到冬，天天在我思念中，我深深地体会到“失去了方知可贵”这句智理名言。 8、从见你的第一眼开始，我就发现终于找到我的另一半了。我要给你一生的幸福，我坚信一生不动摇！ 9、在遇到梦中人之前，上天也许会安排我们先遇到的人；在我们终于遇见心仪的人时，便应当心存感激。 10、爱情是不按逻辑发展的，所以必须时时注意它的变化。爱情更不是永恒的，所以必须不断的追求。 &quot;&quot;&quot; create_word_cloud(s) 运行展示 ","link":"https://Wangrongsheng.github.io/post/K3ScnBZt9/"},{"title":"用浏览器拍照和保存","content":" 打开摄像头 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;打开摄像头&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;打开摄像头&lt;/h1&gt; &lt;video autoplay playsinline&gt;&lt;/video&gt; &lt;/body&gt; &lt;/html&gt; &lt;script&gt; const mediaStreamContrains = { video: { frameRate: {min: 20}, width: {min: 640, ideal: 1280}, height: {min: 360, ideal: 720}, aspectRatio: 16 / 9 }, audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true } }; const localVideo = document.querySelector('video'); function gotLocalMediaStream(mediaStream) { localVideo.srcObject = mediaStream; } function handleLocalMediaStreamError(error) { console.log('navigator.getUserMedia error: ', error); } navigator.mediaDevices.getUserMedia(mediaStreamContrains).then( gotLocalMediaStream ).catch( handleLocalMediaStreamError ); &lt;/script&gt; 演示结果： 拍照保存 &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;拍照一分钟，P图两小时&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;section&gt; &lt;div&gt; &lt;video autoplay playsinline id=&quot;player&quot;&gt;&lt;/video&gt; &lt;/div&gt; &lt;/section&gt; &lt;section&gt; &lt;div&gt; &lt;button id=&quot;snapshot&quot;&gt;拍照&lt;/button&gt; &lt;button id=&quot;download&quot;&gt;下载&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;canvas id=&quot;picture&quot;&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;/section&gt; &lt;/body&gt; &lt;/html&gt; &lt;script&gt; 'use strict'; var videoplay = document.querySelector('video#player'); function gotMediaStream(stream) { window.stream = stream; videoplay.srcObject = stream; } function handleError(err) { console.log('getUserMedia error:', err); } function start() { var constraints = { video: { width: 1280, height: 720, frameRate: 15, facingMode: 'enviroment' }, audio: false } navigator.mediaDevices.getUserMedia(constraints) .then(gotMediaStream) .catch(handleError); } //拍照 var snapshot = document.querySelector('button#snapshot'); snapshot.onclick = function () { var picture = document.querySelector('canvas#picture'); picture.width = 1280; picture.height = 720; picture.getContext('2d').drawImage(videoplay, 0, 0, picture.width, picture.height); }; //下载 function downLoad(url) { var oA = document.createElement(&quot;a&quot;); oA.download = 'photo';// 设置下载的文件名，默认是'下载' oA.href = url; document.body.appendChild(oA); oA.click(); oA.remove(); // 下载之后把创建的元素删除 } document.querySelector(&quot;button#download&quot;).onclick = function () { downLoad(picture.toDataURL(&quot;image/jpeg&quot;)); }; start(); &lt;/script&gt; 演示结果： ","link":"https://Wangrongsheng.github.io/post/v0mZfte5G/"},{"title":"家国清明","content":" 唯愿山河无恙,人间皆安. ","link":"https://Wangrongsheng.github.io/post/FCQ9SIXQF/"},{"title":"Jupyter渲染网页的3种方式","content":" 一、渲染文本 将htm网页内容到%%html后面，示例如下 %%html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;chenqionghe&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt;Wangrongsheng &lt;small&gt;yeah buddy! light weight bay!&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;p&gt;geting muscle is not easy&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 二、渲染变量 例如我们经常通过requests抓取网页，可以直接渲染出抓取到的内容，例如通过request抓取网页，直接渲染res.text，代码如下 import requests from IPython.display import HTML res=requests.get('http://jd.com') HTML(res.text) 三、代理页面 已有页面想通过jupyter显示出来，可以通过IFrame方法渲染，src可以是本地的html，也可以是一个网页地址 from IPython.display import IFrame IFrame(src='https://sqdxwz.com', width=1000, height=600) ","link":"https://Wangrongsheng.github.io/post/N3oLmg9Ve/"},{"title":"基于selenium+python的自动打开关闭刷新网站","content":" 什么是Selenium？ Selenium是一个用于Web应用程序测试的工具。Selenium测试直接运行在浏览器中，就像真正的用户在操作一样。支持的浏览器包括IE（7, 8, 9, 10, 11），Mozilla Firefox，Safari，Google Chrome，Opera等。支持自动录制动作和自动生成.Net、Java、Python等不同语言的测试脚本。 基于Selenium+Python的打开刷新关闭网页 # coding = utf-8 import time from selenium import webdriver driver = webdriver.Firefox() # 打开火狐浏览器 # driver = webdriver.Chrome() # 打开Chrome # driver = webdriver.Ie() # 打开IE driver.maximize_window() #最大化窗口 driver.get('yoursite') #打开地址 time.sleep(60) #睡眠60s driver.refresh() #刷新打开的页面 driver.close() #关闭浏览器 问题 可能会出现Path配置问题，大家自行百度一下 ","link":"https://Wangrongsheng.github.io/post/KyD_iOEjH/"},{"title":"Python内置函数","content":" Github地址：https://github.com/WangRongsheng/Python-functions 1.abs()函数 ''' abs() 函数返回数字的绝对值。 绝对值：absolute 正如字面上的意思，可以返回一个绝对值 ''' import math print('abs(45)的值:',abs(45)) print('abs(-45)的值:',abs(-45)) print('abs(45+23)的值:',abs(45+23)) print('abs(math.pi)的值:',abs(math.pi)) print(help(abs)) ''' 运行结果： abs(45)的值: 45 abs(-45)的值: 45 abs(45+23)的值: 68 abs(math.pi)的值: 3.141592653589793 Help on built-in function abs in module builtins: abs(x, /) Return the absolute value of the argument. None 在python2 里还可以输出 print &quot;abs(119L) : &quot;, abs(119L) 不过python3中abs函数只能输入int型 不然会报错 ''' 2.all()函数 ''' all() 函数用于判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False。 元素除了是 0、空、FALSE 外都算 TRUE。 语法 以下是 all() 方法的语法: all(iterable) 参数 iterable -- 元组或列表。 返回值 如果iterable的所有元素不为0、''、False或者iterable为空，all(iterable)返回True，否则返回False； 注意：空元组、空列表返回值为True，这里要特别注意。 ''' print(all(['a','b','c',''])) #列表存在一个为空的元素，返回False print(all(['a','b','c','d'])) #列表都有元素，返回True print(all([0,1,2,3,4,5,6])) #列表里存在为0的元素 返回False print(all(('a','b','c',''))) #元组存在一个为空的元素，返回Fasle print(all(('a','b','c','d'))) #元组都有元素，返回True print(all((0,1,2,3,4,5))) #元组存在一个为0的元素，返回Fasle print(all([])) #空列表返回 True print(all(())) #空元组返回 True 3.any()函数 ''' any() 函数用于判断给定的可迭代参数 iterable 是否全部为 False，则返回 False，如果有一个为 True，则返回 True。 元素除了是 0、空、FALSE 外都算 TRUE。 语法 以下是 any() 方法的语法: any(iterable) 参数 iterable -- 元组或列表。 返回值 如果都为空、0、false，则返回false，如果不都为空、0、false，则返回true。 ''' print(any(['a','b','c',''])) #列表存在一个为空的元素，返回True print(any(['a','b','c','d'])) #列表都不为空，返回True print(any([0,'',False])) #列表里的元素全为 0,'',False 返回False print(any(('a','b','c',''))) #元组存在一个为空的元素，返回True print(any(('a','b','c','d'))) #元组都有元素，返回True print(any((0,'',False))) #元组里的元素全为 0,'',False 返回False print(any([])) #空列表返回 False print(any(())) #空元组返回 False 4.ascii()函数 ''' ascii() 函数类似 repr() 函数, 返回一个表示对象的字符串, 但是对于字符串中的非 ASCII 字符则返回通过 repr() 函数使用 \\x, \\u 或 \\U 编码的字符。 生成字符串类似 Python2 版本中 repr() 函数的返回值。 语法 以下是 ascii() 方法的语法: ascii(object) 参数 object -- 对象。 返回值 返回字符串 ''' print(ascii('uiatfu')) #报错 SyntaxError: (unicode error) 'unicodeescape' codec can't decode bytes in position 427-428: truncated \\xXX escape #不知道为何 5.bin()函数 ''' 函数原型 bin(x) 参数解释 x 整数型，参数不可为空。 返回值 &lt;class 'str'&gt; 字符串类型，二进制整数。 函数说明 将一个整数转化为一个二进制整数，并以字符串的类型返回。 ''' print(bin(12)) #输出12的二进制 0b1100 print(bin(-120)) #输出-12的二进制 -0b1111000 print(type(bin(12))) #输出bin(12) 的类型 &lt;class 'str'&gt; 所以不能直接计算 print(int(bin(10),base=2)+int(bin(20),base=2)) #输出 30 #base 参数不可为空 为空默认参数为10进制 会报错 ValueError: invalid literal for int() with base 10: '0b1010' #当然了，参数不仅可以接受十进制整数，八进制、十六进制也是可以的，只要是int型数据就合法。 print(bin(0b10010)) #输出0b10010 print(bin(0o1357)) #输出0b1011101111 print(bin(0x2d9)) #输出0b1011011001 6.bool()函数 ''' 描述 bool() 函数用于将给定参数转换为布尔类型，如果没有参数，返回 False。 bool 是 int 的子类。 语法 以下是 bool() 方法的语法: class bool([x]) 参数 x -- 要进行转换的参数。 返回值 返回 Ture 或 False。 ''' print(bool(0)) #返回False print(bool(1)) #返回True print(bool(True)) #返回True print(bool(False)) #返回False print(bool('')) #返回False #0,False,'', 空字符串返回Fasle 7.bytes()函数 ''' 描述 bytes 函数返回一个新的 bytes 对象，该对象是一个 0 &lt;= x &lt; 256 区间内的整数不可变序列。 它是 bytearray 的不可变版本。 语法 以下是 bytes 的语法: class bytes([source[, encoding[, errors]]]) 参数 如果 source 为整数，则返回一个长度为 source 的初始化数组； 如果 source 为字符串，则按照指定的 encoding 将字符串转换为字节序列； 如果 source 为可迭代类型，则元素必须为[0 ,255] 中的整数； 如果 source 为与 buffer 接口一致的对象，则此对象也可以被用于初始化 bytearray。 如果没有输入任何参数，默认就是初始化数组为0个元素。 返回值 返回一个新的 bytes 对象。 将一个字符串转换成字节类型 ''' print(bytes('python',encoding='utf-8')) #输出b'python' print(bytes('张三',encoding='utf-8')) #输出b'\\xe5\\xbc\\xa0\\xe4\\xb8\\x89' print(bytes([1,2,3,4])) #输出b'\\x01\\x02\\x03\\x04' print(bytes('hello','ascii')) #输出b'hello' print(type(bytes([1,2,3]))) #输出&lt;class 'bytes'&gt; 8.challable()函数 ''' challable() 判断对象是否可以被调用， 能被调用的对象就是一个callables对象， 比如函数和带有__call__()的实例 ''' print(callable(max)) #输出True print(callable([1,2,3])) #输出Fasle print(callable(None)) #输出Fasle print(callable('str')) #输出Fasle def fn(x): return x*x print(callable(fn)) #输出True 证明自定义的函数也可以 9.chr()函数 ''' 查看十进制数对应的ASCII码值 描述 chr() 用一个整数作参数，返回一个对应的字符。 语法 以下是 chr() 方法的语法: chr(i) 参数 i -- 可以是 10 进制也可以是 16 进制的形式的数字，数字范围为 0 到 1,114,111 (16 进制为0x10FFFF)。 返回值 返回值是当前整数对应的 ASCII 字符。 ''' #print(chr(-1)) #报错 ValueError: chr() arg not in range(0x110000) 超出范围 不能小于0 print(chr(0x30)) #输出 0 print(chr(97)) #输出 a print(chr(8364)) #输出 € 10.classmethod()函数 ''' 描述 classmethod 修饰符对应的函数不需要实例化，不需要 self 参数， 但第一个参数需要是表示自身类的 cls 参数，可以来调用类的属性，类的方法，实例化对象等。 语法 classmethod 语法： classmethod 参数 无。 返回值 返回函数的类方法。 ''' class Stud: num=1 def fn1(self): print('方法一') @classmethod def fn2(cls): print('方法二') #输出 方法二 print(cls.num) #调用类的实例化对象 cls().fn1() #调用类的方法 Stud.fn2() #输出 方法二 不需要实例化 print('===='*10) object=Stud() object.fn1() #输出 方法一 需要实例化 11.complex()函数 ''' 描述 complex() 函数用于创建一个值为 real + imag * j 的复数或者转化一个字符串或数为复数。 如果第一个参数为字符串，则不需要指定第二个参数。。 语法 complex 语法： class complex([real[, imag]]) 参数说明： real -- int, long, float或字符串； imag -- int, long, float； 返回值 返回一个复数。 ''' print(complex(1,2)) #输出 (1+2j) print(complex(1)) #输出 (1+0j) print(complex('2')) #输出 (2+0j) # 注意：这个地方在&quot;+&quot;号两边不能有空格，也就是不能写成&quot;1 + 2j&quot;，应该是&quot;1+2j&quot;，否则会报错 print(complex('2+3j')) #输出 (2+3j) print(complex(1.2,3.4)) #输出 (1.2+3.4j) 12.complie()函数 ''' complie() 将字符串编译成python能识别或可以执行的代码，也可以将文字读成字符串再编译 1 compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1) 2 将source编译为代码或者AST对象。代码对象能过通过exec语句来执行或者eval()进行求值。 3 参数source：字符串或者AST（abstract syntax trees）对象。 4 参数filename：代码文件名称，如果不是从文件读取代码则传递一些可辨认的值。 5 参数model：指定编译代码的种类。可以指定'exec', 'eval', 'single'。 6 参数flag和dont_inherit：这两个参数为可选参数。 ''' s=&quot;print('hello world')&quot; r=compile(s,'hello','exec') print(r) #输出结果： #&lt;code object &lt;module&gt; at 0x000002EBD335CF60, file &quot;hello&quot;, line 1&gt; 13.delattr()函数 ''' 描述： delattr函数用于删除属性 delattr(x,'foobar)相当于del x.foobar 语法： setattr(object,name) 参数： object--对象 name--必须是对象的属性 返回值： 无 ''' class People(): sex='男' def __init__(self,name): self.name=name def peopleinfo(self): print('欢迎%s访问'%self.name) delattr(People,'sex') #等同于 del People.sex print(People.__dict__) #输出 {'__module__': '__main__', '__init__': &lt;function People.__init__ at 0x000001CE3E2E52F0&gt;, 'peopleinfo': &lt;function People.peopleinfo at 0x000001CE3E2E5378&gt;, '__dict__': &lt;attribute '__dict__' of 'People' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'People' objects&gt;, '__doc__': None} class Foo: def run(self): while True: cmd=input('cmd&gt;&gt;: ').strip() if hasattr(self,cmd): func=getattr(self,cmd) func() def download(self): print('download....') def upload(self): print('upload...') obj=Foo() obj.run() 14.dict()函数 ''' 描述 dict() 函数用于创建一个字典。 语法 dict 语法： class dict(**kwarg) class dict(mapping, **kwarg) class dict(iterable, **kwarg) 参数说明： **kwargs -- 关键字 mapping -- 元素的容器。 iterable -- 可迭代对象。 返回值 返回一个字典。 ''' print(dict()) #创建空字典 dict1=dict(a='a', b='b', t='t') #传入关键字 构建字典 print(dict1) #输出 {'a': 'a', 'b': 'b', 't': 't'} dict2=dict(zip(['one', 'two', 'three'], [1, 2, 3])) # 映射函数方式来构造字典 print(dict2) #输出 {'one': 1, 'two': 2, 'three': 3} dict3=dict([('one', 1), ('two', 2), ('three', 3)]) # 可迭代对象方式来构造字典 print(dict3) #输出 {'one': 1, 'two': 2, 'three': 3} 15.dir()函数 ''' dir() 函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。如果参数包含方法__dir__()，该方法将被调用。如果参数不包含__dir__()，该方法将最大限度地收集参数信息。 语法 dir 语法： dir([object]) 参数说明： object -- 对象、变量、类型。 返回值 返回模块的属性列表。 ''' print(dir()) #获得当前模块的属性列表 #输出 ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__'] print(dir([])) #获得列表的方法 #输出 ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__ print(dir(str)) #获得字符串的方法 #输出 ['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill'] print(dir(dict)) #获得字典的方法 #输出 ['__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values'] def update_func(var): print(&quot;var 的内存地址:&quot;, id(var)) var += [4] lst_1 = [1, 2, 3] print(dir()) #输出 ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'lst_1', 'update_func'] class Shape: def __dir__(self): return ['area', 'perimeter', 'location'] s = Shape() print(dir(s)) #输出 ['area', 'location', 'perimeter'] #参考网页 https://www.yuzhi100.com/tutorial/python3/python3-neizhihanshu-dir 16.divmod()函数 ''' python divmod() 函数把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a // b, a % b)。 在 python 2.3 版本之前不允许处理复数。 函数语法 divmod(a, b) 参数说明： a: 数字 b: 数字 ''' print(divmod(20,4)) #返回 (5, 0) print(divmod(7,2)) #返回 (3, 1) print(divmod(8,2)) #返回 (4, 0) #print(divmod(1+2j,1+0.5j)) #报错 TypeError: can't take floor or mod of complex number. 17.enumerate()函数 ''' enumerate是翻译过来是枚举的意思，看下它的方法原型： enumerate(sequence, start=0)，返回一个枚举对象。 sequence必须是序列或迭代器iterator，或者支持迭代的对象。 enumerate()返回对象的每个元素都是一个元组， 每个元组包括两个值，一个是计数，一个是sequence的值， 计数是从start开始的，start默认为0。 --------------------- ''' a=[&quot;q&quot;,&quot;w&quot;,&quot;e&quot;,&quot;r&quot;] c=enumerate(a) for i in c: print(i) ''' 输出如下: (0, 'q') (1, 'w') (2, 'e') (3, 'r') ''' a=[&quot;w&quot;,&quot;a&quot;,&quot;s&quot;,&quot;d&quot;] #这里加了个参数2，代表的是start的值 c=enumerate(a,2) for i in c: print(i) ''' 输出如下： (2, 'w') (3, 'a') (4, 's') (5, 'd') ''' a=[&quot;q&quot;,&quot;w&quot;,&quot;e&quot;,&quot;r&quot;] #创建一个空字典 b=dict() #这里i表示的是索引，item表示的是它的值 for i,item in enumerate(a): b[i]=item print(b) #输出 {0: 'q', 1: 'w', 2: 'e', 3: 'r'} for i,j in enumerate('abc'): print(i,j) #输出结果 # 0 a # 1 b # 2 c 18.eval()函数 ''' eval() 函数用来执行一个字符串表达式，并返回表达式的值。 语法 以下是 eval() 方法的语法: eval(expression[, globals[, locals]]) 参数 expression -- 表达式。 globals -- 变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。 locals -- 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。 返回值 返回表达式计算结果。 ''' x=7 print(eval('3*x')) #返回 21 print(eval('pow(2,2)')) #返回 4 print(eval('3+5')) #返回 8 #eval函数还可以实现list、dict、tuple与str之间的转化 #1.字符串转换成列表 a = &quot;[[1,2], [3,4], [5,6], [7,8], [9,0]]&quot; print(type(a)) #返回 &lt;class 'str'&gt; b = eval(a) print(type(b)) #返回 &lt;class 'list'&gt; print(b) #输出 [[1, 2], [3, 4], [5, 6], [7, 8], [9, 0]] #2.字符串转换成字典 a = &quot;{1: 'a', 2: 'b'}&quot; print(type(a)) #返回 &lt;class 'str'&gt; b = eval(a) print(type(b)) #返回 &lt;class 'dict'&gt; print(b) #输出 {1: 'a', 2: 'b'} #3.字符串转换成元组 a = &quot;([1,2], [3,4], [5,6], [7,8], (9,0))&quot; print(type(a)) #返回 &lt;class 'str'&gt; b=eval(a) print(type(b)) #返回 &lt;class 'tuple'&gt; print(b) #输出 ([1, 2], [3, 4], [5, 6], [7, 8], (9, 0)) 19.exec()函数 ''' 函数的作用： 动态执行python代码。也就是说exec可以执行复杂的python代码，而不像eval函数那样只能计算一个表达式的值。 exec(source, globals=None, locals=None, /) source：必选参数，表示需要被指定的python代码。它必须是字符串或code对象。如果source是一个字符串，该字符串会先被解析为一组python语句，然后执行。如果source是一个code对象，那么它只是被简单的执行。 返回值： exec函数的返回值永远为None。 eval()函数和exec()函数的区别： eval()函数只能计算单个表达式的值，而exec()函数可以动态运行代码段。 eval()函数可以有返回值，而exec()函数返回值永远为None。 ''' x = 10 def func(): y = 20 a = exec(&quot;x+y&quot;) print(&quot;a:&quot;,a) #输出 a: None b = exec(&quot;x+y&quot;,{&quot;x&quot;:1,&quot;y&quot;:2}) print(&quot;b:&quot;,b) #输出 b: None c = exec(&quot;x+y&quot;,{&quot;x&quot;:1,&quot;y&quot;:2},{&quot;y&quot;:3,&quot;z&quot;:4}) print(&quot;c:&quot;,c) #输出 c: None d = exec(&quot;print(x,y)&quot;) print(&quot;d:&quot;,d) #输出 d: None func() x = 10 expr = &quot;&quot;&quot; z = 30 sum = x + y + z #一大包代码 print(sum) &quot;&quot;&quot; def func(): y = 20 exec(expr) #10+20+30 输出60 exec(expr,{'x':1,'y':2}) #30+1+2 输出 33 exec(expr,{'x':1,'y':2},{'y':3,'z':4}) #30+1+3，x是定义全局变量1，y是局部变量 输出34 func() #参考原博客 https://www.cnblogs.com/yangmingxianshen/p/7810496.html 20.filter()函数 ''' filter() 函数是一个对于可迭代对象的过滤器，过滤掉不符合条件的元素， 返回的是一个迭代器，如果要转换为列表，可以使用 list() 来转换。 该函数接收两个参数，第一个为函数的引用或者None，第二个为可迭代对象， 可迭代对象中的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到迭代器中 下面看下fiter()的用法： ''' my_list=[1,2,'',3,4,'6',' '] new_list=list(filter(None,my_list)) print(new_list) #None 函数 过滤掉'' 而不是过滤掉空字符串 def is_oushu(x): return x%2==0 new_list=list(filter(is_oushu,list(range(1,11)))) print(new_list) #过滤掉不是偶数的数 a=[1,2,3,4,5,6,2,2,2,] print(list(filter(lambda x:x!=2,a))) #筛选出列表里所有的不是 2 的元素 21.float()函数 ''' 描述 float() 函数用于将整数和字符串转换成浮点数。 语法 float()方法语法： class float([x]) 参数 x -- 整数或字符串 返回值 返回浮点数。 ''' print(float(1)) #输出 1.0 print(float(112.0)) #输出 112.0 print(float('123')) #输出 123.0 print(float(True)) #输出 1.0 print(float(False)) #输出 0.0 #print(float('a')) #报错 ValueError: could not convert string to float: 'a' #可以参考博客 https://blog.csdn.net/TCatTime/article/details/82932818 22.format()函数 ''' 自python2.6开始，新增了一种格式化字符串的函数str.format()，此函数可以快速处理各种字符串。 语法 它通过{}和:来代替%。 请看下面的示例，基本上总结了format函数在python的中所有用法 ''' #通过位置 print ('{0},{1}'.format('chuhao',20)) #chuhao,20 print ('{},{}'.format('chuhao',20)) #chuhao,20 print ('{1},{0},{1}'.format('chuhao',20)) #20,chuhao,20 #通过关键字参数 print ('{name},{age}'.format(age=18,name='chuhao')) #chuhao,18 class Person: def __init__(self,name,age): self.name = name self.age = age def __str__(self): return 'This guy is {self.name},is {self.age} old'.format(self=self) print (str(Person('chuhao',18))) #This guy is chuhao,is 18 old #通过映射 list a_list = ['chuhao',20,'china'] print ('my name is {0[0]},from {0[2]},age is {0[1]}'.format(a_list)) #my name is chuhao,from china,age is 20 #通过映射 dict b_dict = {'name':'chuhao','age':20,'province':'shanxi'} print ('my name is {name}, age is {age},from {province}'.format(**b_dict)) #my name is chuhao, age is 20,from shanxi #填充与对齐 print ('{:&gt;8}'.format('189')) #189 print ('{:0&gt;8}'.format('189')) #00000189 print ('{:a&gt;8}'.format('189')) #aaaaa189 #精度与类型f #保留两位小数 print ('{:.2f}'.format(321.33345)) #321.33 #用来做金额的千位分隔符 print ('{:,}'.format(1234567890)) #1,234,567,890 #其他类型 主要就是进制了，b、d、o、x分别是二进制、十进制、八进制、十六进制。 print ('{:b}'.format(18)) #二进制 10010 print ('{:d}'.format(18)) #十进制 18 print ('{:o}'.format(18)) #八进制 22 print ('{:x}'.format(18)) #十六进制12 #参考博客 https://www.cnblogs.com/gide/p/6955895.html 23.frozenset()函数 ''' 描述 frozenset() 返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。 语法 frozenset() 函数语法： class frozenset([iterable]) 参数 iterable -- 可迭代的对象，比如列表、字典、元组等等。 返回值 返回新的 frozenset 对象，如果不提供任何参数，默认会生成空集合。 ''' a=frozenset(range(10)) print(a) #输出 frozenset({0, 1, 2, 3, 4, 5, 6, 7, 8, 9}) b=frozenset('ltftyut1234') print(b) #输出 frozenset({'2', '4', 't', 'f', '1', '3', 'l', 'y', 'u'}) # 1 frozenset([iterable]) # 2 set和frozenset最本质的区别是前者是可变的，后者是不可变的。当集合对象会被改变时（例如删除，添加元素），只能使用set， # 3 一般来说使用fronzet的地方都可以使用set。 # 4 参数iterable：可迭代对象。 24.getattr()函数 ''' 描述： getattr()函数用于返回一个对象属性值 语法： getattr(object,name,default) 参数： object--对象 name--字符串，对象属性 default--默认返回值，如果不提供该参数，在没有对应属性时，将触发AttributeError。 返回值： 返回对象属性值 ''' class People(): sex='男' def __init__(self,name): self.name=name def peopleinfo(self): print('欢迎%s访问'%self.name) obj=getattr(People,'sex') print(obj) #返回值 男 #obj=getattr(People,'sexage') #print(obj) ''' 报错。。。 Traceback (most recent call last): File &quot;G:/pythonAI/Python_funs/getattr函数详解.py&quot;, line 24, in &lt;module&gt; obj=getattr(People,'sexage') AttributeError: type object 'People' has no attribute 'sexage' ''' obj=getattr(People,'sexage',None) print(obj) #返回值 None 25.globals() 函数 ''' 描述 globals() 函数会以字典类型返回当前位置的全部全局变量。 语法 globals() 函数语法： globals() 参数 无 返回值 返回全局变量的字典 ''' a='ltftyut1234' print(globals()) # globals 函数返回一个全局变量的字典，包括所有导入的变量。 # {'__name__': '__main__', '__doc__': '\\n描述\\nglobals() 函数会以字典类型返回当前位置的全部全局变量。\\n语法\\nglobals() 函数语法：\\nglobals()\\n参数\\n无\\n返回值\\n返回全局变量的字典\\n', '__package__': None, '__loader__': &lt;_frozen_importlib_external.SourceFileLoader object at 0x000001C5A50FB4E0&gt;, '__spec__': None, '__annotations__': {}, '__builtins__': &lt;module 'builtins' (built-in)&gt;, '__file__': 'G:/pythonAI/Python_funs/globals函数详解.py', '__cached__': None, 'a': 'ltftyut1234'} def zero_promo(): return 0 def one_promo(): return 1 def two_promo(): return 2 def hello(): print(&quot;Hello&quot;) if __name__ == '__main__': promos = [name for name in globals()if name.endswith(&quot;_promo&quot;)] print(promos) #输出 ['zero_promo', 'one_promo', 'two_promo'] promos = [globals()[name] for name in globals() if name.endswith(&quot;_promo&quot;)] print(promos[0]()) #输出 0 调用了第一个函数 #参考博客 https://www.jianshu.com/p/a9f583d8cbaa 26.hasattr()函数 ''' hasattr()函数用于判断是否包含对应的属性 语法： hasattr(object,name) 参数： object--对象 name--字符串，属性名 返回值： 如果对象有该属性返回True，否则返回False ''' class People(): sex='男' def __init__(self,name): self.name=name def peopleinfo(self): print('欢迎%s访问'%self.name) obj=People('zhangsan') print(hasattr(People,'sex')) #输出 True print('sex'in People.__dict__) #输出 True print(hasattr(obj,'peopleinfo')) #输出 True print(People.__dict__) #输出 {'__module__': '__main__', 'sex': '男', '__init__': &lt;function People.__init__ at 0x0000019931C452F0&gt;, 'peopleinfo': &lt;function People.peopleinfo at 0x0000019931C45378&gt;, '__dict__': &lt;attribute '__dict__' of 'People' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'People' objects&gt;, '__doc__': None} 27.hash()函数 ''' 描述 hash() 用于获取取一个对象（字符串或者数值等）的哈希值。 语法 hash 语法： hash(object) 参数说明： object -- 对象； 返回值 返回对象的哈希值。 ''' print(hash('test')) #输出 -2950866779904704330 会改变的 print(hash(1)) #数字 输出 1 print(hash(str([1,2,3]))) # 集合 输出 -6217131644886971364 print(hash(str(sorted({'1':1})))) # 字典 输出 -6233802074491902648 ''' hash() 函数可以应用于数字、字符串和对象，不能直接应用于 list、set、dictionary。 在 hash() 对对象使用时，所得的结果不仅和对象的内容有关，还和对象的 id()，也就是内存地址有关。 ''' class Test: def __init__(self, i): self.i = i for i in range(10): t = Test(1) print(hash(t), id(t)) ''' -9223371889060894604 2364702099272 147793883435 2364702134960 -9223371889060894604 2364702099272 147793883435 2364702134960 -9223371889060894604 2364702099272 147793883435 2364702134960 -9223371889060894604 2364702099272 147793883435 2364702134960 -9223371889060894604 2364702099272 147793883435 2364702134960 ''' ''' hash() 函数的用途 hash() 函数的对象字符不管有多长，返回的 hash 值都是固定长度的， 也用于校验程序在传输过程中是否被第三方（木马）修改， 如果程序（字符）在传输过程中被修改hash值即发生变化， 如果没有被修改，则 hash 值和原始的 hash 值吻合， 只要验证 hash 值是否匹配即可验证程序是否带木马（病毒）。 ''' name1='正常程序代码' name2='正常程序代码带病毒' print(hash(name1)) # 2403189487915500087 print(hash(name2)) # -8751655075885266653 28.hex() 函数 ''' 描述 hex() 函数将一个整数转换成十六进制字符串。 语法 hex 语法： hex(x) 参数说明： x -- 整数。 返回值 返回十六进制字符串。 ''' print(hex(12)) #输出12的八进制 0xc print(hex(-120)) #输出-12的二进制 -0x78 print(type(hex(12))) #输出oct(12) 的类型 &lt;class 'str'&gt; 所以不能直接计算 print(int(hex(10),base=16)+int(hex(15),base=16)) #输出 25 #base 参数不可为空 为空默认参数为10进制 会报错 ValueError: invalid literal for int() with base 10: '0b1010' #当然了，参数不仅可以接受十进制整数，八进制、十六进制也是可以的，只要是int型数据就合法。 print(hex(0b10010)) #输出0x12 print(hex(0o1357)) #输出0x2ef print(hex(0x2d9)) #输出0x2d9 29.id() 函数 ''' id() 函数用于获取对象的内存地址。 语法 id 语法： id([object]) 参数说明： object -- 对象。 返回值 返回对象的内存地址。 ''' str='zhangsan' print(id(str)) #输出 1556579882544 动态分配 id 每一次会改变 b=1 print(id(b)) #输出 1597205568 ''' id方法的返回值就是对象的内存地址。 python2中会为每个出现的对象分配内存，哪怕他们的值完全相等（注意是相等不是相同）。 如执行a=2.0，b=2.0这两个语句时会先后为2.0这个Float类型对象分配内存， 然后将a与b分别指向这两个对象。所以a与b指向的不是同一对象 python3中 值相等的变量 内存一样 如下图所示 ''' a=10.21 b=10.21 print(id(a)) #输出2036826247912 print(id(b)) #输出2036826247912 print(a is b) #输出 True print(a == b) #输出 True ''' id 函数 涉及到 浅拷贝和深拷贝的相关知识 深copy和浅copy 深copy新建一个对象重新分配内存地址，复制对象内容。 浅copy不重新分配内存地址，内容指向之前的内存地址。 浅copy如果对象中有引用其他的对象，如果对这个子对象进行修改，子对象的内容就会发生更改。 ''' import copy #这里有子对象 numbers=['1','2','3',['4','5']] #浅copy num1=copy.copy(numbers) #深copy num2=copy.deepcopy(numbers) #直接对对象内容进行修改 num1.append('6') #这里可以看到内容地址发生了偏移，增加了偏移‘6’的地址 print('numbers:',numbers) print('numbers memory address:',id(numbers)) print('numbers[3] memory address',id(numbers[3])) print('num1:',num1) print('num1 memory address:',id(num1)) print('num1[3] memory address',id(num1[3])) num1[3].append('6') print('numbers:',numbers) print('num1:',num1) print('num2',num2) ''' 输出： numbers: ['1', '2', '3', ['4', '5']] numbers memory address: 1556526434888 numbers memory address 1556526434952 num1: ['1', '2', '3', ['4', '5'], '6'] num1 memory address: 1556526454728 num1[3] memory address 1556526434952 numbers: ['1', '2', '3', ['4', '5', '6']] num1: ['1', '2', '3', ['4', '5', '6'], '6'] num2 ['1', '2', '3', ['4', '5']] ''' #参考博客 https://www.cnblogs.com/dplearning/p/5998112.html #参考博客 https://www.cnblogs.com/JackFu/p/8014762.html 30.input() 函数 ''' Python3.x 中 input() 函数接受一个标准输入数据，返回为 string 类型。 注意：在 Python3.x 中 raw_input() 和 input() 进行了整合， 去除了 raw_input( )，仅保留了input( )函数，其接收任意任性输入， 将所有输入默认为字符串处理，并返回字符串类型。 函数语法 input([prompt]) 参数说明： prompt: 提示信息 ''' a=input('请输入一个数:') #输入 10 print(a) #输出 10 print(type(a)) #输出 &lt;class 'str'&gt; #b=a+10 #报错 TypeError: must be str, not int b=int(a)+10 #转换成整型 print(b) #输出 20 a=input('请输入一个字符串:') #输入 ltf1234 print(a) #输出 字符串ltf1234 可以使用字符串对应的方法 print(a.split('1')) #输出 ['ltf', '234'] split 切割字符串 直接输出列表 31.int()函数 ''' int([x[,radix]]) 如果参数是字符串，那么它可能包含符号和小数点。参数radix表示转换的基数（默认是10进制）。 它可以是[2,36]范围内的值，或者0。如果是0，系统将根据字符串内容来解析。 如果提供了参数radix，但参数x并不是一个字符串，将抛出TypeError异常； 否则，参数x必须是数值（普通整数，长整数，浮点数）。通过舍去小数点来转换浮点数。 如果超出了普通整数的表示范围，一个长整数被返回。 如果没有提供参数，函数返回0。 int(x, [base]) 作用： 将一个数字或base类型的字符串转换成整数。 int(x=0) int(x, base=10)，base缺省值为10，也就是说不指定base的值时，函数将x按十进制处理。 注： 1. x 可以是数字或字符串，但是base被赋值后 x 只能是字符串 2. x 作为字符串时必须是 base 类型，也就是说 x 变成数字时必须能用 base 进制表示 ''' #1.x是数字 print(int(2.1)) #输出 2 print(int(2e3)) #输出 2000 #print(int(1000,2)) #出错，base 被赋值后函数只接收字符串 #报错 TypeError: int() can't convert non-string with explicit base #2.x是字符串 print(int('abc12',16)) #输出 703506 #print(int('tuifyg',16)) #出错 tuifyg 超过0-9 abcdef 超出16进制 #报错 ValueError: invalid literal for int() with base 16: 'tuifyg' #3. base 可取值范围是 2~36，囊括了所有的英文字母(不区分大小写)， #十六进制中F表示15，那么G将在二十进制中表示16，依此类推....Z在三十六进制中表示35 #print(int('FZ',16)) # 出错，FZ不能用十六进制表示 #报错 ValueError: invalid literal for int() with base 16: 'FZ' print(int('FZ',36)) # 575 #4.字符串 0x 可以出现在十六进制中，视作十六进制的符号， #同理 0b 可以出现在二进制中，除此之外视作数字 0 和字母 x print(int('0x10', 16)) # 16，0x是十六进制的符号 #print(int('0x10', 17)) # 出错，'0x10'中的 x 被视作英文字母 x print(int('0x10', 36)) # 42804，36进制包含字母 x #参考博客 https://www.cnblogs.com/guyuyuan/p/6827987.html 32.isinstance() 函数 ''' isinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。 isinstance() 与 type() 区别： type() 不会认为子类是一种父类类型，不考虑继承关系。 isinstance() 会认为子类是一种父类类型，考虑继承关系。 如果要判断两个类型是否相同推荐使用 isinstance()。 语法 以下是 isinstance() 方法的语法: isinstance(object, classinfo) 参数 object -- 实例对象。 classinfo -- 可以是直接或间接类名、基本类型或者有它们组成的元组。 返回值 如果对象的类型与参数二的类型（classinfo）相同则返回 True，否则返回 False。。 ''' a=2 print(isinstance(a,int)) #返回 True print(isinstance(a,str)) #返回 Fasle print(isinstance(a,(str,int,list))) #返回 True 是元组中的一个类型 就行 class A: pass class B(A): pass print(isinstance(A(), A) ) # returns True print(type(A()) == A ) # returns True print(isinstance(B(), A)) # returns True print(type(B()) == A) # returns False 33.issubclass()函数 ''' 描述 issubclass() 方法用于判断参数 class 是否是类型参数 classinfo 的子类。 语法 以下是 issubclass() 方法的语法: issubclass(class, classinfo) 参数 class -- 类。 classinfo -- 类。 返回值 如果 class 是 classinfo 的子类返回 True，否则返回 False。 ''' class A: pass class B(A): pass class C(A): pass print(issubclass(B, A)) # 返回 True print(issubclass(C, A)) # 返回 True print(issubclass(C, B)) # 返回 False #2.class参数是classinfo的子类，并且classinfo是元组 print(issubclass(C, (A, object))) #返回 True print(issubclass(C, (A, int, object))) #返回 True print(issubclass(C, (int, str))) #返回 False print(issubclass(C, (int, str, type))) #返回 False #print(issubclass(C, (1, A))) #报错 TypeError: issubclass() arg 2 must be a class or tuple of classes #参考简书 https://www.jianshu.com/p/4c425bbdd773 34.iter() 函数 ''' 描述 iter() 函数用来生成迭代器。 语法 以下是 iter() 方法的语法: iter(object[, sentinel]) 参数 object -- 支持迭代的集合对象。 sentinel -- 如果传递了第二个参数，则参数 object 必须是一个可调用的对象（如，函数），此时，iter 创建了一个迭代器对象，每次调用这个迭代器对象的__next__()方法时，都会调用 object。 打开模式 返回值 迭代器对象。 1 iter(o[, sentinel]) 2 返回一个iterator对象。该函数对于第一个参数的解析依赖于第二个参数。 3 如果没有提供第二个参数，参数o必须是一个集合对象，支持遍历功能（__iter__()方法）或支持序列功能（__getitem__()方法）， 4 参数为整数，从零开始。如果不支持这两种功能，将处罚TypeError异常。 5 如果提供了第二个参数，参数o必须是一个可调用对象。在这种情况下创建一个iterator对象，每次调用iterator的next()方法来无 6 参数的调用o，如果返回值等于参数sentinel，触发StopIteration异常，否则将返回该值。 ''' lst = [1,2,3,4,5,6,7] for i in iter(lst): print(i) #输出1,2,3,4,5,6,7 class counter: def __init__(self, _start, _end): self.start = _start self.end = _end def get_next(self): s = self.start if(self.start &lt; self.end): self.start += 1 else: raise StopIteration return s c = counter(1, 5) iterator = iter(c.get_next, 3) print(type(iterator)) #返回 &lt;class 'callable_iterator'&gt; for i in iterator: print(i) #输出 1 2 #参考博客 https://www.cnblogs.com/yitouniu/p/5243136.html 35.lambda()函数 ''' 匿名函数lambda：是指一类无需定义标识符（函数名）的函数或子程序。 lambda 函数可以接收任意多个参数 (包括可选参数) 并且返回单个表达式的值。 要点： 1，lambda 函数不能包含命令， 2，包含的表达式不能超过一个。 说明：一定非要使用lambda函数；任何能够使用它们的地方，都可以定义一个单独的普通函数来进行替换。 我将它们用在需要封装特殊的、非重用代码上，避免令我的代码充斥着大量单行函数。 lambda匿名函数的格式：冒号前是参数，可以有多个，用逗号隔开，冒号右边的为表达式。 其实lambda返回值是一个函数的地址，也就是函数对象。 ''' def sum(x,y): return x+y print(sum(4,6)) f=lambda x,y:x+y print(f(4,6)) #这俩个例子的效果是一样的，都是返回x+y a=lambda x:x*x print(a(4)) #传入一个参数的lambda函数 返回x*x b=lambda x,y,z:x+y*z print(b(1,2,3)) #返回x+y*z 即1+2*3=7 #2.方法结合使用 from functools import reduce foo=[2, 18, 9, 22, 17, 24, 8, 12, 27] print(list(filter(lambda x:x%3==0,foo))) #筛选x%3==0 的元素 print(list(map(lambda x:x*2+10,foo))) #遍历foo 每个元素乘2+10 再输出 print(reduce(lambda x,y:x+y,foo)) #返回每个元素相加的和 36.len()函数 ''' 描述 Python len() 方法返回对象（字符、列表、元组等）长度或项目个数。 语法 len()方法语法： len( s ) 参数 s -- 对象。 返回值 返回对象长度。 ''' str1='ltf1234' print(len(str1)) #输出 7 list1=[1,2,3,4,5,6,7,8] print(len(list1)) #输出 8 for i in range(len(list1)): print(i) #依次输出1-8 dict = {'num':777,'name':&quot;anne&quot;} print(len(dict)) #输出 2 #参考博客 https://www.cnblogs.com/101718qiong/p/7542193.html 37.list()函数 ''' list() 列表构造函数 1 list([iterable]) 2 list的构造函数。参数iterable是可选的，它可以是序列，支持编译的容器对象，或iterator对象。 3 该函数创建一个元素值，顺序与参数iterable一致的列表。如果参数iterable是一个列表，将创建 4 列表的一个拷贝并返回，就像语句iterables[:]。 ''' list=[1,2,3,4,5,6,7,8,9] #构建列表 print(list) #输出 [1,2,3,4,5,6,7,8,9] list.append(10) #列表追加 10 print(list) #输出 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] list.insert(2,18) #在列表索引为2 的位置 插入 18 其余的后移 print(list) #输出 [1, 2, 18, 3, 4, 5, 6, 7, 8, 9, 10] print(list.count(1)) #输出 列表里1 的数量 list2=[-1,-2,-3] list.extend(list2) #列表追加列表 print(list) #输出 [1, 2, 18, 3, 4, 5, 6, 7, 8, 9, 10, -1, -2, -3] list.remove(1) #删除列表里的第一个1 print(list) #输出 [2, 18, 3, 4, 5, 6, 7, 8, 9, 10, -1, -2, -3] list.sort() #列表排序 print(list) #输出 [-3, -2, -1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 18] list.reverse() #列表反转 print(list) #输出 [18, 10, 9, 8, 7, 6, 5, 4, 3, 2, -1, -2, -3] print(max(list)) #输出列表最大值 18 print(min(list)) #输出列表最小值 -3 list3=[1,2,3,'q','a','s'] #print(max(list3)) #报错 &gt;' not supported between instances of 'str' and 'int' #print(min(list3)) #报错 &gt;' not supported between instances of 'str' and 'int' 38.locals() 函数 ''' locals() 函数会以字典类型返回当前位置的全部局部变量。 对于函数, 方法, lambda 函式, 类, 以及实现了 __call__ 方法的类实例, 它都返回 True。 语法 locals() 函数语法： locals() 参数 无 返回值 返回字典类型的局部变量 1 不要修改locals()返回的字典中的内容；改变可能不会影响解析器对局部变量的使用。 2 在函数体内调用locals()，返回的是自由变量。修改自由变量不会影响解析器对变量的使用。 3 不能在类区域内返回自由变量。 ''' def test_py(arg): z=1 print(locals()) test_py(6) #输出 {'z': 1, 'arg': 6} def foo(arg, a): x = 100 y = 'hello python!' for i in range(10): j = 1 k = i print(locals()) foo(1, 2) #输出 {'k': 9, 'j': 1, 'i': 9, 'y': 'hello python!', 'x': 100, 'a': 2, 'arg': 1} #参考博客 https://blog.csdn.net/sxingming/article/details/52061630 39.map()函数 ''' map()函数 map()是 Python 内置的高阶函数，它接收一个函数 f 和一个 list， 并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。 例如，对于list [1, 2, 3, 4, 5, 6, 7, 8, 9] 如果希望把list的每个元素都作平方，就可以用map()函数： 因此，我们只需要传入函数f(x)=x*x，就可以利用map()函数完成这个计算： ''' list=[1,2,3,4,5,6,7,8,9] def f(x): return x*x list1=map(f,list) print(list1) for i in list1: print(i) ''' 注意：map()函数不改变原有的 list，而是返回一个新的 list。 利用map()函数，可以把一个 list 转换为另一个 list，只需要传入转换函数。 由于list包含的元素可以是任何类型，因此，map() 不仅仅可以处理只包含数值的 list， 事实上它可以处理包含任意类型的 list，只要传入的函数f可以处理这种数据类型。 任务 假设用户输入的英文名字不规范，没有按照首字母大写，后续字母小写的规则， 请利用map()函数，把一个list（包含若干不规范的英文名字）变成一个包含规范英文名字的 ''' def format_name(s): s1=s[0:1].upper()+s[1:].lower() return s1 names=['adam', 'LISA', 'barT'] print (map(format_name, names)) #python2 这样写可以直接输出列表 for i in map(format_name,names): print(i) #python3 得这样写才可以 40.max()函数 ''' 描述 max() 方法返回给定参数的最大值，参数可以为序列。 语法 以下是 max() 方法的语法: max( x, y, z, .... ) 参数 x -- 数值表达式。 y -- 数值表达式。 z -- 数值表达式。 返回值 返回给定参数的最大值。 ''' print (&quot;max(80, 100, 1000) : &quot;, max(80, 100, 1000)) print (&quot;max(-20, 100, 400) : &quot;, max(-20, 100, 400)) print (&quot;max(-80, -20, -10) : &quot;, max(-80, -20, -10)) print (&quot;max(0, 100, -400) : &quot;, max(0, 100, -400)) ''' 输出结果： max(80, 100, 1000) : 1000 max(-20, 100, 400) : 400 max(-80, -20, -10) : -10 max(0, 100, -400) : 100 ''' #1.传入的多个参数的最大值 print(max(1,2,3,4)) #输出 4 #2.传入可迭代对象时，取其元素最大值 s='12345' print(max(s)) #输出 5 #3.传入命名参数key，其为一个函数，用来指定取最大值的方法 s = [ {'name': 'sumcet', 'age': 18}, {'name': 'bbu', 'age': 11} ] a = max(s, key=lambda x: x['age']) print(a) #输出 {'name': 'sumcet', 'age': 18} 41.min()函数 ''' 描述 min() 方法返回给定参数的最小值，参数可以为序列。 语法 以下是 min() 方法的语法: min( x, y, z, .... ) 参数 x -- 数值表达式。 y -- 数值表达式。 z -- 数值表达式。 返回值 返回给定参数的最小值。 ''' print (&quot;min(80, 100, 1000) : &quot;, min(80, 100, 1000)) print (&quot;min(-20, 100, 400) : &quot;, min(-20, 100, 400)) print (&quot;min(-80, -20, -10) : &quot;, min(-80, -20, -10)) print (&quot;min(0, 100, -400) : &quot;, min(0, 100, -400)) ''' 输出结果 min(80, 100, 1000) : 80 min(-20, 100, 400) : -20 min(-80, -20, -10) : -80 min(0, 100, -400) : -400 ''' #1.传入的多个参数的最小值 print(min(1,2,3,4)) #输出 1 #2.传入可迭代对象时，取其元素最小值 s='12345' print(min(s)) #输出 1 #3.传入命名参数key，其为一个函数，用来指定取最小值的方法 s = [ {'name': 'sumcet', 'age': 18}, {'name': 'bbu', 'age': 11} ] a = min(s, key=lambda x: x['age']) print(a) #输出 {'name': 'bbu', 'age': 11} 42.next()函数 ''' 描述 next() 返回迭代器的下一个项目。 语法 next 语法： next(iterator[, default]) 参数说明： iterator -- 可迭代对象 default -- 可选，用于设置在没有下一个元素时返回该默认值，如果不设置，又没有下一个元素则会触发 StopIteration 异常。 返回值 返回对象帮助信息。 ''' # 首先获得Iterator对象: it = iter([1, 2, 3, 4, 5]) # 循环: while True: try: # 获得下一个值: x = next(it) print(x) except StopIteration: # 遇到StopIteration就退出循环 break a=iter('abcde') print(next(a)) #输出 a print(next(a)) #输出 b print(next(a)) #输出 c print(next(a)) #输出 d print(next(a)) #输出 e #print(next(a)) #报错 StopIteration #函数可以接收一个可选的default参数，传入default参数后， # 如果可迭代对象还有元素没有返回，则依次返回其元素值，如果所有元素已经返回， # 则返回default指定的默认值而不抛出StopIteration 异常。 print(next(a,'e')) #这次不报错了 返回 e 即default参数 #参考博客 http://www.cnblogs.com/sesshoumaru/p/6037922.html 43.oct() 函数 ''' 描述 oct() 函数将一个整数转换成八进制字符串。 语法 oct 语法： oct(x) 参数说明： x -- 整数。 返回值 返回八进制字符串。 ''' print(oct(12)) #输出12的八进制 0o14 print(oct(-120)) #输出-12的二进制 -0o170 print(type(oct(12))) #输出oct(12) 的类型 &lt;class 'str'&gt; 所以不能直接计算 print(int(oct(10),base=8)+int(oct(15),base=8)) #输出 25 #base 参数不可为空 为空默认参数为10进制 会报错 ValueError: invalid literal for int() with base 10: '0b1010' #当然了，参数不仅可以接受十进制整数，八进制、十六进制也是可以的，只要是int型数据就合法。 print(oct(0b10010)) #输出0o22 print(oct(0o1357)) #输出0o1357 print(oct(0x2d9)) #输出0o1331 44.open() 函数 ''' python open() 函数用于打开一个文件，创建一个 file 对象，相关的方法才可以调用它进行读写。 更多文件操作可参考：Python 文件I/O。 函数语法 open(name[, mode[, buffering]]) 参数说明： name : 一个包含了你要访问的文件名称的字符串值。 mode : mode 决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。 buffering : 如果 buffering 的值被设为 0，就不会有寄存。如果 buffering 的值取 1，访问文件时会寄存行。如果将 buffering 的值设为大于 1 的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。 不同模式打开文件的完全列表： 模式 描述 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 file 对象方法 file.read([size])：size 未指定则返回整个文件，如果文件大小 &gt;2 倍内存则有问题，f.read()读到文件尾时返回&quot;&quot;(空字串)。 file.readline()：返回一行。 file.readlines([size]) ：返回包含size行的列表, size 未指定则返回全部行。 for line in f: print line ：通过迭代器访问。 f.write(&quot;hello\\n&quot;)：如果要写入字符串以外的数据,先将他转换为字符串。 f.tell()：返回一个整数,表示当前文件指针的位置(就是到文件头的比特数)。 f.seek(偏移量,[起始位置])：用来移动文件指针。 偏移量: 单位为比特，可正可负 起始位置: 0 - 文件头, 默认值; 1 - 当前位置; 2 - 文件尾 f.close() 关闭文件 open(filename [, mode [, bufsize]]) 打开一个文件，返回一个file对象。 如果文件无法打开，将处罚IOError异常。 应该使用open()来代替直接使用file类型的构造函数打开文件。 参数filename表示将要被打开的文件的路径字符串； 参数mode表示打开的模式，最常用的模式有：'r'表示读文本，'w'表示写文本文件，'a'表示在文件中追加。 Mode的默认值是'r'。 当操作的是二进制文件时，只要在模式值上添加'b'。这样提高了程序的可移植性。 可选参数bufsize定义了文件缓冲区的大小。0表示不缓冲；1表示行缓冲；任何其他正数表示使用该大小的缓冲区； 负数表示使用系统默认缓冲区大小，对于tty设备它往往是行缓冲，而对于其他文件往往完全缓冲。如果参数值被省却。 使用系统默认值。 ''' f=open('1.txt','r',encoding='utf-8') print(f.read()) ''' 输出... ltf zhongguo shanxi yuncheng 男 20 ''' #参考博客 https://www.cnblogs.com/Devilf/p/8006663.html 45.ord() 函数 ''' 描述 ord() 函数是 chr() 函数（对于8位的ASCII字符串）或 unichr() 函数（对于Unicode对象）的配对函数，它以一个字符（长度为1的字符串）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值，如果所给的 Unicode 字符超出了你的 Python 定义范围，则会引发一个 TypeError 的异常。 语法 以下是 ord() 方法的语法: ord(c) 参数 c -- 字符。 返回值 返回值是对应的十进制整数。 ''' print(ord('a')) #输出97 print(ord('b')) #输出98 print(ord('c')) #输出99 print(ord(']')) #输出93 print(ord('8')) #输出56 #其实要是有一张表就好了 哈哈哈哈 46.pow()函数 ''' 描述 pow() 方法返回 xy（x的y次方） 的值。 语法 以下是 math 模块 pow() 方法的语法: import math math.pow( x, y ) 内置的 pow() 方法 pow(x, y[, z]) 函数是计算x的y次方，如果z在存在，则再对结果进行取模，其结果等效于pow(x,y) %z 注意：pow() 通过内置的方法直接调用，内置方法会把参数作为整型，而 math 模块则会把参数转换为 float。 参数 x -- 数值表达式。 y -- 数值表达式。 z -- 数值表达式。 返回值 返回 xy（x的y次方） 的值。 ''' import math # 导入 math 模块 print(&quot;math.pow(100, 2) : &quot;, math.pow(100, 2)) # 使用内置，查看输出结果区别 print(&quot;pow(100, 2) : &quot;, pow(100, 2)) print(&quot;math.pow(100, -2) : &quot;, math.pow(100, -2)) print(&quot;math.pow(2, 4) : &quot;, math.pow(2, 4)) print(&quot;math.pow(3, 0) : &quot;, math.pow(3, 0)) ''' 输出结果... math.pow(100, 2) : 10000.0 pow(100, 2) : 10000 math.pow(100, -2) : 0.0001 math.pow(2, 4) : 16.0 math.pow(3, 0) : 1.0 ''' 47.property() 函数 ''' 描述 property() 函数的作用是在新式类中返回属性值。 语法 以下是 property() 方法的语法: class property([fget[, fset[, fdel[, doc]]]]) 参数 fget -- 获取属性值的函数 fset -- 设置属性值的函数 fdel -- 删除属性值函数 doc -- 属性描述信息 返回值 返回新式类属性 ''' class C(object): def __init__(self): self._x = None def getx(self): return self._x def setx(self, value): self._x = value def delx(self): del self._x x = property(getx, setx, delx, &quot;I'm the 'x' property.&quot;) class Parrot(object): def __init__(self): self._voltage = 100000 #装饰器写法 @property def voltage(self): &quot;&quot;&quot;Get the current voltage.&quot;&quot;&quot; return self._voltage class D(object): def __init__(self): self._x = None @property def x(self): &quot;&quot;&quot;I'm the 'x' property.&quot;&quot;&quot; return self._x @x.setter def x(self, value): self._x = value @x.deleter def x(self): del self._x 48.range() 函数 ''' python range() 函数可创建一个整数列表，一般用在 for 循环中。 函数语法 range(start, stop[, step]) 参数说明： start: 计数从 start 开始。默认是从 0 开始。例如range（5）等价于range（0， 5）; stop: 计数到 stop 结束，但不包括 stop。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5 step：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1) ''' for i in range(10): print(i) #输出 从0-9 for i in range(0,11,2): print(i) #输出 0,2,4,6,8,10 for i in range(0,-10,-3): print(i) #输出 0,-3,-6,-9 list=[] for i in range(5,-5,-1): list.append(i) print(list) #输出 [5, 4, 3, 2, 1, 0, -1, -2, -3, -4] for i in 'ahfgohiauf': print(i) #依次输出字符 #参考博客 https://www.cnblogs.com/101718qiong/p/7542193.html 49.reduece()函数 ''' 在python3中如果使用reduce需要先导入 from functools import reduce reduce函数，reduce函数会对参数序列中元素进行累积。 reduce函数的定义： reduce(function, sequence [, initial] ) -&gt; value function参数是一个有两个参数的函数，reduce依次从sequence中取一个元素， 和上一次调用function的结果做参数再次调用function。 第一次调用function时，如果提供initial参数， 会以sequence中的第一个元素和initial作为参数调用function， 否则会以序列sequence中的前两个元素做参数调用function。 ''' from functools import reduce lst=[1,2,3,4,5,6] def f(x,y): return x+y print(reduce(f,lst)) ''' 过程1+2+3+4+5+6=21 ''' print(reduce(lambda x,y:x*y,lst)) # 运行过程为1*2*3*4*5*6=720 #来个稍微复杂的 print(reduce(lambda x,y:x*y+1,lst)) ''' 运算步骤：1*2+1=3 3*3+1=10 10*4+1=41 41*5+1=206 206*6+1=1237 ''' #再说说有初始化值的情况, 这个时候就不是取列表的前两项, 而是取初始值为第一个, # 序列的第一个元素为第二个元素,开始进行lambda函数的应用计算. print(reduce(lambda x,y:x+y,lst,5)) ''' 计算步骤：5+1=6 6+2=8 8+3=11 11+4=15 15+5=20 20+6=26 ''' 50.repr()函数 ''' 描述 repr() 函数将对象转化为供解释器读取的形式。 语法 以下是 repr() 方法的语法: repr(object) 参数 object -- 对象。 返回值 返回一个对象的 string 格式。 ''' s='qwerasdf' print(s) #输出 qwerasdf print(repr(s)) #输出 'qwerasdf' dict={'a':1,'b':2} print(dict) #输出 {'a': 1, 'b': 2} print(repr(dict)) #输出 {'a': 1, 'b': 2} 没改变么 print(repr([0,1,2,3,4])) #输出 [0, 1, 2, 3, 4] print(repr('hello')) #输出 'hello' print(str(1.0/7.0)) #输出 0.14285714285714285 print(repr(1.0/7.0)) #输出 0.14285714285714285 51.reversed() 函数 ''' 描述 reversed 函数返回一个反转的迭代器。 语法 以下是 reversed 的语法: reversed(seq) 参数 seq -- 要转换的序列，可以是 tuple, string, list 或 range。 返回值 返回一个反转的迭代器。 1 reversed(seq) 2 返回一个逆序的iterator对象。参数seq必须是一个包含__reversed__()方法的对象或支持序列操作(__len__()和__getitem__()) 3 该函数是2.4中新增的 ''' str='wasdqwer' print(list(reversed(str))) #输出 ['r', 'e', 'w', 'q', 'd', 's', 'a', 'w'] tuple=('r', 'e', 'w', 'q', 'd', 's', 'a', 'w') print(list(reversed(tuple))) #输出 ['w', 'a', 's', 'd', 'q', 'w', 'e', 'r'] seqRange = range(5, 9) print(list(reversed(seqRange))) #输出 [8, 7, 6, 5] seqList = [1, 2, 4, 3, 5] print(list(reversed(seqList))) #输出 [5, 3, 4, 2, 1] a=[1,2,3,4,5,6] b=reversed(a) print(b) #输出 &lt;list_reverseiterator object at 0x0000023E2A448748&gt; 显示为一个迭代器 print(list(b)) #输出 [6, 5, 4, 3, 2, 1] print(list(b)) #输出 [] #由此可知：reversed（）返回的是一个迭代器对象，只能进行一次循环遍历。显示一次所包含的值！ 52.round()函数 ''' 描述 round() 方法返回浮点数x的四舍五入值。 语法 以下是 round() 方法的语法: round( x [, n] ) 参数 x -- 数字表达式。 n -- 表示从小数点位数，其中 x 需要四舍五入，默认值为 0。 返回值 返回浮点数x的四舍五入值。 ''' print (&quot;round(70.23456) : &quot;, round(70.23456)) print (&quot;round(56.659,1) : &quot;, round(56.659,1)) print (&quot;round(80.264, 2) : &quot;, round(80.264, 2)) print (&quot;round(100.000056, 3) : &quot;, round(100.000056, 3)) print (&quot;round(-100.000056, 3) : &quot;, round(-100.000056, 3)) ''' 输出结果... round(70.23456) : 70 round(56.659,1) : 56.7 round(80.264, 2) : 80.26 round(100.000056, 3) : 100.0 round(-100.000056, 3) : -100.0 ''' 53.setattr()函数 ''' 描述： setattr函数，用于设置属性值，该属性必须存在 语法： setattr(object,name,value) 参数： object--对象 name--字符串，对象属性 value--属性值 返回值： 无 ''' class People(): sex='男' def __init__(self,name): self.name=name def peopleinfo(self): print('欢迎%s访问'%self.name) obj=People('zhangsan') setattr(People,'x',123) print(People.x) #等同于 Peopel.x=123 setattr(obj,'age',18) print(obj.__dict__) #输出 {'name': 'zhangsan', 'age': 18} print(People.__dict__) #输出 #{'__module__': '__main__', 'sex': '男', '__init__': &lt;function People.__init__ at 0x00000259A92752F0&gt;, 'peopleinfo': &lt;function People.peopleinfo at 0x00000259A9275378&gt;, '__dict__': &lt;attribute '__dict__' of 'People' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'People' objects&gt;, '__doc__': None, 'x': 123} 54.set() 函数 ''' 描述 set() 函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等。 语法 set 语法： class set([iterable]) 参数说明： iterable -- 可迭代对象对象； 返回值 返回新的集合对象。 ''' a=set('www.baidu.com') b=set('www.gogle.com') #重复的元素被删除 元素唯一 可以用来去重 print(a) #输出 {'u', '.', 'm', 'c', 'w', 'd', 'i', 'a', 'o', 'b'} print(b) #输出 {'.', 'm', 'e', 'c', 'w', 'o', 'l', 'g'} print(a&amp;b) #交集 {'m', 'c', 'w', '.', 'o'} print(a|b) #并集 {'m', 'c', 'i', 'w', 'b', 'd', 'u', 'g', 'e', 'a', '.', 'o', 'l'} print(a-b) #差集 {'i', 'b', 'd', 'u', 'a'} #1.比较 se = {11, 22, 33} be = {22, 55} temp1 = se.difference(be) #找到se中存在，be中不存在的集合，返回新值 print(temp1) #{33, 11} print(se) #{33, 11, 22} temp2 = se.difference_update(be) #找到se中存在，be中不存在的集合，覆盖掉se print(temp2) #None print(se) #{33, 11}, #2.删除 se = {11, 22, 33} se.discard(11) se.discard(44) # 移除不存的元素不会报错 print(se) se = {11, 22, 33} se.remove(11) #se.remove(44) # 移除不存的元素会报错 print(se) se = {11, 22, 33} # 移除末尾元素并把移除的元素赋给新值 temp = se.pop() print(temp) # 33 print(se) # {11, 22} #3.取交集 se = {11, 22, 33} be = {22, 55} temp1 = se.intersection(be) #取交集，赋给新值 print(temp1) # 22 print(se) # {11, 22, 33} temp2 = se.intersection_update(be) #取交集并更新自己 print(temp2) # None print(se) # 22 #4.判断 se = {11, 22, 33} be = {22} print(se.isdisjoint(be)) #False，判断是否不存在交集（有交集False，无交集True） print(se.issubset(be)) #False，判断se是否是be的子集合 print(se.issuperset(be)) #True，判断se是否是be的父集合 #5.合并 se = {11, 22, 33} be = {22} temp1 = se.symmetric_difference(be) # 合并不同项，并赋新值 print(temp1) #{33, 11} print(se) #{33, 11, 22} temp2 = se.symmetric_difference_update(be) # 合并不同项，并更新自己 print(temp2) #None print(se) #{33, 11} #6.取并集 se = {11, 22, 33} be = {22,44,55} temp=se.union(be) #取并集，并赋新值 print(se) #{33, 11, 22} print(temp) #{33, 22, 55, 11, 44} #7.更新 se = {11, 22, 33} be = {22,44,55} se.update(be) # 把se和be合并，得出的值覆盖se print(se) se.update([66, 77]) # 可增加迭代项 print(se) #8.集合的转换 se = set(range(4)) li = list(se) tu = tuple(se) st = str(se) print(li,type(li)) #输出 [0, 1, 2, 3] &lt;class 'list'&gt; print(tu,type(tu)) #输出 [0, 1, 2, 3] &lt;class 'tuple'&gt; print(st,type(st)) #输出 [0, 1, 2, 3] &lt;class 'str'&gt; #参考博客 https://www.cnblogs.com/whatisfantasy/p/5956775.html 55.slice() 函数 ''' 描述 slice() 函数实现切片对象，主要用在切片操作函数里的参数传递。 语法 slice 语法： class slice(stop) class slice(start, stop[, step]) 参数说明： start -- 起始位置 stop -- 结束位置 step -- 间距 返回值 返回一个切片对象。 实例 ''' myslice=slice(5) #设置一个 截取五个元素的切片 print(myslice) #输出 slice(None, 5, None) arr=list(range(10)) print(arr) #输出 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] print(arr[myslice]) #输出 [0, 1, 2, 3, 4] print(arr[3:6]) #输出 [3, 4, 5] 56.sorted() 函数 ''' 描述 sorted() 函数对所有可迭代的对象进行排序操作。 sort 与 sorted 区别： sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。 list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。 语法 sorted 语法： sorted(iterable, key=None, reverse=False) 参数说明： iterable -- 可迭代对象。 key -- 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。 reverse -- 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。 返回值 返回重新排序的列表。 ''' print(sorted([2,3,4,1,5,6])) #输出 [1, 2, 3, 4, 5, 6] #另一个区别在于list.sort() 方法只为 list 定义。而 sorted() 函数可以接收任何的 iterable。 print(sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})) #输出 [1, 2, 3, 4, 5] #利用key进行倒序排序 example_list = [5, 0, 6, 1, 2, 7, 3, 4] result_list = sorted(example_list, key=lambda x: x*-1) print(result_list) #输出 [7, 6, 5, 4, 3, 2, 1, 0] #要进行反向排序，也通过传入第三个参数 reverse=True： example_list = [5, 0, 6, 1, 2, 7, 3, 4] result_list=sorted(example_list, reverse=True) print(result_list) #输出 [7, 6, 5, 4, 3, 2, 1, 0] #sorted 的应用，也可以通过 key 的值来进行数组/字典的排序，比如 array = [{&quot;age&quot;:20,&quot;name&quot;:&quot;a&quot;},{&quot;age&quot;:25,&quot;name&quot;:&quot;b&quot;},{&quot;age&quot;:10,&quot;name&quot;:&quot;c&quot;}] array = sorted(array,key=lambda x:x[&quot;age&quot;]) print(array) #输出 [{'age': 10, 'name': 'c'}, {'age': 20, 'name': 'a'}, {'age': 25, 'name': 'b'}] 57.staticmethod()函数 ''' python staticmethod 返回函数的静态方法。 该方法不强制要求传递参数，如下声明一个静态方法： class C(object): @staticmethod def f(arg1, arg2, ...): ... 以上实例声明了静态方法 f，类可以不用实例化就可以调用该方法 C.f()，当然也可以实例化后调用 C().f()。 函数语法 staticmethod(function) 参数说明： 无 ''' class C(object): @staticmethod def f(): print('hello world') C.f() # 静态方法无需实例化 cobj = C() cobj.f() # 也可以实例化后调用 class A(object): def foo(self, x): print(&quot;executing foo(%s,%s)&quot; % (self, x)) print('self:', self) @classmethod def class_foo(cls, x): print(&quot;executing class_foo(%s,%s)&quot; % (cls, x)) print('cls:', cls) @staticmethod def static_foo(x): print(&quot;executing static_foo(%s)&quot; % x) a = A() print(a.foo) #输出 &lt;bound method A.foo of &lt;__main__.A object at 0x000001B5B2A51D30&gt;&gt; print(a.class_foo) #输出 &lt;bound method A.class_foo of &lt;class '__main__.A'&gt;&gt; print(a.static_foo) #输出 &lt;function A.static_foo at 0x000001B5B2A55598&gt; #参考博客 https://www.cnblogs.com/elie/p/5876210.html 58.str() 函数 ''' 描述 str() 函数将对象转化为适于人阅读的形式。 语法 以下是 str() 方法的语法: class str(object='') 参数 object -- 对象。 返回值 返回一个对象的string格式。 ''' print(str(1)) #输出 字符串1 print(type(str(1))) #输出 &lt;class 'str'&gt; print(str(b'\\xe5\\xbc\\xa0\\xe4\\xb8\\x89',encoding='utf-8')) #输出张三 dict={'zhangsan':'zhang1234','lisi':'li1234'} print(type(dict)) #输出 &lt;class 'dict'&gt; a=str(dict) print(str(dict)) #输出 字符串 {'zhangsan': 'zhang1234', 'lisi': 'li1234'} print(type(a)) #输出 &lt;class 'str'&gt; 59.sum()函数 ''' 描述 sum() 方法对系列进行求和计算。 语法 以下是 sum() 方法的语法: sum(iterable[, start]) 参数 iterable -- 可迭代对象，如：列表、元组、集合。 start -- 指定相加的参数，如果没有设置这个值，默认为0。 返回值 返回计算结果 ''' print(sum([0,1,2])) # 列表总和 3 print(sum((2,3,4),1)) # 元组计算总和后再加 1 print(sum([2,3,4,5,6],8)) # 列表计算总和后再加 2 a = list(range(1,11)) b = list(range(1,10)) c = sum([item for item in a if item in b]) print(c) #输出 45 60.vars() 函数 ''' 描述 vars() 函数返回对象object的属性和属性值的字典对象。 语法 vars() 函数语法： vars([object]) 参数 object -- 对象 返回值 返回对象object的属性和属性值的字典对象，如果没有参数，就打印当前调用位置的属性和属性值 类似 locals()。 ''' print(vars()) #输出 {'__name__': '__main__', '__doc__': '\\n描述\\nvars() 函数返回对象object的属性和属性值的字典对象。\\n语法\\nvars() 函数语法：\\nvars([object])\\n参数\\nob class A: a=1 __dict__ = 'ltf' print(vars(A)) #输出 {'__module__': '__main__', 'a': 1, '__dict__': &lt;attribute '__dict__' of 'A' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'A' objects&gt;, '__doc__': None} a=A() print(vars(a)) #输出 ltf print(a.__dict__) #输出 ltf 61.zip()函数 #zip函数接受任意多个可迭代对象作为参数,将对象中对应的元素打包成一个tuple,然后返回一个可迭代的zip对象. #这个可迭代对象可以使用循环的方式列出其元素 #若多个可迭代对象的长度不一致,则所返回的列表与长度最短的可迭代对象相同. #1.用列表生成zip对象 x=[1,2,3] y=[4,5,6] z=[7,8,9] h=['a','b','c','d'] zip1=zip(x,y,z) print(zip1) for i in zip1: print(i) zip2=zip(x,y,h) for i in zip2: print(i) zip3=zip(h) for i in zip3: print(i) zip4=zip(*h*3) for i in zip4: print(i) #这是干啥哟。。 print('==*=='*10) #2.二维矩阵变换 l1=[[1,2,3],[4,5,6],[7,8,9]] print(l1) print([[j[i] for j in l1] for i in range(len(l1[0])) ]) zip5=zip(*l1) for i in zip5: print(i) ","link":"https://Wangrongsheng.github.io/post/05WRNcL6x/"},{"title":"Win10设置定时程序运行任务","content":" 最近写了一个简单的Python程序，想让这个小程序每天上午7点定时运行一次。由于其他原因，直接使用Windows定时任务： 搜索打开【任务计划程序】 ： 之后点击右侧的【创建基本任务】： 输入任务名称以及可选的任务描述： 设置任务的开始时间，这个应该没什么难度，我这里设置为每天早上7点运行此计划任务： 设置【操作】为【启动程序】： 进入启动程序设置界面： 【程序或脚本】文本框中填的是Python编译器的名称，一般就是python.exe； 【添加参数】文本框中填的是你的要运行的Python程序的完整路径； 【起始于】文本框中填的是Python编译器的目录； 好了，这就设置好了，定时任务就开始了~ ","link":"https://Wangrongsheng.github.io/post/xhSGxgIMT/"},{"title":"将博客或者文档部署在Coding上","content":" Coding简介 Coding 是一个面向开发者的云端开发平台，目前提供代码托管，运行空间，质量控制，项目管理等功能。此外，还提供社会化协作功能，包含了社交元素，方便开发者进行技术讨论和协作。 安装 配置SSH公钥 进入 Coding官网 ，进行注册或者登录； 关于如何获得密钥：将Git与GitHub进行SSH连接 ，然后打开Coidng个人设置---SSH公钥，点击新增公钥，将电脑上.ssh/id_rsa.pub文件里的所有内容全部复制过来即可； 可以打开终端输入ssh -T git@git.coding.net 来测试一下是否成功； 新建项目并创建静态Pages应用 点击页面上的加号里的项目选项，新建一个项目来存放以后的代码； 创建好了之后点击代码---Pages服务，新建一个Pages服务 ； 绑定个人域名 为Github Pages添加自定义域名 拓展 基于Github 和Coding 都可以部署自己的博客，但是Github 在国外访问还行，国内访问速度过慢，是不是我们可以将自己的（Hexo）博客同时部署在Github 和 Coding 上呢，我们可以在国外访问Github ，并且在国内访问Coding ： # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: - type: git #部署方式，统一填git repository: github: git@github.com:WangRongsheng/WangRongsheng.github.io.git # 填自己的 coding: git@git.dev.tencent.com:WangRongsheng/blog.git # 填自己的 branch: master #分支名称 ","link":"https://Wangrongsheng.github.io/post/6Ss2AWEJy/"},{"title":"为Github Pages添加自定义域名","content":" 把自定义域名的步骤进行记录-三步设置自定义域名。 1.获取博客的ip地址 首先是用ping命令找到存放你的github pages的主机的IP地址，在终端里面用命令ping xxx.github.io便可完成，下图中红框内的就是我们要找的IP地址： 2.域名解析 在购买域名的提供商为域名添加解析。我是在阿里云买的域名，因此我以阿里云的为例。在域名控制台选择想要绑定的域名，并点击解析： 然后添加如下两条记录： 3.Github仓库设置 在Github中，找到托管博客的xxx.github.io项目： 进入到设置页面，并滑动到下方，找到Github Pages这一栏，在Custom Domain填上刚刚添加解析的域名并保存： 到这儿就已经完成了，等待10分钟后就可以使用自定义的域名访问github pages所提供的页面了。 ","link":"https://Wangrongsheng.github.io/post/wTw0vWo80/"},{"title":"基于Gitbook+Github建立自己的项目文档","content":" Gitbook GitBook 是一个基于 Node.js 的命令行工具，可使用 Github/Git 和 Markdown来制作精美的电子书，GitBook 并非关于 [Git]的教程。 安装 脚手架安装 由于npm 安装较慢，所以我们采用另外一种方法： npm install -g cnpm --registry=https://registry.npm.taobao.org 然后再执行： cnpm install gitbook-cli -g 初始化 gitbook init 这个过程极其漫长，即使是npm淘宝源也很慢。当然你可以去百度一下，大佬们办法多的是。 创建一个book.json文件 给大家一个我的Demo（可以直接实用）： { &quot;title&quot;: &quot;王荣胜的gitbook&quot;, &quot;author&quot;: &quot;王荣胜&quot;, &quot;description&quot;: &quot;select * from learn&quot;, &quot;language&quot;: &quot;zh-hans&quot;, &quot;gitbook&quot;: &quot;3.2.3&quot;, &quot;styles&quot;: { &quot;website&quot;: &quot;./styles/website.css&quot; }, &quot;structure&quot;: { &quot;readme&quot;: &quot;README.md&quot; }, &quot;links&quot;: { &quot;sidebar&quot;: { &quot;我的博客&quot;: &quot;https://sqdxwz.com&quot; } }, &quot;plugins&quot;: [ &quot;-sharing&quot;, &quot;splitter&quot;, &quot;expandable-chapters-small&quot;, &quot;anchors&quot;, &quot;github&quot;, &quot;donate&quot;, &quot;sharing-plus&quot;, &quot;anchor-navigation-ex&quot;, &quot;favicon&quot; ], &quot;pluginsConfig&quot;: { &quot;github&quot;: { &quot;url&quot;: &quot;https://github.com/WangRongsheng&quot; }, &quot;donate&quot;: { &quot;alipay&quot;: &quot;./source/images/donate.png&quot;, &quot;title&quot;: &quot;&quot;, &quot;button&quot;: &quot;赞赏&quot;, &quot;alipayText&quot;: &quot; &quot; }, &quot;sharing&quot;: { &quot;douban&quot;: false, &quot;facebook&quot;: false, &quot;google&quot;: false, &quot;hatenaBookmark&quot;: false, &quot;instapaper&quot;: false, &quot;line&quot;: false, &quot;linkedin&quot;: false, &quot;messenger&quot;: false, &quot;pocket&quot;: false, &quot;qq&quot;: true, &quot;qzone&quot;: false, &quot;stumbleupon&quot;: false, &quot;twitter&quot;: true, &quot;viber&quot;: false, &quot;vk&quot;: false, &quot;weibo&quot;: true, &quot;whatsapp&quot;: false, &quot;all&quot;: [ &quot;google&quot;, &quot;facebook&quot;, &quot;weibo&quot;, &quot;twitter&quot;, &quot;qq&quot;, &quot;qzone&quot;, &quot;linkedin&quot;, &quot;pocket&quot; ] }, &quot;anchor-navigation-ex&quot;: { &quot;showLevel&quot;: false }, &quot;favicon&quot;:{ &quot;shortcut&quot;: &quot;./source/images/favicon.jpg&quot;, &quot;bookmark&quot;: &quot;./source/images/favicon.jpg&quot;, &quot;appleTouch&quot;: &quot;./source/images/apple-touch-icon.jpg&quot;, &quot;appleTouchMore&quot;: { &quot;120x120&quot;: &quot;./source/images/apple-touch-icon.jpg&quot;, &quot;180x180&quot;: &quot;./source/images/apple-touch-icon.jpg&quot; } } } } 里面有一些插件的说明，Gitbook 的插件安装需要把插件信息填在上面的文件里面，然后执行： gitbook install ./ 生成静态文档 执行： gitbook build 然后生成的_book 就是对应的网页文件夹。 发布 发布到Github Pages上； 发布到Netlify ； 参考 gitbook部署到服务器 GitBook运行报错 - Error: ENOENT: no such file or directory ","link":"https://Wangrongsheng.github.io/post/vIwtML1JW/"},{"title":"基于Plotly的在线作图","content":" 演示 参考 世界银行：https://data.worldbank.org.cn/ Plotly在线绘图：https://chart-studio.plot.ly/create/#/ Plotly学习：https://github.com/WangRongsheng/Plotly ","link":"https://Wangrongsheng.github.io/post/EIY23TNFl/"},{"title":"北京智源大会之旅","content":" 一、引言 这篇总结我早就想写了，但一直搁置，现在正在准备大二上学期的期末考试，晚上也不是很爱复习，就记个流水账吧！ 首先说一下我是如何知道的这个会议，我本来就是一个收集癖，平时没事就喜欢水水群啦，逛逛网站了，偶然间看到了2019年10.31-11.1的北京智源大会，因为大会时首次，并且与我的小爱好（人工智能）相关，同时票价在同等级的会议中对学生也算是很友好的，毅然决定去瞅瞅吧，大会的安排还是很丰富的： 看到大会的会议安排你是不是兴奋了？包括多个领域，大佬云集，出于这样的激动，我们（叫上了亲爱的舍友和一个班级的朋友）迅速的订车票，会议票，请假，出发了.... 二、日程 1、出发车程 我们在10月30日晚上坐上了去北京的火车，其实坐火车的痛苦，大家都是很清楚的，在车上发誓，以后永远不会再坐硬座火车了，累死人。 那天晚上在车上我睡了大概有2个小时（1：30-3-：30）吧，其实实际上来说，并没有这么多，身体劳累，但精神饱满，辉辉和浩浩的睡眠质量还行吧，至少比我多睡一会。在车上晚上睡觉的时候，每次停车都会感觉冷气从车门外袭来，不觉打个寒颤。在这种情况下，我们依然还是在晚上的劳累中商讨好了第二天的参会议程，去数理基础和机器学习基础专题听会（其实我是想去ai医疗那个比赛的，事实上我们最后确实去了）。 在车上的时候，凌晨4点多，车上的人纷纷的醒来（我们的车是5：30到达北京的），车上的好多的人都在吃饭或者准备吃饭，我不清楚是为什么，难道人也会在睡醒之后饿？但我觉得，北京太大了，大到每个人都向往，但每个人去到那里，却不一定能找到自己的生存空间，人，要生存啊！ 2、到达会场 10月31号早晨7点多我们就已经来到了国家会议中心，北京智源大会会场，对于头一次来北京的我，心里是激动和兴奋。 前台找接待小姐姐拿了自己的资料： 进入到会场内： 气势恢宏啊，有没有，感觉是非常喜欢的环境！ 3、开幕式 上午9：30开幕式正式开始，首先是智源院长进行的讲话，哈哈，好可爱的： 然后高文教授讲话： 我国在发展人工智能方面的优势和短板： 宣布开放一个代码托管平台（取代Github了要？）： 英文的巅峰对话（我实在听不懂，英语很重要啊）： 接下来就是我们这次最喜爱的讲解人了-朱松纯，提出了“由小数据大任务走向通用人工智能”： 论道AI的能与不能： 4、数理基础专题 5、晚间的happy时光 白天的一天懵逼，发誓晚上一定要出去逛逛： 鸟巢，水立方： IBM： 北京大学： 方正集团： 好了，其他照片不放了，真的好多呀~ 6、ai医疗 十强路演团队的项目： 比赛结果： 7、迈向第三代人工智能（闭幕式） 张院士闭幕式总结（2019年吴文俊奖获得者）： 8、回学校 辉辉的美照： 最后放几张北京天安门的美照吧： 三、总结 总的来说，学习到的东西还是挺多的，写一下吧： 1、路演技巧 ppt是用来看的，不需要我读给评委听。 重点的地方，标红，放大。 图，表，文字结合出现。 说话的时候慢，稳。 单页ppt全出，不加特效。 2、出门注意 学会计划 照顾他人 保护自己 3、两句话 凡事有得必有失，只要你觉得值得，那么没什么是不值得的。 不要让你目前所处的环境束缚了你。 4、花费 其实出门去趟北京觉得会很高，但是真正的去一次，其实并不会很高，比如我们的穷游，平均每人500左右，希望每个人都能出去多走走~ ","link":"https://Wangrongsheng.github.io/post/lpnQUc2Bj/"},{"title":"Python为什么成为人工智能的首选语言？","content":" 前言 之前一直都是在学习Python与机器学习，深度学习。但是究竟为什么在众多的编程语言中选择Python作为人工智能的首选语言呢我一直不得而知，今天就来以我的理解来梳理下吧。首先在我不再赘述Python的前世今生，只是深入的说一下Python与人工智能的关系。 从人工智能说起 首先人工智能话题的热度再度升起应该是开始于一个引发全民狂欢的科技新闻：2016年到2017年，谷歌开发的围棋AI程序AlphaGo接连击败欧洲冠军樊麾、韩国九段棋手李世石、世界围棋冠军柯洁，登顶地球之巅。此时距离深蓝在国际象棋中横扫人类选手刚好20年。几个月后，AlphaGo的升级版化名AlphaGo Zero卷土重来，仅仅通过3天的自我训练就击败了已经击败了李世石的AlphaGo Lee，经过40天的训练，又轻描淡写的击败了已经击败了柯洁的AlphaGo Master，没有一点防备，也没有一丝顾虑，围棋这个被认为是人类智慧遮羞布的领域就这样被机器按在地上狠狠摩擦，这也就彻底引发了舆论的狂欢。这个时候，许多人说人工智能的时代又一次到来... 在上面所说的是人工智能在游戏领域的应用，其实人工智能的应用还有很多，比如计算机视觉、语音识别、无人驾驶、自然语言处理、推荐系统等，在接下来，我们就重点讲讲我们本文的核心话题：Python为什么成为人工智能的首选语言吧。 Python成为人工智能的首选编程语言？ 首先我们需要明白一点，人工智能所有的核心算法，都是依赖C或者C++完成的，这些算法跑起来非常复杂，属于计算密集型任务，需要榨干硬件的每一分性能。而Python本身的性能只能说是可惜，Java的性能一直被人诟病，Python比Java还要更下一层楼，如果一个人黑Python，那么肯定是朝性能这个点狠揍。python在人工智能、深度学习等领域扮演的更多是一个工具人的角色，也就是发挥一个前端或者说“花瓶”的作用，Python虽然不快，但是它易学易用易推倒，你只需要拿Python做做可视化，调用下API接口，写写展示层的逻辑就完事了。现在的人工智能还处于人工智障阶段，快速搭建一个可以调用和迭代的原型比什么都重要。一些专门搞科研和算法的牛人精力都不在编程语言上，用Python能以最低的学习成本快速上手。 为什么不学习其他的低成本的编程语言呢？ Python的前期优势巨大，尤其是和人工智能相关的数据分析领域，Python更是深耕多年，早早占据了先机，像一些广受欢迎的数据分析框架：Numpy、Pandas等都是出自Python的手笔; 一些大型的互联网公司，比如谷歌和FaceBook对Python也是十分的钟爱，而这两家公司都是走在人工智能前沿的先锋，谷歌发布了深度学习框架TensorFlow，FaceBook推出的机器学习库PyTorch，都将Python放在了扛把子的位置; Python的学术圈和科研圈的渗透力度也远非其他语言可以相提并论，放着简单易学库多的Python不学，难道去学C++嘛，博士也是人，柿子也挑软的捏; 在美国，特朗普政府和奥巴马政府也花费大量金钱来推广计算机教育; 打铁还需自身硬，python语言也有其自己独特的优势: Python的定位是“优雅”、“明确”、“简单”，所以Python程序看上去总是简单易懂，初学者学Python，不但入门容易，而且将来深入下去，可以编写那些非常非常复杂的程序。 开发效率非常高，Python有非常强大的第三方库，基本上你想通过计算机实现任何功能，Python官方库里都有相应的模块进行支持，直接下载调用后，在基础库的基础上再进行开发，大大降低开发周期，避免重复造轮子。 高级语言————当你用Python语言编写程序的时候，你无需考虑诸如如何管理你的程序使用的内存一类的底层细节 可移植性————由于它的开源本质，Python已经被移植在许多平台上（经过改动使它能够工 作在不同平台上）。如果你小心地避免使用依赖于系统的特性，那么你的所有Python程序无需修改就几乎可以在市场上所有的系统平台上运行 可扩展性————如果你需要你的一段关键代码运行得更快或者希望某些算法不公开，你可以把你的部分程序用C或C++编写，然后在你的Python程序中使用它们。 可嵌入性————你可以把Python嵌入你的C/C++程序，从而向你的程序用户提供脚本功能。 其他补充 Python在一些公司的应用： 谷歌：Google App Engine 、code.google.com 、Google earth 、谷歌爬虫、Google广告等项目都在大量使用Python开发 CIA: 美国中情局网站就是用Python开发的 NASA: 美国航天局(NASA)大量使用Python进行数据分析和运算 YouTube:世界上最大的视频网站YouTube就是用Python开发的 Dropbox:美国最大的在线云存储网站，全部用Python实现，每天网站处理10亿个文件的上传和下载 Instagram:美国最大的图片分享社交网站，每天超过3千万张照片被分享，全部用python开发 Facebook:大量的基础库均通过Python实现的 Redhat: 世界上最流行的Linux发行版本中的yum包管理工具就是用python开发的 豆瓣: 公司几乎所有的业务均是通过Python开发的 知乎: 国内最大的问答社区，通过Python开发(国外Quora) 春雨医生：国内知名的在线医疗网站是用Python开发的 除上面之外，还有搜狐、金山、腾讯、盛大、网易、百度、阿里、淘宝 、土豆、新浪、果壳等公司都在使用Python完成各种各样的任务。 Python的缺点: 速度慢，Python 的运行速度相比C语言确实慢很多，跟JAVA相比也要慢一些，因此这也是很多所谓的大牛不屑于使用Python的主要原因，但其实这里所指的运行速度慢在大多数情况下用户是无法直接感知到的，必须借助测试工具才能体现出来，比如你用C运一个程序花了0.1s,用Python是0.01s,这样C语言直接比Python快了10s,算是非常夸张了，但是你是无法直接通过肉眼感知的，因为一个正常人所能感知的时间最小单位是0.15-0.4s左右，哈哈。其实在大多数情况下Python已经完全可以满足你对程序速度的要求，除非你要写对速度要求极高的搜索引擎等，这种情况下，当然还是建议你用C去实现的。 代码不能加密，因为PYTHON是解释性语言，它的源码都是以名文形式存放的，不过我不认为这算是一个缺点，如果你的项目要求源代码必须是加密的，那你一开始就不应该用Python来去实现。 线程不能利用多CPU问题，这是Python被人诟病最多的一个缺点，GIL即全局解释器锁（Global Interpreter Lock），是计算机程序设计语言解释器用于同步线程的工具，使得任何时刻仅有一个线程在执行，Python的线程是操作系统的原生线程。在Linux上为pthread，在Windows上为Win thread，完全由操作系统调度线程的执行。一个python解释器进程内有一条主线程，以及多条用户程序的执行线程。即使在多核CPU平台上，由于GIL的存在，所以禁止多线程的并行执行。关于这个问题的折衷解决方法，我们在以后线程和进程章节里再进行详细探讨。 ","link":"https://Wangrongsheng.github.io/post/sWGpijx_J/"},{"title":"国内开源镜像汇总","content":" 声明：全部资源最终为2018年汇总完成，后期如果出现不可使用的开源镜像网站请大家再自行更换！ 一、站点版 A、企业站 搜狐：http://mirrors.sohu.com/ 网易：http://mirrors.163.com/ 阿里：http://mirrors.aliyun.com/ 华为：https://mirrors.huaweicloud.com/ B、教育站 上海交通大学：http://ftp.sjtu.edu.cn/html/resources.xml（部分移动运营商出口状况不佳，无法访问） 华中科技大学：http://mirror.hust.edu.cn/（当前已用容量估计：4.83T） 清华大学：http://mirrors.tuna.tsinghua.edu.cn/（当前已用容量估计：9.8T） 北京理工大学：http://mirror.bit.edu.cn/web/ 兰州大学：http://mirror.lzu.edu.cn/ 中国科技大学：http://mirrors.ustc.edu.cn/（当前已用容量估计：21.32T） 大连东软信息学院：http://mirrors.neusoft.edu.cn/（当前已用容量估计：2.5T） 东北大学：http://mirror.neu.edu.cn/ 大连理工大学：http://mirror.dlut.edu.cn/ 哈尔滨工业大学：http://run.hit.edu.cn/html/（部分联通运营商出口状况不佳，无法访问） 北京交通大学：http://mirror.bjtu.edu.cn/cn/ 中国地质大学：http://mirrors.cug.edu.cn/（当前已用容量估计：2.3T） 浙江大学：http://mirrors.zju.edu.cn/ 厦门大学：http://mirrors.xmu.edu.cn/ 中山大学：http://mirror.sysu.edu.cn/ 重庆大学：http://mirrors.cqu.edu.cn/（当前已用容量估计：3.93T） 北京化工大学：http://ubuntu.buct.edu.cn/（AndroidSDK镜像仅供校内使用，当前已用容量估计：1.72T） 南阳理工学院：http://mirror.nyist.edu.cn/ 中国科学院：http://www.opencas.org/mirrors/ 电子科技大学星辰工作室：http://mirrors.stuhome.net/（当前已用容量估计：1.08T） 西北农林科技大学：http://mirrors.nwsuaf.edu.cn/（只做CentOS镜像，当前已用容量估计：140GB） C、C、其他站 首都在线科技股份有限公司（英文名CapitalOnlineDataService）：http://mirrors.yun-idc.com/ 中国电信天翼云：http://mirrors.ctyun.cn/ 常州贝特康姆软件技术有限公司：http://centos.bitcomm.cn/（只做CentOS镜像，当前已用容量估计：140GB） 公云PubYun（母公司为贝特康姆）：http://mirrors.pubyun.com/ 中国互联网络信息中心：http://mirrors.cnnic.cn/（只做Apache镜像，当前已用容量估计：120GB） Fayea工作室：http://apache.fayea.com/（只做Apache镜像，当前已用容量估计：120GB） 二、软件版 A、操作系统类 1、Ubuntu 阿里云：http://mirrors.aliyun.com/ubuntu-releases/ 网易：http://mirrors.163.com/ubuntu-releases/ 搜狐：http://mirrors.sohu.com/ubuntu-releases/（搜狐在12年之后似乎不同步了） 首都在线科技股份有限公司：http://mirrors.yun-idc.com/ubuntu-releases/ 2、CentOS 网易：http://mirrors.163.com/centos/ 搜狐：http://mirrors.sohu.com/centos/ 阿里云：http://mirrors.aliyun.com/centos/ B、操作系统类 1、Tomcat、Apache 中国互联网络信息中心：http://mirrors.cnnic.cn/apache/ 华中科技大学：http://mirrors.hust.edu.cn/apache/ 北京理工大学：http://mirror.bit.edu.cn/apache/ 2、MySQL 北京理工大学：http://mirror.bit.edu.cn/mysql/Downloads/ 中国电信天翼云：http://mirrors.ctyun.cn/Mysql/ 3、PostgreSQL 浙江大学：http://mirrors.zju.edu.cn/postgresql/ 4、MariaDB 中国电信天翼云：http://mirrors.ctyun.cn/MariaDB/ 5、VideoLAN 大连东软信息学院：http://mirrors.neusoft.edu.cn/videolan/ 中国科技大学：http://mirrors.ustc.edu.cn/videolan-ftp/ C、开发工具类 1、Eclipse 中国科技大学：http://mirrors.ustc.edu.cn/eclipse/ 中国科学院：http://mirrors.opencas.cn/eclipse/ 东北大学A：http://ftp.neu.edu.cn/mirrors/eclipse/ 东北大学B：http://mirror.neu.edu.cn/eclipse/ 2、安卓SDK 中国科学院：http://mirrors.opencas.ac.cn/android/repository/ 南洋理工学院：http://mirror.nyist.edu.cn/android/repository/ 中国科学院：http://mirrors.opencas.cn/android/repository/ 大连东软信息学院：http://mirrors.neusoft.edu.cn/android/repository/（同步效果不如中科院的镜像，不推荐） 三、官方镜像列表状态地址 CentOS：http://mirror-status.centos.org/#cn Archlinux：https://www.archlinux.org/mirrors/status/ Ubuntu：https://launchpad.net/ubuntu/+cdmirrors Debian：http://mirror.debian.org/status.html FedoraLinux/FedoraEPEL：https://admin.fedoraproject.org/mirrormanager/mirrors Apache：http://www.apache.org/mirrors/#cn Cygwin：https://www.cygwin.com/mirrors.html ","link":"https://Wangrongsheng.github.io/post/5mN6ImO5v/"},{"title":"Github高级搜索","content":" 搜索条件 使用例子 备注 location: location:china 匹配填写的地址在china的开发者 language: language:python 匹配开发语言为python的项目 followers: followers:&gt;=1000 匹配拥有超过1000名关注着的项目 in:name in:name WangRongsheng 匹配用户名为WangRongsheng的开发者 in:descripton in:descripton python 匹配仓库描述里面有python的项目 in:readme in:readme python 匹配README描述中有python的项目 stars: stars:&gt;=500 匹配收藏数量超过500的项目 forks: forks:&gt;=500；forks: 10..20 匹配分支数量超过500的项目；匹配分支数量为10-20的项目 size: size:&gt;=5000 匹配仓库大于5000KB的仓库 created: created:&gt;2019-01-01 匹配2019年以后创建的仓库 pushed: pushed:&gt;2019-01-01 匹配仓库最近一次提交在2019年以后的仓库 license: license:apache-2.0 匹配使用 apache-2.0 协议的仓库 user: user:google 匹配用户google 上传的仓库 org: org:spring-cloud 匹配列出org的spring-cloud仓库 Awesome + 关键字 神奇关键字 帮助找到优秀的工具列表 除此之外，这些指令都可以组合搜索。 ","link":"https://Wangrongsheng.github.io/post/DLFfKvF_p/"},{"title":"Github界面简介","content":" GitHub界面简介 常驻工具栏 Github网站上方，会有一个常驻工具栏，在首页和在仓库，工具栏会稍微有些许不同： 首页： 我们从左往右说： Github的LOGO：点击会进入首页； 搜索窗口：输入想要查找的用户、仓库或代码片段，如果在仓库中搜索，则是搜索的本仓库； Pull requests：显示用户已经经行过的合并请求，开发者可以很方便的追踪合并请求的后续情况； Issues：查看用户有权限的仓库的问题或者分配给自己的问题。 Marketplace：罗列了各种可以与 Github 集成的服务，开发需要什么在线服务去找就可以； Explore：根据你的兴趣为你推荐一些东西； 一个小铃铛图标：显示你未读的信息； 这里点击会出现下拉列表，可以创建新的仓库，导入新的仓库，创建新的Gist，新的组织成员、创建新的项目： 最后是个人信息，点击后会出现： 可以选择进入你的个人档案，你的stars项目，设置，登出等等操作。 仓库界面 我们打交道最多的还是仓库界面，我们打开一个仓库： 用户名/仓库名； watch:点击即可watch该仓库，今后该仓库的更新信息都会显示在用户的公开活动中； star:点击表示对该仓库关注，star越多，表示仓库越受关注； fork:点击，即可fork该仓库； code:该仓库的文件列表； issues:用于BUG报告，功能添加，方向性讨论等； pull requests:查看合并请求，代码的更改和讨论都可以在这里进行； projects:项目管理工具，对项目整个开发周期进行管理； wiki:记录开发者之间应该共享的信息或者软件文档； commits:查看当前分支的提交历史； branches:查看仓库的分支列表； releases:显示仓库的标签列表，可以将标签加入时的文件以归档形式下载到本地。软件在版本升级时一般都会打标签，如果需要特定版本，可以从这里查找； contributors:对该仓库进行过提交的程序员名单； branch:显示当前分支的名称，从这里可以切换仓库内的分支，查看其他分支文件； new pull request:新的合并请求； create new file:创建新的文件； upload files:上传文件； find file:查找文件； clone or download:克隆当前项目或者下载； clone in desktop:通过github专用客户端进行克隆； download zip:将当前分支中的文件以zip形式下载； 当前分支的文件，顶部为最新的提交信息，左边是文件名称，中间是提交日志，右边是提交日期； actions:持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器，发布到第三方服务等等，GitHub 把这些操作就称为 actions；Github Actions入门教程 security； insights:以图标的形式显示该仓库的各种指标； settings:可以修改仓库名称、删除仓库等； packages：类似npm包管理工具或平台； edit:编辑书写仓库的基本信息和一些链接； ","link":"https://Wangrongsheng.github.io/post/A5LBCRXBu/"},{"title":"Linux常用命令","content":" Linux简介 Linux是目前应用最广泛的服务器操作系统，基于Unix，开源免费，由于系统的稳定性和安全性，市场占有率很高，几乎成为程序代码运行的最佳系统环境。 linux不仅可以长时间的运行我们编写的程序代码，还可以安装在各种计算机硬件设备中，如手机、路由器等，Android程序最底层就是运行在linux系统上的。 linux常用命令 命令格式：命令 -选项 参数 （选项和参数可以为空） 如：ls -la /usr 操作文件及目录 命令 参数 示例 说明 cd cd /home 切换目录 pwd pwd 显示当前工作目录目录 touch touch 1.txt 创建空文件 mkdir mkdir testdir 创建一个新目录 -p mkidr -p dir1/dir2/dir3/ 创建多级目录，父目录不存在情况下先生成父目录 cp cp 1.txt 复制文件或目录 -r cp -r dir1/ 递归处理，将指定目录下的文件与子目录一并拷贝 mv mv dir1 dir2 移动文件或目录、文件或目录改名 rm rm 1.txt 删除文件 -r rm -rf dir1 r同时删除该目录下的所有文件 -f rm -rf dir1 f强制删除文件或目录 rmdir rmdir dir1 删除空目录 cat cat 1.txt 显示文本文件内容 more more 1.txt 分页显示文本文件内容，可前后翻页，空格向后，b向前 less less 1.txt 分页显示文本文件内容，可前后翻页，空格向后，b向前，支持底行模式（后面介绍） head head 1.txt 查看文本开头部分，默认十行 -[num] head -20 1.txt 查看文本开头部分指定行数 tail tail 1.txt 查看文本结尾部分，默认十行 -[num] tail -20 1.txt 查看文本结尾部分指定行数 -f tail -f 1.txt 循环滚动读取文件并动态显示在屏幕上，根据文件属性追踪 -F tail -F 1.txt 循环滚动读取文件并动态显示在屏幕上，文件文件名追踪 wc wc 1.txt 统计文本的行数、字数、字符数 -m wc -m 1.txt 字符数 -w wc -w 1.txt 文本字数 -l wc -l 1.txt 文本行数 find -name find / -name 1.txt 在文件系统中的指定目录下查找指定的文件 grep grep aaa 1.txt 在指定文件中查找包含指定内容的行，例：在1.txt中查找包含aaa的所有行 ln ln 1.txt 1_bak.txt 建立链接文件 -s ln -s 1.txt 1_bak.txt 对源文件建立符号连接，而非硬连接 系统常用命令 命令 参数 示例 说明 top top 显示当前系统中耗费资源最多的进程 date date 显示系统当前时间 ps 较少单独使用，配参数根据需求，ps -ef 或者ps-aux -e /-A ps -e 显示所有进程，环境变量 -f ps -ef 全格式显示 -a ps -a 显示所有用户的所有进程（包括其它用户） -u ps -au 按用户名和启动时间的顺序来显示进程 -x ps -aux 显示无控制终端的进程 kill -9 kill -9 pid 强制杀死一个进程 df df 显示文件系统磁盘空间的使用情况 -h df -h 以人类可读的方式显示，Kb，Mb，GB等 du 显示指定的目录及其子目录已使用的磁盘空间的总和 -s du -s * 进显示指定目录的总和，星号当前目录下表示所有 -h du -sh * 以人类可读的方式显示，Kb，Mb，GB等 free free 显示当前内存和交换空间的使用情况 ifconfig ifconfig 网卡网络配置，常用于查看当前IP地址 ifconfig eth0 192.168.12.22 临时修改系统IP（重启后失效） ping ping baidu.com 测试网络的连通性 hostname hostname 查看主机名 shutdown -r shutdown -r 先关机，再重启 -h shutdown -h 关机后不重启 halt halt 关机后关闭电源，相当于shutdown -h reboot reboot 重新启动 相当于shutdown -r 压缩解压缩 命令 参数 示例 说明 gzip gzip 1.txt 压缩后面的文件或者文件夹 -d gzip -d 1.txt.gz 解压后面的压缩文件 -[num] gzip -9 1.txt 用指定的数字num调整压缩的速度，-1或--fast表示最快压缩方法（低压缩比），-9或--best表示最慢压缩方法（高压缩比）。系统缺省值为6 tar -c tar -cvf 1.tar 1.txt 建立一个压缩文件的参数指令，例，将1.txt压缩为1.tar，也可指定多个文件或文件夹 -x tar -xvf 1.tar 1.txt 解开一个压缩文件的参数指令 -z tar -zcvf 1.tar.gz 1.txt / tar -zxvf 1.tar.gz 1.txt 是否需要用 gzip ，使用gzip压缩或解压 -v 压缩的过程中显示文件 -f 使用档名，在 f 之后要立即接档名 修改目录下所有文件及子目录的所属用户和组，用数字来表示权限（r=4，w=2，x=1，-=0）| linux系统常用快捷键及符号命令 命令 参数 示例 说明 ctrl + c 停止进程 ctrl + l 清屏 ctrl + r 搜索历史命令 ctrl + q 退出 tab 自动补全 &gt; echo &quot;haha&quot; &gt; 1.txt 将前一条命令的输出，写入到后面的文本中，将文本清空，然后写入 &gt;&gt; echo &quot;lala&quot; &gt;&gt; 1.txt 将前一条命令的输出，写入到后面的文本中，不清空文本，追加到文本最后 cat 1.txt * 通配符，指所有 参考 Linux常用命令 Linux常用命令详解 ","link":"https://Wangrongsheng.github.io/post/FeHg74BBn/"},{"title":"什么是博士？","content":" 先想象可以包含人类所有知识的一个圆： Imagine a circle that contains all of human knowledge: 当你小学毕业的时候，你了解的知识没有多少： By the time you finish elementary school, you know a little: 当你中学毕业的时候，你掌握的知识稍微多了点： By the time you finish high school, you know a bit more: 当你获得学士学位的时候，你获得了一项特长： With a bachelor's degree, you gain a specialty: 而硕士学位使得你的特长更加扎实： A master's degree deepens that specialty: 通过阅读研究相关的论文你可以了解人类知识的边缘所在： Reading research papers takes you to the edge of human knowledge: 当你处在人类知识的边缘时，你就需要专注一点进行研究了： Once you're at the boundary, you focus: 你需要在这个边缘地点进行数年的努力钻研： You push at the boundary for a few years: 直到有一天，你突破了边缘的限制： Until one day, the boundary gives way: 那时，你所完成的那个小突破（凹坑）就叫做“博士”： And, that dent you've made is called a Ph.D.: 当然，此时你看到的世界与之前的感觉已经有了大不同： Of course, the world looks different to you now: 所以，别忘记了整个图景 （不要以个人的经验随意扩大，勿认为你经历的就是整个世界的样子）： So, don't forget the bigger picture: 还需记得，即便拿到了博士学位，也要一直努力哈。 Keep pushing. 参考：http://matt.might.net/articles/phd-school-in-pictures/ ","link":"https://Wangrongsheng.github.io/post/QItHcA_x2/"},{"title":"Windows10下Linux子系统安装docker","content":" 记录自己安装docker 的过程 ​安装完子系统后，按win键加R键， 输入cmd-&gt;回车 Windows 10安装Linux子系统方法 ​打开cmd 后输入 bash.exe 回车就进入了子系统 接下来正式开始 docker 的安装啦 依次执行命令： sudo apt-get update curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; 使用以下命令更新apt软件包索引并安装最新版本的Docker CE sudo apt-get install docker-ce docker-ce-cli containerd.io 这就已经安装好了 输入docker 看看安装好没 ","link":"https://Wangrongsheng.github.io/post/ACUm1Inji/"},{"title":"获取GoogleDrive无限网盘","content":" 首先登陆Google账号 Google 登陆成功后 进入GoogleDrive 我们进入到自己的 drive 中后，是只有一个 我的云端硬盘 并且只有15GB的空间 接下来我们新建一个页面访问 https://gd.zxd.workers.dev/ 这是一个 GitHub项目 有兴趣的可以去看看，原理是通过js去创建一个 团队网盘 打开链接后需要填入相关信息，邮箱填写你自己的 信息填好后 点击 提交 ，稍微等待一小会，会弹出成功的提示 现在就可以关闭当前这个页面了，回到刚刚登陆的 GoogleDrive 会发现 刚刚的15GB还是15GB ,但是多了一个共享的网盘 我们可以看看管理信息 里面就你一个人是，并且是管理员。 至于那个档案所属域，我看代码里面好像是一个变量设置的，也不清楚是不是属于另外一个账号，所以这个共享的网盘，我们可以放放大容量的电影，镜像文件啥的，私密性的数据千万不要放，当然，无论是 GoogleDrive还是百度云，其实任何数据只要一上云就会有泄漏的风险，最保险的就是自己搭建NAS私有云。 ","link":"https://Wangrongsheng.github.io/post/UOmpH-YXf/"},{"title":"Github学生包申请","content":" 从今天开始，我也是成为有Pro的人了~ PRO是什么？ 是由Github提供的学生开发包，享受众多福粒吧，从共同开发工具，教育平台，资源平台，代码编辑器，独立域名，甚至连制作引擎都有。 怎么申请PRO？ 首先，我是由于第一次申请踩了不少坑： (失败了两次，前后经历了超过一个月 的等待~惨...) 进到官网 Github学生包申请地址 然后点击Get benefits for students 填写表单 表单的话大概是这个样子的： Which best describes your academic status? 这里分为两种： Students：学生身份，个人申请； Faculty：学院； 在这里我们要选择Students，但是也有几个约束条件： 目前正在接受能获得学位或文凭的教育，例如高中，中学，大学，大学，家庭学校或类似的教育机构； 具有学校核发的可验证电子邮件地址或能够证明您当前学生身份的文件； 有一个GitHub用户帐户； 至少13岁； What e-mail address do you use for school? 这里可以填写自己的个人邮箱或者学校邮箱，如果你拥有学校邮箱请一定要使用学校邮箱 ，因为可以快速的认证你的身份，在短时间内实现Pro的认证。 We need all faculty to send additional proof of academic status. 如果你上一步中使用的是个人邮箱 ，这里你就要注意了，你出示的学生身份证明（入学通知书、学生证等都算为证明材料）必须要认真、仔细，以便于让他们完成识别，否则不予以通过； 如果上一步中你使用了学校邮箱 ，你可以随便的拍一张学生证或者成绩单作为资料上传就可以了； How do you plan to use GitHub? 这里的话你可以随便写写你的想法，或者我给你提供几个模板使用，直接复制粘贴提交就好了： Contribute to other open source projects. GitHub has a very nice way of making people learn to give credits to someone’s code if they are using it. Learn those etiquettes Star cool projects or lists. Staring is a kind of bookmarking on GitHub Follow people, you feel, you can learn something from their activity and if you want to use GitHub as a socialnetwork 等待结果 如果成功了你应该会收到一封来自Github的邮件，但我并没有收到，我是通过Github学生包申请地址 侧边栏看到的通过，除此之外你还可以通过去自己的Github 主页查看是不是亮起了Pro的图标~ 申请没有被批准？ GitHub Student Developer Pack应用程序未获得批准的常见原因： 学业隶属文件不清 如果你上传的图片不能清楚地表明你目前的学业状况，我们需要你的学业状况的进一步证明。当你重新申请时，上传一张你的学生卡、成绩单或其他文件的图片，显示你的学业状况，并其文件上有至少一个日期。 注意： 不支持PDF文件，您不能将其作为从属关系的证明上载。 使用未经验证的域的学校电子邮件 如果您的学术电子邮件地址有一个未经验证的域名，我们需要进一步证明您的学术地位。当你重新申请时，上传一张你的学生卡、成绩单或其他文件的图片，显示你的学业状况，并其文件上有至少一个日期。 使用学校提供的学术电子邮件，且电子邮件政策不严格 如果您的学校在学生入学之前发出电子邮件地址，我们需要您的学历进一步证明。重新申请时，请上传您的学校ID，成绩单或其他文件的图像，以证明您的学业状况证明至少清楚地显示了一个日期。（我觉得应该是你还没入学就知道了学生邮箱的格式？） 术电子邮件地址已被使用 如果您的学术电子邮件地址已经用于其他GitHub帐户的GitHub学生开发工具包，占用账户的学生折扣到期才可以使用。 注意： 维护多个个人帐户是违反GitHub服务条款的。 如果您有多个个人用户帐户，则必须合并您的帐户。要保留折扣，请保留授予学生折扣的帐户。您可以重命名想要保留的帐户，并通过将所有电子邮件地址添加到保留的帐户上来保存您其他账号的数据。 不合格的学生身份 以下条件，则您没有资格获得GitHub Student Developer Pack： 您已加入非正式学习计划，该计划不属于GitHub校园计划，也未参与授予学位或文凭的学习课程。 您不到13岁。 您的讲师仍可以申请GitHub教育折扣，供课堂使用。如果您是编程培训学校或训练营的学生，如果您的培训学校加入GitHub校园计划，您仍有资格获得GitHub学生开发包。 参考 Github学生计划申请的一些经验分享(2018) ","link":"https://Wangrongsheng.github.io/post/V56Ke3xWB/"},{"title":"深度学习图像数据标注-Labelme","content":" Labelme简介 LabelMe 是一个用于在线图像标注的 Javascript 标注工具。与传统图像标注工具相比，其优势在于我们可以在任意地方使用该工具。此外，它也可以帮助我们标注图像，不需要在电脑中安装或复制大型数据集。 安装使用 安装labelme 所有操作在已经安装Anaconda环境下运行：Anaconda3 Win10安装教程 打开Anaconda3自带的Anaconda Prompt； 创建一个虚拟的py环境： conda create –name=labelme python=3.6 安装pyqt： conda install pyqt 安装labelme： pip install labelme -i https://pypi.tuna.tsinghua.edu.cn/simple 这里我进行了换源 ，原因是因为安装速度过慢！ 左侧选项依次是： 打开文件、打开目录、下一张、上一张、保存、创建多边形、编辑多边形、复制、删除、撤销操作、图片放大… 中间是： 图片区域 右边显示的有： flags、标签名称列表、多边形标注、图片文件列表 顶部菜单栏： 文件、编辑、视图、帮助 使用labelme 此处打开一个图片文件夹做示范： 点击左侧Open Dir选择需要标注的数据文件夹。 在顶部 edit 菜单栏中可选不同的标记方案，依次为：多边形（默认），矩形，圆、直线，点。 制作图像分割的数据，选择多边形，点击左侧的 create polygons ，回到图片，按下鼠标左键会生成一个点，完成标注后会形成一个标注区域，同时弹出labelme的框，键入标签名字，点击 OK或者回车完成标注。 如果需要更改标注的数据，可以选择左侧的编辑框，或者把鼠标移动到标签上，点击鼠标右键，可以选择编辑标签或者标注的名字。在编辑模式下，把鼠标移动到边界上，右键，可以增加点。 标注完成后点击Save保存。会在图片路径下生成同名的json文件。在目录下打开终端键入： labelme_json_to_dataset &lt;文件名&gt;.json 会把生成的json转化成对应的数据文件： *.png info.yaml label.png label_names.txt label_viz.png 如果这里你嫌弃一个一个转化json文件太麻烦的话可以进行批量转化： 利用labelme批量转换.json文件 也可以利用我写的一个python脚本： import os path = './&lt;文件名称&gt;' # path为json文件存放的路径 json_file = os.listdir(path) os.system(&quot;activate labelme&quot;) for file in json_file: os.system(&quot;labelme_json_to_dataset.exe %s&quot;%(path + '/' + file)) 注意：要把所有的json文件放在同一个文件夹哦！ 参考 win10下 Anaconda使用conda连接网络出现错误(CondaHTTPError: HTTP 000 CONNECTION FAILED for url） labeme批量转化json 未生成info.yaml解决办法 官方项目地址 数据标注软件labelme详解 ","link":"https://Wangrongsheng.github.io/post/BkTcHSj7m/"},{"title":"如果你将要面临地震...","content":" 地震前预兆 发生大的地震前几天或者几小时前一般都会有很多小地震，而且非常频繁，这种地震我们称之为前震。所以，发生一系列前震时大家一定要有警觉意识啦！ 地震来前有些动物会有异常表现，例如：老鼠会疯了似的满街乱跑；蜻蜓会一群群的飞到其它地方去；鱼儿会浮到水面上打旋儿；特别是蜜蜂，它会抛离巢跑出来到处蜇人等等。 由于地震来时伴有磁波。因此一些植物也会受此影响，比如说含羞草：在强烈地震发生的几小时前，它的叶子会突然萎缩，然后枯萎。还有，在正常情况下，害羞草的叶子都是白天张开，晚上闭合，如何发生白天闭合，晚上张开，这就说明地震随后就来。所以，大家可以在家里养一盆含羞草。 地震来之前，也会发生反常的大气物理现象。或是暴风或是大雪‘怪风亦或是大涝，有时候也会是骤然增温诸如此类的大气反常变化等等。 地震来临之前人们 可以看见天空发光的现象，并且颜色各异，有红、黄、蓝、白、紫等，这就是地光，震前地光现象是非常突出的。汶川地震来临时天空上就出现了地光，但大家都没在意只当是好看的景象后来就真的地震发生了。 地震来临前多有地声从地面传来。地震前几天或前几小时甚至前几分钟往往有声音从地底下传来，如果传来的声音越大，越响，音调越沉闷就说明地震越大，反之则越小。 地震时避险 在家中 在房屋里，赶快到安全的地方，如躲到书桌、工作台、床底下。单元楼内，可选择面积小的卫生间、墙角，减小伤亡。对于户外开阔，住平房的居民，震时可头顶被子、枕头或安全帽逃出户外，来不及时，最好在室内避震，要注意远离窗户，趴下时头靠墙，枕在横着的双臂上面，闭上眼和嘴，待地震再沉着离开。 如果在平房里，快速撤离，地震发生后，建筑物不会马上倒塌，一般都要间隔10秒左右的时间，这就是“黄金12秒”，在这个时间里，平房的人迅速撤离，如房屋摇晃，可用枕头捂住头部，以防砸伤。如果在楼房里，来不及撤离，我们采取的最科学有效的避震方法就是就近躲避，震后再迅速撤离。 地震时，门框会因变形而打不开，所以，在防震期间最好不要关门。 地震时，如已被砸伤或埋在倒塌物下面，应先观察周围环境，寻找通道想办法出去。若无通道，则要保存体力，静听外面的动静，可敲击铁管或墙壁使声音传出去，以便救援。 在室外 地震时在户外的人，千万不能冒着大地的震动进屋去救亲人，只能等地震过后，再对他们及时抢救。 如果你正行走在高楼旁的人行道上，要迅速躲到高楼的门口处，以防碎片掉下来砸伤。 汽车司机要就地刹车。 如果在山坡上感到地震发生，千万不要跟着滚石往山下跑，应躲在山坡上隆起的小山包背后，同时要远离陡崖峭壁，防止崩塌、滑坡和泥石流的威胁。 在海边，如发现海水突然后退，比退潮更快、更低，就要注意海啸的突然袭击，尽快向高处转移。 在工作岗位 地震时，在办公楼的工作人员，要赶紧躲在办公桌下面。 在厂区上班的工人，地震时，要立即关闭机器、断掉电源，迅速躲到车床、机床及高大的设备下。 在公共场所 如果你在影剧院、体育馆等处遇到地震，要沉着冷静，特别是断电时，应就地蹲下或躲在排椅下，注意避开吊灯、电扇等悬挂物，用皮包等物保护头部。 地震时，你正在商场、书店、展览馆等处，应选择结实的柜台、商品或柱子边，以及内墙角处就地蹲下，用手或其他东西护头，避开玻璃门窗和玻璃橱窗。 正在上课的学生，要在老师的指挥下迅速抱头、闭眼，躲在各自的课桌下。 地震中的自救互救 被埋压在废墟下时，不能在精神上发生崩溃，要有勇气和毅力。 被压埋后，注意用湿手巾、衣服等捂住口鼻和头部，避免灰尘呛闷发生窒息，尽量消除压在身上的各种物体，用周围可搬动的物品支撑身体上面的重物，扩大活动空间，保障有足够的空气。条件允许时设法逃避险境。 被埋压后，要注意观察周围环境，寻找通道，设法爬出去，无法爬出去时，不要大声呼喊，当听到外面有人时再呼叫，或敲击出声，向外界传信息求救。 无法脱险时，尽量减少体力消耗，想办法与外面援救人员取得联系。 ","link":"https://Wangrongsheng.github.io/post/FaE9wIDmO/"},{"title":"代码注释规则","content":" 注释原则 项目开发中，尽量保持代码注释规范和统一。 注释方便了代码的阅读和维护。 边写代码边注释，修改代码时要相应修改注释，保证注释和代码的一致性。 注释要简洁明确，不要出现形容词。 通过注释可以快速知道所写函数的功能，返回值，参数的使用。 我们以C语言代码为例子进行注释学习。 文件头部注释 /******************************************************************************** * @File name: demo.c * @Author: WangRongsheng * @Version: 1.0 * @Date: 2020-3-10 * @Description: test. ********************************************************************************/ 还可以增加：版权说明等。 如果你进行了代码的修改 ，你需要重新写注释： /******************************************************************************** * @File name: demo.c * @Author: WangRongsheng * @Version: 1.0 * @Date: 2020-3-10 * @Description: test. * @Modifier（修改人）：张三 * @Modification time（修改时间）：2001-02-16 * @Modify content（修改内容）：新增 ********************************************************************************/ 结构体、全局变量等的注释 int num; /*全局变量的作用*/ /*结构体的功能*/ typedef struct{ int h; /*High risk*/ int l; /*Low risk*/ int m; /*Middle risk*/ int i; /*Information risk*/ }risk; 函数注释 函数头部应进行注释，列出：函数的目的/功能、输入参数、输出参数、返回值、调用关系（函数、表）等 /******************************************************* * * Function name ：insert_hhistory * Description : Insert to bd_host_history * Parameter ： * @ipsql SQL statement * @host_level Risk level * @total The total number of risk * @t_id task id * @t_uuid task uuid * @ipaddr target ipaddr * @end_time task end time * Return ：0 success , other fail **********************************************************/ int insert_hhistory(char* ipsql,risk host_level,int total,int t_id,char* t_uuid,char* ipaddr,long int end_time) { /* * 如果程序过于复杂，这里可以写明，具体算法和思路。 */ } 建议 一般情况下，源程序有效注释量必须在20％以上。 注释不宜太多、不宜太少，准确易懂简洁； 注释格式尽量统一，建议使用“/* …… */”； 避免在一行代码或表达式的中间插入注释； 说明：除非必要，不应在代码或表达中间插入注释， 否则容易使代码可理解性变差。 通过对函数或过程、变量、结构等正确的命名以及合理地组织代码的结构，使代码成为自注释的。 说明：清晰 准确的函数、变量等的命名，可增加代码可读性，并减少不必要的注释。 在代码的功能、意图层次上进行注释，提供有用、额外的信息。 说明：注释的目的是解释代码的目的、功能和采用的方法，提供代码以外的信息，帮助读者理解代码，防止没必要的重复注释信息。 ","link":"https://Wangrongsheng.github.io/post/-cBKkNdSS/"},{"title":"让你的博客增加邮件订阅功能 – RSSMailer","content":" 简介 作为一个独立博客的博主，能让用户第一时间接收到新文章的推送是很有必要的。自从 QQ 邮件列表功能只能公司注册之后，很多个人博客站长就无法使用了，今天就来介绍一款邮件订阅服务的网站 RSSMail。 可能有的朋友会说 RSS 软件一抓一大把，直接用 RSS 订阅博客的更新不就行了。那么问题来了，有多少人知道 RSS 呢？又有多少人用 RSS 软件呢？ 相对于 RSS 软件的普及程度，我相信邮件的使用率应该是更高的，而且是很多人每天必须要打开的应用之一，所以为博客增加一个邮件订阅功能就显得尤为重要。 RSSMailer | https://rssmailer.app/ RSSMailer 的主业其实是一款 RSS 阅读器，通过邮件形式把设置好的 RSS 源更新的文章发送到指定邮件。最棒的是它还能为内容创造者提供内容更新订阅服务，其实就相当于是邮件订阅服务了。 只不过在 RSSMailer 后台没有查看相关订阅的功能，也就是说你是管理不了订阅者的，当然这也符合 RSSMailer 产品的设计初衷。 安装使用 访问官网 https://rssmailer.app/ 并简单注册后，点击右上角用户名找到 Create mail newsletter 就会看到如图所示，按照我的例子填写就好。只有一点需要说明，Pick a url（needs to be unique）是你自定义的网址后缀。 建立完成后就会有这样一个网址 https://rssmailer.app/s/wangrongshengzz ，访问的时候如下图。 只要有用户订阅了你的更新，RSSMailer 就会每天把内容推送到用户的邮箱了。是不是很方便~ 当然 RSSMailer 的订阅功能也很不错，你可以选择是获取 RSS 源的摘要或是列表。只要输入需要订阅的网址就可以自动识别了，而且还支持.opml 文件导入。 ","link":"https://Wangrongsheng.github.io/post/iXC_f5HSm/"},{"title":"Github利用码云加速下载","content":" 简介 众所周知，GitHub是一个巨大的开源宝库，以及程序员和编程爱好者的聚集地，包括我之前推荐的诸多优秀的开源项目全部都是位于GitHub上。 但是每当我们看到优秀的开源项目，准备去 下（bai）载（piao） 时，会发现 git clone的速度异常之慢！这简直太难受了。 小项目倒还好，等几分钟无所谓；一旦项目庞大起来，或者项目文件数目一多， git clone 大概率会失败！ 当然网上常见的诸如修改hosts（加速国内Github访问速度）、代理等方式实际使用效果并不一定好，而且也不稳定。 解决使用 加速下载 介绍一种GitHub下载的加速方法：通过国内码云平台的转接，来完成GitHub上项目的下载加速。 首先确保码云上有账户，可以正常使用，没有的可以自行注册一下； 点击右上角新建仓库的加号 +，选择“从 GitHub/GitLab导入仓库”菜单； 然后填写位于 GitHub上你想 clone的仓库地址并导入； 这一步交给码云来做速度是非常快的，一会儿功夫，码云就克隆出了一份和GitHub上一模一样的项目！ 接下来我们通过码云上的项目地址，将项目 clone到本地，这时候的clone速度就很快了，几 MB/s的速度是没问题的，很快项目就下载下来了； 按道理讲这时候我们的目的已经达到了，不过不要忘了，还有一件事没做：你通过Git操作，提交的仓库不是Github，而是码云，我们需要重新修改远端地址。 重新关联远端地址 要知道，这时候克隆到本地的项目关联的是码云Gitee的地址，已经和原来的GitHub项目完全脱离了，是另外一个副本。 在必要情况下（比如我们就是要给GitHub上的某个项目提 PR），我们还需要重新将我们本地的项目关联到原来的GitHub项目上去，做法如下： 首先找到位于本地仓库目录下的隐藏文件夹 .git； 用文本编辑器打开 .git文件夹中的 config配置文件； 将配置文件中的 [remote &quot;origin&quot;].url字段重新关联到原来位于GitHub上的GitHub项目地址 当然你也可以通过命令行来修改远端地址，效果一样的 至此大功告成，本地项目就相当于是 clone自GitHub，后续提代码，提 PR到GitHub上都没有问题。 ","link":"https://Wangrongsheng.github.io/post/zRZIKlpZ8/"},{"title":"Vim基本使用方法","content":" Vim简介 Vim 是什么？ Vim是一个高度可配置的文本编辑器，用于创建和更改任何类型的文本非常高效。与大多数UNIX系统和Apple OS X一起，它被包含为“vi”。Vim是稳定的，并且不断发展，变得更好。其特点是：持久的多级撤消树；广泛的插件系统；支持数百种编程语言和文件格式；强大的搜索和替换；与许多工具集成。 Vim是Vi IMproved，是编辑器Vi的一个加强版，一个极其强大并符合IT工程师（程序员、运维）习惯的编辑器。如果你是一名职业的SE，那么一定在寻找一款出色的能够自由定制、满足灵活编辑功能的编辑器。那么答案，就是vim或者Emacs。vim最大特色是完全使用键盘命令进行编辑，脱离了鼠标操作虽然使得入门变得困难，但上手之后键盘的各种巧妙组合操作却能带来极为大幅的效率提升。 在Linux系统中，RHEL和CentOS的配置文件是/etc/vimrc，Debian和Ubuntu的配置文件是/usr/share/vim/vimrc。 那么vimRC中的RC是什么意思？ 一般在运行某个软件、环境或工具之初，要初始执行的一些命令，称为Run Commands，即RC。根据Wikipedia.org的记载，RC缩写的用法源自MIT的相容分时操作系统（Compatible Time-Sharing System，CTSS），有兴趣的话请自行了解。 为什么要学 Vim ？ 作为一个程序员，不管是前端还是后端，工作中基本上都要跟服务器打交道，现在服务器里面运行的操作系统基本上都是 Linux，当你远程跟服务器通信的时候，基本上都要通过终端来跟服务器建立连接，当你要修改服务器的某个配置文件的时候，在一个黑漆漆的终端里，你能用的几乎只有 Vim，所以不会 Vim 的话，你就没办法工作； vim三种基本模式 基本上vi/vim可以分为三种状态，分别是普通模式、插入模式和命令模式，各模式的功能区分如下： 普通模式 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段。 插入模式 只有在插入下，才可以做文字输入、删除，按「ESC」键可回到普通模式。可以按i、I、a、A、o、O、r、R即可。其中i和I表示插入（Insert），r和R表示替换（replace）。 命令模式 将文件保存或退出vim，也可以设置编辑环境，如寻找字符串、列出行号等……可以按“:”、“/”、“?”。其中“:”表示输入vim命令，“/”表示后面输入要向下搜索的字符串，“?”表示后面输入要向上搜索字符串。 其实，可以把普通模式理解为常态，进入其它任何一种模式，需要某种特殊方式，而从其它特殊模式回到普通模式，就按「ESC」键即可。 vim最常用的配置 为了使以下参数永久有效，那你可以把以下参数写进/etc/vimrc配置文件里，当然，有一些参数已经存在配置文件中了。 颜色设置 指令 作用 syntax on 开启代码高亮 syntax off 关闭代码高亮 syntax enable 开启代码高亮 搜索设置 指令 作用 set hlsearch 开启搜索高亮 set nohlsearch 关闭搜索高亮 set incsearch 输入搜索字符串的同时进行搜索 set ignorecase 搜索时忽略大小写 用户界面 指令 作用 set ruler 开启光标位置提示 set number 显示行号 set nonu 不显示行号 set cmdheight=1 命令部分高度为1 编辑辅助配置 指令 作用 set autoindent 自动缩进 set noautoindent 不自动缩进 set smartindent 智能缩进 set autoread 当文件在外部被改变时，vim自动更新载入 set showmatch 显示匹配的括号 常用的状态切换按键 普通模式 → 插入模式 指令 作用 i 小写字母i 在光标位置插入 a 小写字母a 在光标的下一个位置插入 I 大写字母I 在光标所在行的第一个非空格处插入 A 大写字母A 在光标所在行的最后一个字符处插入 o 小写字母o 在光标所在行的下一行处插入新行 O 大写字母O 在光标所在行的上一行处插入新航 r 小写字母r 替换光标所在处的字符一次 R 大写字母R 持续替换光标所在处的字符，直到按下「ESC」键 普通模式 → 命令模式 指令 作用 :w 保存文件 :w! 强制保存文件（前提是用户有修改文件访问权限的权限） :q 退出缓冲区 :q! 强制退出缓冲区而不保存 :wq 保存文件并退出缓冲区 :wq! 强制保存文件并退出缓冲区（前提是用户有修改文件访问权限的权限） :w [filename] 另存为名为filename文件 :r [filename] 将另外一个文件读入到正在编辑的文件 :n1,n2 w [filename] 将n1行到n2行的数据另存为名为filename文件 :x 保存并退出 ZZ 保存并退出 ZQ 不保存退出 插入模式 → 视图模式 按下「ESC」键 命令模式 → 视图模式 按下「ESC」键 常用的光标移动按键 光标字符操作 指令 作用 h 向左箭头键(←) 光标向左移动一个字符 l 向右箭头键(→) 光标向右移动一个字符 j 向下箭头键(↓) 光标向下移动一个字符 k 向上箭头键(↑) 光标向上移动一个字符 $ 光标移动到行尾（End），注意要按「Shift」键 0 光标移动到行首（Home） ^ 光标移动到行首第一个非空白字符（Home），注意要按「Shift」键 光标词操作 指令 作用 w 光标移动到后一词的词首 W 光标移动到后一词的词首且忽略标点符号 e 光标移动到后一词的词尾 E 光标移动到后一词的词尾且忽略标点符号 b 光标移动到前一词的词首 B 光标移动到前一词的词首且忽略标点符号 光标行操作 指令 作用 G 光标移动到文件的最后一行的第一个非空白字符 nG/ngg 光标移动到文件的第n行，相当于”:n” gg 光标移动到文件的第1行的第一个非空白字符 光标页操作 指令 作用 Ctrl + f 向下翻页（Pagedown） Ctrl + b 向上翻页（Pageup） Ctrl + d 向下翻半页 Ctrl + u 向上翻半页 「H」 光标移动到目前显示页的第一行 「M」 光标移动到目前显示页的中间行 「L」 光标移动到目前显示页的最后一行 光标自由操作 指令 作用 Ctrl + o 回到光标的上一位置 常用编辑操作按键 删除操作（delete） 指令 作用 dd 删除光标所在行 ndd 删除从光标所在行开始，向下的n行 d1G 删除从光标所在行开始，到第一行的所有行 dG 删除从光标所在行开始，到最后一行的所有行 d$ 删除从光标所在位置，到行尾的所有字符 d0 删除从光标所在位置，到行首的所有字符 x 每按一次，删除光标所在位置的“后面”一个字符 nx 删除光标所在位置的“后面”n个字符 X 大写的X，每按一次，删除光标所在位置的“前面”一个字符 nX 删除光标所在位置的“前面”n个字符 复制操作（yank） 指令 作用 yy 复制光标所在行 nyy 复制从光标所在行开始，向下的n行 y1G 复制从光标所在行开始，到第一行的所有行 yG 复制从光标所在行开始，到最后一行的所有行 y$ 复制从光标所在位置，到行尾的所有字符 y0 复制从光标所在位置，到行首的所有字符 J 将光标所在行与下一行合并成一行 yw 复制当前光标所在的字母到该单词的最后一个字母 yaw 复制当前光标所在的单词 粘贴操作（paste） 指令 作用 p 小写字母p 粘贴剪贴板中的数据，从光标所在行的下一行开始 P 大写字母P 粘贴剪贴板中的数据，从光标所在行的上一行开始~ 撤销与重做操作（undo） 指令 作用 u 撤销上一个操作 重复操作 指令 作用 . 重复上一操作 替换操作（replace） 指令 作用 r 替换光标所在处字符 R 进入替换模式，直至按ESC退出 cc 替换光标所在行 cw 替换光标所在的英文单词 ~ 转换大小写 :n1,n2s/old/new/g 从n1到n2行将old替换成new，g表示全部替换 :1,$s/old/new/g 将整个文件的old替换成new :1,$s/old/new/gc c表示确认 排版操作 指令 作用 :le 光标所在行左对齐 :ri 光标所在行右对齐 :ce 光标所在行居中 查看历史 指令 作用 :history 显示最近在vim里面输入的历史 常用的搜索快捷键 搜索字符串 指令 作用 /string 向下搜索字符串“string” ?string 向上搜索字符串“string” 重复上次搜索 指令 作用 n 根据上次搜索条件找到下一个匹配的字符串 N 根据上次搜索条件找到上一个匹配的字符串 常用多缓冲区操作按键 单一缓冲区打开多个文件 指令 作用 :files 显示目前打开了哪些文件 :n 切换到下一个缓冲区内容 :N 切换到上一个缓冲区内容 :2n 切换到下下个缓冲区内容 :bn 下一个缓冲区内容（buffer next） :bp 上一个缓冲区内容（buffer previous） 多个缓冲区打开多个文件 指令 作用 :sp [filename] 打开一个新的缓冲区，如果有filename则内容为该文件，否则为当前文件 Ctrl+w n 新建一个缓冲区 Ctrl+w q 退出光标所在的缓冲区 Ctrl+w j 光标移动到下一缓冲区 Ctrl+w k 光标移动到上一缓冲区 Ctrl+w l 光标移动到右一缓冲区 Ctrl+w h 光标移动到左一缓冲区 Ctrl+w v 左右切割窗口新建缓冲区 Ctrl+w s 上下切割窗口新建缓冲区 Ctrl+w o 使光标所在缓冲区最大化，其他缓冲区隐藏 关于加密 加密文本文件 当你用vim打开或新建一个文件时，如果加上-x参数，即： # vim -x test.txt --打开你要加密的文本文件 那么vim会提示你： Enter entryption key: 当你输入了密码后，vim会提示你重复输入以确认： Enter same key again: 当你在设置密码的时候，是以*来显示的，非明文。打开文件之后，:wq保存退出，密码才生效。 当下次有人（包括你自己）打开该文件的时候，vim就会提示： Enter encryption key: 这时你只要输入你之前所设置的密码就可以了。如果你输入的密码是错误的，vim并不会提示你密码错误，而是显示一堆无意义的垃圾代码。 解除加密与重设密码 打开你已经加密的文件，然后输入： # vim test.txt --打开加密文件之后，输入下面内容 :set key= 这样，你的密码就被设置为空了，今后进入就不再需要输入密码了。而如果你向重设密码的话，你可以输入： :X 注意是个大写字母X。这时vim会提示你，只要反复输入两次新的密码就可以了： Enter entryption key: ***** Enter sanme key again: ***** 如果是清除密码，连续敲两次键盘就可以了 注意： 加密、解除密码、重设密码之后，一定要保存之后才能生效。 如果密码输入错误，vim不会拒绝访问者编辑文件。在这种显示乱码的情况下编辑文件并保存，整个文件就会变得混乱不堪，无法辨识。今后即使使用正确的密码打开文件，也看不到正确的文档了。 参考 Linux vi/vim|菜鸟教程 Vim命令&amp;笔记 ","link":"https://Wangrongsheng.github.io/post/lj6l5vjd8/"},{"title":"Github库名命名规范","content":" 必要性说明 由于迁移到Github上的项目越来越多，对项目的管理越来越困难。由于各项目命名具有随意性，用之代表git仓库名后就很难快速回忆起这个项目的相关细节，通常需要不断打开某个库才能有所了解。因此，十分必要对git库名命名方式进行规范以便于项目的管理。 命名规则 GIT库名一律采用项目名-类型-年月的形式。其中对项目名的规范如下： 库名中不得出现下述规定的字符- \\ @ ! # $ % ^ &amp; * () [] {} | \\ ; : '' ’ ， 。 《 》 &lt; &gt; · ~ ； 库名应尽量避免使用 名.名的形式； 库名应尽量使用英文，禁止使用中文字符。一般情况下，库名中出现的各个单词的首字母应使用大写。各个单词不能使用连接符-连接；如有必要，应使用下划线 _ ； 缩写的单词一律使用大写； 对类型的规定如下： TST——测试项目 BC——已完成项目 SUS——被搁置项目 ING——正在进行的项目 TST-BC——已完成的测试项目 TST-SUS——被搁置的测试项目 TST-ING——正在进行的测试项目 ","link":"https://Wangrongsheng.github.io/post/fqNMmScvt/"},{"title":"HTML基础语法","content":" HTML简介 HTML称为超文本标记语言，是一种标识性的语言。它包括一系列标签．通过这些标签可以将网络上的文档格式统一，使分散的Internet资源连接为一个逻辑整体。HTML文本是由HTML命令组成的描述性文本，HTML命令可以说明文字，图形、动画、声音、表格、链接等。 HTML基础语法 全局架构标签 每一个html页面必须包含以下一段内容，可以称为全局架构标签 &lt;!DOCTYPE html&gt; &lt;!-- 声明这个html页面使用的版本，这样写代表是H5最新版本 --&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!-- 告诉浏览器使用的是utf-8字符集 --&gt; &lt;title&gt;我的网站&lt;/title&gt; &lt;!-- 这里用来编写网站的标题，显示在浏览器选项卡的位置 --&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 只有body标签里面的内容，才能真正显示在浏览器的窗口中 --&gt; &lt;h1&gt;我的第一个标签&lt;/h1&gt; &lt;p&gt;我的第一个段落&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; html标签和元素的说法： 标签：html、head、meta、title、body、h1、p等等我们都称为html的标签，简称标签即可。 元素：一对标签所表示的东西，我们称为元素。 练习： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf8&quot; /&gt; &lt;!-- 这里是注释：meta为半闭合标签，并使用utf8字符集 --&gt; &lt;title&gt;这是我的标题：首次学习HTML&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt; 首次学习PHP，这是HTML基础语法部分！！ &lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 标题 标题就是我们通常理解的文档里面的标题，html里面的标题分为：h1、h2、h3、h4、h5、h6 写法： &lt;h1&gt;最大的标题&lt;/h1&gt; &lt;h2&gt;标题二&lt;/h2&gt; &lt;h3&gt;标题三&lt;/h3&gt; &lt;h4&gt;标题四&lt;/h4&gt; &lt;h5&gt;标题五&lt;/h5&gt; &lt;h6&gt;标题六&lt;/h6&gt; 练习： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf8&quot; /&gt; &lt;title&gt;标题--HTML基础语法学习&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我是一个h1标题&lt;/h1&gt; &lt;h2&gt;我是一个h2标题&lt;/h2&gt; &lt;h3&gt;我是一个h3标题&lt;/h3&gt; &lt;h4&gt;我是一个h4标题&lt;/h4&gt; &lt;h5&gt;我是一个h5标题&lt;/h5&gt; &lt;h6&gt;我是一个h6标题&lt;/h6&gt; &lt;/body&gt; &lt;/html&gt; 段落 段落表示一段普通的文字，类似文章中的一个段落 写法： &lt;p&gt; 近日，西安女车主坐在66万买的奔驰车引擎盖上无奈维权引发各界密切关注。除了车本身的质量问题，该车主还质疑4S店诱其贷款收取的“金融服务费”存在欺诈。贷款买车究竟有哪些渠道？“金融服务费”是不是合理收费？贷款买车会遭遇哪些套路？消费者提前防范别踩坑里？北京青年报记者就这些问题采访了众多专业人士。 据了解，汽车金融业务包括三种较为常见的模式。第一种为银行车贷，消费者向申请住房按揭一样向银行申请贷款，按照一定利率按月还款；第二种为信用卡分期，指持卡人同意支付首付款的情况下，向银行申请用其信用卡在银行指定的经销商购买家用汽车，经银行核准后，将审批通过金额平均分成若干期，由持卡人在约定期限内按月还款，并支付一定手续费。第三种模式为消费者向汽车金融公司申请贷款。也是西安奔驰维权事件中女车主选择的方式。第四种是近年来新兴的汽车融资租赁，即通过“以租代购、分期付款”的方式购车。 &lt;/p&gt; 练习： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;meta charset=&quot;utf8&quot; /&gt; &lt;head&gt; &lt;title&gt;段落--HTML基础语法&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;毛主席介绍&lt;/h1&gt; &lt;p&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;近日，西安女车主坐在66万买的奔驰车引擎盖上无奈维权引发各界密切关注。除了车本身的质量问题，该车主还质疑4S店诱其贷款收取的“金融服务费”存在欺诈。贷款买车究竟有哪些渠道？“金融服务费”是不是合理收费？贷款买车会遭遇哪些套路？消费者提前防范别踩坑里？北京青年报记者就这些问题采访了众多专业人士。 &lt;/p&gt; &lt;p&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;据了解，汽车金融业务包括三种较为常见的模式。第一种为银行车贷，消费者向申请住房按揭一样向银行申请贷款，按照一定利率按月还款；第二种为信用卡分期，指持卡人同意支付首付款的情况下，向银行申请用其信用卡在银行指定的经销商购买家用汽车，经银行核准后，将审批通过金额平均分成若干期，由持卡人在约定期限内按月还款，并支付一定手续费。第三种模式为消费者向汽车金融公司申请贷款。也是西安奔驰维权事件中女车主选择的方式。第四种是近年来新兴的汽车融资租赁，即通过“以租代购、分期付款”的方式购车。 &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 文本 HTML文本格式化标签（常用） 标签 描述 &lt;em&gt; 定义着重文字 &lt;i&gt; 定义斜体字 &lt;small&gt; 定义小号字 &lt;strong&gt; 定义加重语气 &lt;sub&gt; 定义下标字 &lt;sup&gt; 定义上标字 &lt;ins&gt; 定义插入字 &lt;del&gt; 定义删除字 练习： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf8&quot; /&gt; &lt;title&gt;文本--HTML基础语法&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;b&gt;PHP是世界上最美的语言！！！&lt;/b&gt; &lt;!-- b标签，用于加粗字体 --&gt; &lt;b&gt;PHP&lt;/b&gt;是世界上最美的语言！！！ &lt;!-- b标签，仅对PHP加粗 --&gt; &lt;em&gt;PHP&lt;/em&gt;是世界上最美的语言！！！&lt;br&gt; &lt;i&gt;PHP&lt;/i&gt;是世界上最美的语言！！！&lt;br&gt; &lt;!-- i标签，斜体 --&gt; &lt;strong&gt;PHP&lt;/strong&gt;是世界上最美的语言！！！&lt;br&gt; &lt;!-- strong标签，类似加粗 --&gt; &lt;sub&gt;PHP&lt;/sub&gt;是世界上最美的语言！！！&lt;br&gt; &lt;!-- sub标签，下沉 --&gt; &lt;sup&gt;PHP&lt;/sup&gt;是世界上最美的语言！！！&lt;br&gt; &lt;!-- sup标签，上浮 --&gt; &lt;ins&gt;PHP&lt;/ins&gt;是世界上最美的语言！！！&lt;br&gt; &lt;!-- ins标签，下滑线 --&gt; &lt;del&gt;PHP&lt;/del&gt;是世界上最美的语言！！！&lt;br&gt; &lt;!-- del标签，文本划线删除 --&gt; &lt;/body&gt; &lt;/html&gt; 属性 每一个标签都会拥有一堆属性，来描述这个标签的一些功能。 所有标签共有的属性： class 为html元素定义一个或多个类名(classname)（类名从样式文件引入） id 定义元素的唯一id style 规定元素的行内样式 title 描述了元素的额外信息（作为工具条使用） 标签自己的属性，比如下面的a标签和img标签： &lt;a href=&quot;http://www.baidu.com&quot;&gt;我是一个超链接，鼠标点击即可跳转到一个网址&lt;/a&gt; &lt;img src=&quot;haha.jpg&quot; width=&quot;100px&quot; /&gt; 写法： &lt;h1 id=&quot;wwely1&quot; class=&quot;duoge&quot; style=&quot;color: red&quot; title=&quot;鼠标放上来可以显示的&quot;&gt;标题一&lt;/h1&gt; &lt;p id=&quot;wely1&quot; class=&quot;duoge&quot; style=&quot;color: red&quot; title=&quot;鼠标放上来可以显示的&quot;&gt;段落一&lt;/p&gt; 练习： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf8&quot; /&gt; &lt;title&gt;属性--HTML基础语法&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 id=&quot;kim&quot; class=&quot;K&quot; style=&quot;color: red&quot; title=&quot;这是鼠标提示&quot;&gt;英文名&lt;/h1&gt; &lt;!-- h1添加属性 --&gt; &lt;h1 id=&quot;kin&quot; class=&quot;Ki&quot; style=&quot;color: green;font-size: 50px;&quot; &gt;英文名&lt;/h1&gt; &lt;a href=&quot;http://www.baidu.com&quot;&gt;这是一个超链接，点我即可跳转&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 链接 链接，是给任何的html元素添加链接，可以被点击，跳转到某个地址。 写法： &lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot;&gt;点击即可跳转百度&lt;/a&gt; 用法： 在任何元素上面，想让用户点击，即可跳转到某个页面，就可以使用。 &lt;a href=&quot;http://www.youku.com&quot;&gt;&lt;h1&gt;跳转优酷视频&lt;/h1&gt;&lt;/a&gt; 练习： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf8&quot; /&gt; &lt;title&gt;链接--HTML基础语法&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot;&gt;点击我可以打开百度页面&lt;/a&gt; &lt;!--target标签表示在新的标签页打开 --&gt; &lt;a href=&quot;http://www.jd.com&quot; target=&quot;_blank&quot;&gt;&lt;h1&gt;点击跳转京东&lt;h1&gt;&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 图片 在网页中显示一张图片 写法： &lt;img src=&quot;haha.jpg&quot; title=&quot;图片的标题&quot; alt=&quot;图片的属性&quot; width=&quot;100px&quot; height=&quot;100px&quot; /&gt; 绝对路径和相对路径： 绝对路径是指一个完整的可以从开头找到这个图片的路径 相对路径是指相对于当前的页面所在的路径 绝对路径的写法： &lt;img sr=&quot;C:\\Users\\Administrator\\Pictures\\timg.jpg&quot; /&gt; 相对路径的写法： &lt;img src=&quot;haha.jpg&quot; /&gt; &lt;!--当前目录--&gt; &lt;img src=&quot;./haha.jpg&quot; /&gt; &lt;!-- 当前目录 --&gt; &lt;img src=&quot;../haha.jpg&quot; /&gt; &lt;!-- 上一级目录 --&gt; 练习： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf8&quot; /&gt; &lt;title&gt;图片--HTML基础语法&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;http://www.baidu.com&quot;&gt;&lt;img src=&quot;C:\\Users\\Administrator\\Pictures\\timg.jpg&quot; width=&quot;1000px&quot; height=&quot;1000px&quot; title=&quot;这是gitlab的Logo&quot; alt=&quot;gitlab&quot;/&gt;&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 列表 无序列表（常用） &lt;ul&gt; &lt;li&gt;第一个列表内容&lt;/li&gt; &lt;li&gt;第二个列表内容&lt;/li&gt; &lt;/ul&gt; 有序列表（用的少） &lt;ol&gt; &lt;li&gt;第一个列表内容&lt;/li&gt; &lt;li&gt;第二个列表内容&lt;/li&gt; &lt;/ol&gt; 自定义列表（不怎么用） &lt;dl&gt; &lt;dt&gt;编程语言&lt;/dt&gt; &lt;dd&gt;- PHP&lt;/dd&gt; &lt;dd&gt;- Java&lt;/dd&gt; &lt;dd&gt;- C++&lt;/dd&gt; &lt;dt&gt;操作系统&lt;/dt&gt; &lt;dd&gt;- Linux&lt;/dd&gt; &lt;dd&gt;- windows&lt;/dd&gt; &lt;/dl&gt; 练习： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf8&quot; /&gt; &lt;title&gt;列表--HTML基础语法&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;!-- 无序列表 --&gt; &lt;li&gt;Linux跟我学&lt;/li&gt; &lt;li&gt;老男孩教育&lt;/li&gt; &lt;li&gt;千峰教育&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;!-- 有序列表 --&gt; &lt;li&gt;Linux跟我学&lt;/li&gt; &lt;li&gt;老男孩教育&lt;/li&gt; &lt;li&gt;千峰教育&lt;/li&gt; &lt;/ol&gt; &lt;dl&gt; &lt;!-- 自定义列表 --&gt; &lt;dt&gt;操作系统&lt;/dt&gt; &lt;dd&gt;- Linux&lt;/dd&gt; &lt;dd&gt;- Windows&lt;/dd&gt; &lt;/dl&gt; &lt;/body&gt; &lt;/html&gt; 表格 写法： &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt; &lt;tr&gt; &lt;th&gt;头部一&lt;/th&gt; &lt;th&gt;头部二&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;第一行，第一列&lt;/td&gt; &lt;td&gt;第一行，第二列&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;第二行，第一列&lt;/td&gt; &lt;td&gt;第二行，第二列&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 用法： 需要以表格显示的内容 可以用来布局页面（现在不用了，用div来进行布局） 练习： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf8&quot; /&gt; &lt;title&gt;表格--HTML基础语法&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt; &lt;tr&gt;&lt;th&gt;标题&lt;/th&gt;&lt;th&gt;标题&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;第一行，第一列&lt;/td&gt;&lt;td&gt;第一行，第二列&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;第二行，第一列&lt;/td&gt;&lt;td&gt;第二行，第二列&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 区块 块级元素：div是指一块内容的标签，div不显示任何东西，用来包含其他标签，称之为一块内容，需要配合CSS样式来进行页面布局。 h1、p、ul、table都是块级元素，会以新行来开始。 内联元素：span标签用来包裹文字。b、id、a、img通常不会以新行开始。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf8&quot; /&gt; &lt;title&gt;区块--HTML基础语法&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;这是一个div&lt;/div&gt; &lt;div&gt; 这是第二个div &lt;a&gt;66666&lt;/a&gt; &lt;!-- 这里a标签不是块级元素，不会在新行开始--&gt; &lt;/div&gt; &lt;p&gt; &lt;!-- p标签为块级元素，会在新行开始--&gt; 这是一个段落 &lt;/p&gt; &lt;p&gt; 这是第二个段落 &lt;/p&gt; &lt;span&gt;内联元素&lt;/span&gt; &lt;span&gt;内联元素222&lt;/span&gt; &lt;/body&gt; &lt;/html&gt; 布局 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf8&quot;/&gt; &lt;title&gt; 布局--HTML基础语法&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 表单 表单是用来在网页上显示给用户输入的标签，然后提交给后台服务器进行处理。 定义： &lt;form action=&quot;xxx.php&quot; method=&quot;post&quot;&gt; &lt;/form&gt; 表单元素： 多数情况下被用到的表单标签是输入标签（&lt;input&gt;），输入类型是由类型属性（type）进行定义的，常用的输入类型如下： 文本 &lt;form &gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;Kim&quot; /&gt; &lt;/form&gt; 密码 &lt;form&gt; Password: &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt; &lt;/form&gt; 单选按钮（Radio Buttons） &lt;form&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt;Male&lt;br&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt;Female &lt;/form&gt; 多选按钮（Checkboxes） &lt;form&gt; &lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; value=&quot;Bike&quot;&gt;I have a bike&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; value=&quot;Car&quot;&gt;I have a car &lt;/form&gt; 提交按钮（Submit Button） &lt;form name=&quot;input&quot; action=&quot;html_form_action.php&quot; method=&quot;get&quot;&gt; Username: &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt; &lt;/form&gt; 练习： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf8&quot; /&gt; &lt;title&gt;表单--HTML语法基础&lt;/title&gt; &lt;form action=&quot;xxx.php&quot; method=&quot;post&quot; id=&quot;11&quot; name=&quot;login&quot;&gt; &lt;label&gt;用户名：&lt;label&gt;&lt;input type=&quot;text&quot; value=&quot;kim&quot; name=&quot;username&quot; /&gt;&lt;br&gt; &lt;label&gt;密码：&lt;/label&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;请输入密码&quot; /&gt;&lt;br&gt; &lt;label&gt;备注：&lt;/label&gt; &lt;textarea name=&quot;intro&quot; placeholder=&quot;输入简介&quot;&gt; &lt;/textarea&gt;&lt;br /&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;1&quot;&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;0&quot;&gt;女&lt;br /&gt; &lt;h1&gt;选择题&lt;/h1&gt; &lt;p&gt;1、下面哪个城市是孙中山的故乡&lt;/p&gt; &lt;input type=&quot;checkbox&quot; name=&quot;area&quot; value=&quot;city&quot;&gt;天津&lt;br /&gt; &lt;input type=&quot;checkbox&quot; name=&quot;area&quot; value=&quot;city&quot;&gt;上海&lt;br /&gt; &lt;input type=&quot;checkbox&quot; name=&quot;area&quot; value=&quot;city&quot;&gt;中山&lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/html&gt; 框架 框架（iframe） &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf8&quot; /&gt; &lt;title&gt;框架--HTML基础语法&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;iframe src=&quot;http://www.baidu.com&quot; width=&quot;500px&quot; height=&quot;1000px&quot;&gt;&lt;/iframe&gt; &lt;/body&gt; &lt;/html&gt; 头部 完整的头部标签： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf8&quot; /&gt; &lt;base href=&quot;http://www.runoob.com/images/&quot; target=&quot;_link&quot;&gt; &lt;!-- 页面中 所有的链接的默认地址--&gt; &lt;title&gt;头部--HTML基础语法&lt;/title&gt; &lt;meta name=&quot;keywords&quot; content=&quot;PHP学习之路&quot;&gt; &lt;!-- 这个是做seo优化的时候用的 --&gt; &lt;meta name=&quot;description&quot; content=&quot;改变世界的PHP&quot;&gt; &lt;!-- 这个是做seo优化的时候用的 --&gt; &lt;meta http-equiv=&quot;refresh&quot; content=&quot;30&quot;&gt; &lt;!-- 刷新跳转页面 --&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.csss&quot;&gt; &lt;!-- 引入css样式 --&gt; &lt;/head&gt; &lt;body&gt; 文档内容...... &lt;/body&gt; &lt;/html&gt; ","link":"https://Wangrongsheng.github.io/post/8i8GQdZHK/"},{"title":"关于论文作者","content":"对于论文想必大家可能都有过耳闻,今天做一下一些相关知识的普及~ 基础问题 首先,第一作者和通讯作者之间一直是缠缠绵绵到天涯的关系，很多人对这两者并不陌生，但是在一些细节上的问题又感觉比较绕，我今天特意收集了平时大家提到的关于两者之间的一些问题，做成问答集锦，你想知道的，都在里面啦~ 什么是第一作者？ 第一作者通常主导大部分的实验工作，在一般的情况下，引用一篇论文时，提到的就是第一作者的名字，如 Tomas et al. report that...。 以第一作者的身份进行论文发表对博士生的科研路是很重要的，不止中国，全球大部分的博士毕业标准都要求学生要作为第一作者发表至少一篇论文。 对博士后及资深教授来说，作为第一作者的期刊论文发表是争取基金、职称晋升及续聘时的重要因素。据此，期刊论文的作者名单里，第一个名字一直是最抢手的位置。 在第一作者之后，作者顺序是根据对研究的贡献度排序，贡献度越高的排名越前。不过，有时候可能会有多位作者贡献度相同，这时候就可以列为共同一作、共同二作... 注意：第一作者很重要很重要很重要，要毕业、评职称、争基金...没头发可以，没它不行~ 什么是通讯作者？ 通讯作者是课题的总负责人，承担课题的经费、设计、文章的书写和把关，在投稿、同行评审和整个发表流程中负责和期刊沟通。从知识产权的角度来说，研究成果算是通讯作者的。能当通讯作者的人一般有以下几类： 论文的法定负责人: 通讯作者也是论文的主要受益人之一。也可以这么说，论文的第一作者是这项科研成果的主要贡献者，而论文的通讯作者是这项成果的责任者和受益人。 导师、教授、科研项目的主要负责人 其主要贡献是提供研究指导、研究经费、试验场所、实验室、仪器设备等与实验相关的物质资源。 论文的任何作者 要是一篇论文有数个作者，通讯作者可以是他们中的任何一位。至于到底是谁，主要看通讯作者在这项研究中真正起的作用和做出的贡献。要是他在整个实验中做到了关键的作用，那么他就理所当然地即可做第一作者，也可做通讯作者。 注意： 对于学生来说，通讯作者一般是他的导师。 对于研究机构来说，通讯作者一般是项目负责人。 对于出版机构来说，通讯作者可以是机构老板。 另外！！！一定要有固定的通讯地址！ 第一作者和通讯作者，谁更重要？ 通讯作者未必是第一作者，但第一作者可以是通讯作者。通讯作者多数情况和第一作者是同一个人，只有在通讯作者和第一作者不一致的时候，才有必要在文章脚注中附加通讯作者的标识。 所以，总的来说都重要！对于作者来说，第一作者很重要，谁是通讯作者没关系，但是通讯单位很关键，很多单位评职称看通讯单位，不看通讯作者。对于导师来说，通讯作者重要，因为导师永远当通讯作者，至于谁是第一作者不重要。对于出版机构来说，通讯作者非常重要，因为机构老板也常是通讯作者... 注意：通讯作者不是随便挂的，一旦出现通讯作者，这篇文章的科研版权就要非常注意了~ 共同一作排序重要吗，会影响评职称吗？ 共同作者排在第一位的是最好，所有东西都可以申请。因为排第一的肯定是第一作者，大家引用的时候都会缩写成“First-Author, et al，但是排在第二位就要小心了，排在第二位的虽然也是共同第一作者，但是有些单位只看第一位的，所以评职称的时候一定要问清楚单位科研处排在第二的共同作者能否评职称。 不过事无绝对，以下一些例子里面的共同一作和第一作者的贡献量和含金量差不多，排序嘛，就比较随便了··· 按作者名字的字母顺序决定作者排序 抛硬币决定作者顺序 根据对星战的痴迷程度决定作者顺序 根据申tenure的时间远近决定作者顺序 注意：国内对作者排序还是很重视的，很多机构和单位甚至只认可排序靠前的，所以能排前面就别排后面啦~ 所有的论文都要有通讯作者吗？ 并不是要求所有的论文都一定要写通讯作者。对于没有通讯作者的稿件，默认第一作者为通讯作者。 通讯作者多数情况和第一作者是同一个人，这样的话实际上是省略了通讯作者。只有在通讯作者和第一作者不一致的时候，才有必要加通讯作者。不赞成一味地模仿国外杂志，加不加通讯作者应根据需要而定。 注意：通讯作者非必须，随意模仿不可取~ 其他问题 我有两个老板，一个小老板，一个大老板，通讯作者排序要怎么排呢？ 目前，最常见的做法是权力最大的排最后，权力排倒数第二，也就是大老板排最后，小老板排倒数第二。一般期刊只能允许两位通讯作者，在文章中标注，列出他们的邮箱，偶尔也会看见有些期刊会有三个通讯，不过也有些期刊不准共同通讯，只能一个人。所以在投稿前一定要仔细阅读稿约。 注意：根据权力大小排就对了！ 导师可以既是第一作者，又是通讯作者吗？ 可以。第一作者兼任通讯作者没什么问题，更何况，对单一作者的论文来说，第一作者和通讯作者肯定是同一个人。如果你的教授对研究也出谋划策，拟出初始计划和研究设计，一定要将他列为共同作者。至于具体怎么做，还是需要跟导师商量，达成一致，避免日后产生争议。 注意：导师可以既当第一作者，又当通讯作者。 论文被接受，还能更换作者顺序和通讯作者吗？ 一般来说，期刊对于作者顺序变更不会有太大的意见，但非必要最好避免更换通讯作者，因为期刊编辑和通讯作者之间已经有过交流，有一定的熟悉程度。 不过，如果有不可抗拒的因素需要换通讯作者跟作者顺序的话，一定要跟编辑沟通解释清楚，因为这会涉及到之后的一系列问题，例如评职称、申奖金等等。另外，修改作者的时候，一定要附上新的版权~ 注意：作者顺序可以改，通讯作者最好不要改！ 不是通讯作者可以直接和期刊编辑联系吗？ 通讯作者的作用就是期刊编辑最主要的联系窗口，相关的沟通事宜都是通讯作者负责，不是通讯作者最好不要和期刊编辑联系，为避免将事情复杂化，最好是将事情积极反馈给通讯作者，再由通讯作者和期刊编辑沟通。 注意：让通讯作者架起沟通的桥梁~ 论文被查出学术不端，负责的应该是第一作者还是通讯作者？ 通讯作者是要对论文的全程进行把关的。特别是对里面内容的真实性，论证的根据等，有没有达到发表的水平。所以，通讯作者，既是一个署名权，更重要的是对这篇学术论文承担的责任。如果这篇文章出问题，通讯作者是第一责任人！当然那些没有被告知，就被别人列为论文的通讯作者，还是会有背黑锅的时候··· 注意：通讯作者负责就要负到底！ 让有名望的学者当通讯作者是不是能增加论文的投中率？ 如果在学术界口碑好、有名望教授当自己论文的通讯作者，会增加论文的投中率。因为通讯作者需要对论文把关，好口碑的教授一般学风严谨，出任通讯作者也是以自己的名誉来做担保，所以编辑在审查的时候，也会增加对论文的好感度，最后能不能投中关键的还是看论文的质量。 注意：论文能不能投中关键还是靠质量~ 最后,提醒一下大家：研究项目启动前是决定署名作者及其排名顺序的最佳时机，参与项目的团队成员必须在这些方面达成完全一致，毕竟按劳所得是亘古不变的真理~ ","link":"https://Wangrongsheng.github.io/post/CfvIECRBg/"},{"title":"加速国内Github访问速度","content":" 介绍 由于某些原因，国内访问 Github 会异常缓慢，在 clone 仓库时甚至只有 10kb/s 以下的速度，下载半天有时还会失败需要从头再来，甚是让人恼火。 本文介绍通过修改系统 hosts 文件的办法，绕过国内 DNS 解析，直接访问GitHub 的 CDN 节点，从而达到加速的目的。不需要科学上网，也不需要海外的服务器辅助。 使用 获取Github的官方CDN地址 打开 https://www.ipaddress.com/ 查询以下三个链接的的 DNS 地址： github.com assets-cdn.github.com github.global.ssl.fastly.net 记录下查询到的 IP 地址。 修改系统hosts文件 打开系统 hosts 文件(需管理员权限)。 路径：C:\\Windows\\System32\\drivers\\etc windows10 可以将 hosts 文件复制到桌面进行修改后覆盖原文件，windows7 使用管理员权限即可。 在末尾添加三行记录并保存。(需管理员权限，注意 IP 地址与域名间需留有空格) # Copyright (c) 1993-2001 Microsoft Corp. # # This file has been automatically generated for use by Microsoft Internet # Connection Sharing. It contains the mappings of IP addresses to host names # for the home network. Please do not make changes to the HOSTS.ICS file. # Any changes may result in a loss of connectivity between machines on the # local network. # 192.168.222.1 DESKTOP-LNVQC5O.mshome.net # 2025 2 4 27 7 1 41 512 192.30.253.113 github.com 185.199.108.153 assets-cdn.github.com 199.232.5.194 github.global.ssl.fastly.net 刷新系统DNS缓存 Windows+X打开系统命令行（管理员身份）或 powershell 运行 ipconfig /flushdns 手动刷新系统 DNS 缓存。 现在打开 Github，clone 一个项目到本地试试吧！ ","link":"https://Wangrongsheng.github.io/post/t2IHH5nWE/"},{"title":"Git基本命令使用","content":" 文章于2020年4月3日进行了更新！ 简介 Git是一种代码管理工具。 使用Git出于以下3种原因： 代码管理； 版本控制； 团队协作； 基本命令 git clone 复制远程仓库/仓库中的项目到本地的电脑，同时完成初始化 $ git clone https://github.com/WangRongsheng/test-Git Cloning into 'test-Git'... remote: Enumerating objects: 3, done. remote: Counting objects: 100% (3/3), done. remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (3/3), done. 之后你就可以在当前目录或者桌面看到一个叫做test-Git的文件，这就说明我们克隆项目到本地了。 如果让test-Git文件中显示所以文件，你就会看到一个.git的文件，里面存放的是仓库的基本配置，我们不需要管这个，了解就好！ 如果你已经写好了一个文件或文件夹，但是没有配置远程仓库该怎么办呢？ 这时候我们就需要进行自主的初始化了，在该文件夹下运行以下指令就可以进行初始化和配置远程仓库： git init + git remote add origin + 仓库地址 注意：对于新手来说，没有配置远程仓库的情况尽量避免，操作较为复杂哦！ git add . 将本地项目保存至暂存区 在这里我在我的test-Git文件夹中写入一个新的文件：demo.txt ，里面的内容填写为Hello World，然后在文件夹中运行： $ git add . git commit -m &quot;描述语句&quot; 提交到本地仓库 在这里我继续在我的test-Git 文件夹下运行： $ git commit -m &quot;demo上传&quot; [master 74e1688] demo上传 1 file changed, 1 insertion(+) create mode 100644 demo.txt git push 将本地仓库项目上传至远程仓库 在这里我继续在我的test-Git 文件夹下运行： $ git push fatal: HttpRequestException encountered. ▒▒▒▒▒▒▒▒ʱ▒▒▒▒ Enumerating objects: 4, done. Counting objects: 100% (4/4), done. Delta compression using up to 4 threads Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 294 bytes | 294.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0) To https://github.com/WangRongsheng/test-Git d01e1c4..74e1688 master -&gt; master 这时候刷新我们的远程仓库-Github/Gitlab/Coding的仓库就可以看到我们的新文件 demo.txt已经上传上去了！ git pull 拉取/同步远程仓库的代码到本地 在这里我继续在我的test-Git 文件夹下运行： $ git pull Already up to date. Git命令速查 参考 Git使用参考 git常用命令 ","link":"https://Wangrongsheng.github.io/post/QFPLAZbSg/"},{"title":"利用Word宏功能生成手写体文字报告","content":" 简介 小学、中学有没有因为一个知识点犯错了多次被罚抄呢？有没有每次都是心里爆炸？本以为上了大学就再也不会有罚写，可是每次几千字的小论文是不是也是崩溃的？但是还好有时候可以使用电子文档，去百度CV就好了，但是你的老师有没有告诉你：同学们务必要手写哦，不允许电子档！ ，心中一万句不服气...，今天就来用Word的多种字体来搭配一个我们自己的手写体吧，希望下次可以蒙混过关耶~ 使用 准备工作 字体下载 字体 下载链接 陈静的字完整版 下载 李国夫手写字体 下载 萌子字体(6000字) 下载 在这里提供我使用的三种字体，其它手写字体可以自行百度下载~ 宏代码 Sub 字体修改() ' ' 字体修改 宏 ' Dim R_Character As Range Dim FontSize(5) ' 字体大小在5个值之间进行波动，可以改写 FontSize(1) = &quot;21&quot; FontSize(2) = &quot;21.5&quot; FontSize(3) = &quot;22&quot; FontSize(4) = &quot;22.5&quot; FontSize(5) = &quot;23&quot; Dim FontName(3) '字体名称在三种字体之间进行波动，可改写，但需要保证系统拥有下列字体 FontName(1) = &quot;陈静的字完整版&quot; FontName(2) = &quot;萌妹子体&quot; FontName(3) = &quot;李国夫手写体&quot; Dim ParagraphSpace(5) '行间距 在一定以下值中均等分布，可改写 ParagraphSpace(1) = &quot;12&quot; ParagraphSpace(2) = &quot;13&quot; ParagraphSpace(3) = &quot;20&quot; ParagraphSpace(4) = &quot;7&quot; ParagraphSpace(5) = &quot;12&quot; '不懂原理的话，不建议修改下列代码 For Each R_Character In ActiveDocument.Characters VBA.Randomize R_Character.Font.Name = FontName(Int(VBA.Rnd * 3) + 1) R_Character.Font.Size = FontSize(Int(VBA.Rnd * 5) + 1) R_Character.Font.Position = Int(VBA.Rnd * 3) + 1 R_Character.Font.Spacing = 0 Next Application.ScreenUpdating = True For Each Cur_Paragraph In ActiveDocument.Paragraphs Cur_Paragraph.LineSpacing = ParagraphSpace(Int(VBA.Rnd * 5) + 1) Next Application.ScreenUpdating = True End Sub 开始使用 下载字体后，直接双击.ttf文件安装字体就可以了； 新建一个word文档，把正常的文字或者文章写好； 打开宏，新建一个宏命令，并将我们准备的代码完整填进去； 注意：宏代码中的字号、字体等你还可以根据自己的需求更改！ 点击运行，保存就ok了； 如果不满意就要好好微调下哦，完全可以很像我们自己手写的字。 效果 原始文章 修改后文章 推荐 手迹造字 Handright 手写体-中文字库自动生成系统 ","link":"https://Wangrongsheng.github.io/post/fCh63akOu/"},{"title":"垃圾代码书写准则","content":" 准则 💩 以一种代码已经被混淆的方式命名变量 如果我们键入的东西越少，那么就有越多的时间去思考代码逻辑等问题。 Good 👍🏻 let a = 42; Bad 👎🏻 let age = 42; 💩 变量/函数混合命名风格 为不同庆祝一下。 Good 👍🏻 let wWidth = 640; let w_height = 480; Bad 👎🏻 let windowWidth = 640; let windowHeight = 480; 💩 不要写注释 反正没人会读你的代码。 Good 👍🏻 const cdr = 700; Bad 👎🏻 更多时候，评论应该包含一些“为什么”，而不是一些“是什么”。如果“什么”在代码中不清楚，那么代码可能太混乱了。 // 700ms的数量是根据UX A/B测试结果进行经验计算的。 // @查看: &lt;详细解释700的一个链接&gt; const callbackDebounceRate = 700; 💩 使用母语写注释 如果您违反了“无注释”原则，那么至少尝试用一种不同于您用来编写代码的语言来编写注释。如果你的母语是英语，你可能会违反这个原则。 Good 👍🏻 // Закриваємо модальне віконечко при виникненні помилки. toggleModal(false); Bad 👎🏻 // 隐藏错误弹窗 toggleModal(false); 💩 尽可能混合不同的格式 为不同庆祝一下。 Good 👍🏻 let i = ['tomato', 'onion', 'mushrooms']; let d = [ &quot;ketchup&quot;, &quot;mayonnaise&quot; ]; Bad 👎🏻 let ingredients = ['tomato', 'onion', 'mushrooms']; let dressings = ['ketchup', 'mayonnaise']; 💩 尽可能把代码写成一行 Good 👍🏻 document.location.search.replace(/(^\\?)/,'').split('&amp;').reduce(function(o,n){n=n.split('=');o[n[0]]=n[1];return o},{}) Bad 👎🏻 document.location.search .replace(/(^\\?)/, '') .split('&amp;') .reduce((searchParams, keyValuePair) =&gt; { keyValuePair = keyValuePair.split('='); searchParams[keyValuePair[0]] = keyValuePair[1]; return searchParams; }, {} ) 💩 不要处理错误 无论何时发现错误，都没有必要让任何人知道它。没有日志，没有错误弹框。 Good 👍🏻 try { // 意料之外的情况。 } catch (error) { // tss... 🤫 } Bad 👎🏻 try { // 意料之外的情况。 } catch (error) { setErrorMessage(error.message); // and/or logError(error); } 💩 广泛使用全局变量 全球化的原则。 Good 👍🏻 let x = 5; function square() { x = x ** 2; } square(); // 现在x是25 Bad 👎🏻 let x = 5; function square(num) { return num ** 2; } x = square(x); // 现在x是25 💩 创建你不会使用的变量 以防万一。 Good 👍🏻 function sum(a, b, c) { const timeout = 1300; const result = a + b; return a + b; } Bad 👎🏻 function sum(a, b) { return a + b; } 💩 如果语言允许，不要指定类型和/或不执行类型检查。 Good 👍🏻 function sum(a, b) { return a + b; } // 在这里享受没有注释的快乐 const guessWhat = sum([], {}); // -&gt; &quot;[object Object]&quot; const guessWhatAgain = sum({}, []); // -&gt; 0 Bad 👎🏻 function sum(a: number, b: number): ?number { // 当我们在JS中不做置换和/或流类型检查时，覆盖这种情况。 if (typeof a !== 'number' &amp;&amp; typeof b !== 'number') { return undefined; } return a + b; } // 这个应该在转换/编译期间失败。 const guessWhat = sum([], {}); // -&gt; undefined 💩 你应该有不能到达的代码 这是你的 &quot;Plan B&quot;. Good 👍🏻 function square(num) { if (typeof num === 'undefined') { return undefined; } else { return num ** 2; } return null; // 这就是我的&quot;Plan B&quot;. } Bad 👎🏻 function square(num) { if (typeof num === 'undefined') { return undefined; } return num ** 2; } 💩 三角法则 就像鸟巢，鸟巢，鸟巢。 Good 👍🏻 function someFunction() { if (condition1) { if (condition2) { asyncFunction(params, (result) =&gt; { if (result) { for (;;) { if (condition3) { } } } }) } } } Bad 👎🏻 async function someFunction() { if (!condition1 || !condition2) { return; } const result = await asyncFunction(params); if (!result) { return; } for (;;) { if (condition3) { } } } 💩 混合缩进 避免缩进，因为它们会使复杂的代码在编辑器中占用更多的空间。如果你不喜欢回避他们，那就和他们捣乱。 Good 👍🏻 const fruits = ['apple', 'orange', 'grape', 'pineapple']; const toppings = ['syrup', 'cream', 'jam', 'chocolate']; const desserts = []; fruits.forEach(fruit =&gt; { toppings.forEach(topping =&gt; { desserts.push([ fruit,topping]); });}) Bad 👎🏻 const fruits = ['apple', 'orange', 'grape', 'pineapple']; const toppings = ['syrup', 'cream', 'jam', 'chocolate']; const desserts = []; fruits.forEach(fruit =&gt; { toppings.forEach(topping =&gt; { desserts.push([fruit, topping]); }); }) 💩 不要锁住你的依赖项 以非受控方式更新每个新安装的依赖项。为什么坚持使用过去的版本，让我们使用最先进的库版本。 Good 👍🏻 $ ls -la package.json Bad 👎🏻 $ ls -la package.json package-lock.json 💩 函数长的比短的好 不要把程序逻辑分成可读的部分。如果IDE的搜索停止，而您无法找到所需的文件或函数，该怎么办? 一个文件中10000行代码是OK的。 一个函数体1000行代码是OK的。 处理许多服务(第三方和内部，也有一些工具、数据库手写ORM和jQuery滑块)在一个' service.js ' ?这是OK的。 💩 不要测试你的代码 这是重复的并且不需要的工作。 💩 避免代码风格统一 编写您想要的代码，特别是在一个团队中有多个开发人员的情况下。这是一个“自由”的原则。 💩 构建新项目不需要 README 文档 一开始我们就应该保持。 💩 保存不必要的代码 不要删除不用的代码，最多是注释掉。 参考 ","link":"https://Wangrongsheng.github.io/post/YuQg-AeUx/"},{"title":"基于docsify+Github建立自己的项目文档","content":" docsify简介 docsify 是一个动态生成文档网站的工具。不同于 GitBook、Hexo 的地方是它不会生成将 .md 转成 .html 文件，所有转换工作都是在运行时进行。 这将非常实用，如果只是需要快速的搭建一个小型的文档网站，或者不想因为生成的一堆 .html 文件，只需要创建一个 index.html 就可以开始写文档而且直接部署在 GitHub Pages、Coding Pages、Netlify甚至是自己的服务器。 安装 脚手架安装 首先确保你已经安装node.js 。 然后运行： npm i docsify-cli -g 如果你觉得安装缓慢，你可以利用淘宝源先安装cnpm，然后利用cnpm安装docsify： npm install -g cnpm --registry=https://registry.npm.taobao.org cnpm i docsify-cli -g 初始化项目 自动初始化 如果想在项目的 ./docs 目录里写文档，直接通过 init初始化项目。 docsify init docs 手动初始化 如果不喜欢 npm 或者觉得安装工具太麻烦，我们其实只需要直接创建一个 index.html 文件。 index.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;//unpkg.com/docsify/themes/vue.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script&gt; window.$docsify = { //... } &lt;/script&gt; &lt;script src=&quot;//unpkg.com/docsify/lib/docsify.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 如果系统里安装 Python 的话，也可以很轻易的启动一个静态服务器。 cd docs &amp;&amp; python -m SimpleHTTPServer 3000 开始写文档 初始化成功后，可以看到 ./docs 目录下创建的几个文件 index.html 入口文件 README.md 会做为主页内容渲染 .nojekyll 用于阻止 GitHub Pages 会忽略掉下划线开头的文件 直接编辑 docs/README.md 就能更新网站内容，当然也可以写多个.md页面。 修改样式 Loading 提示 初始化时会显示 Loading... 内容，你可以自定义提示信息。 index.html &lt;div id=&quot;app&quot;&gt;加载中&lt;/div&gt; 如果更改了 el 的配置，需要将该元素加上 data-app 属性。 index.html &lt;div data-app id=&quot;main&quot;&gt;加载中&lt;/div&gt; &lt;script&gt; window.$docsify = { el: '#main' } &lt;/script&gt; 多页文档 如果需要创建多个页面，或者需要多级路由的网站，在 docsify 里也能很容易的实现。例如创建一个 guide.md 文件，那么对应的路由就是 /#/guide。 假设你的目录结构如下： -| docs/ -| README.md -| guide.md -| zh-cn/ -| README.md -| guide.md 那么对应的访问页面将是： docs/README.md =&gt; http://domain.com docs/guide.md =&gt; http://domain.com/guide docs/zh-cn/README.md =&gt; http://domain.com/zh-cn/ docs/zh-cn/guide.md =&gt; http://domain.com/zh-cn/guide 其他配置 定制侧边栏 显示目录 忽略副标题 定制导航栏 封面 其他所有配置请访问docsify中文文档 主题范例 这里贴一个我的主题配置：Demo _sidebar.md文件 &lt;!-- docs/_sidebar.md --&gt; - [About](README.md) - [Regularization](regex.md) - [Git](git.md) - [Jupyter](jupyter.md) - [Matplotlib](matplotlib.md) - [Emoji](emoji.md) - [Vim](vim.md) - [Algorithm](algorithm.md) - [Sort](sort.md) - [Pandas](pandas.md) - [Latex](mathjax_cmdeditor.md) index.html文件 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2943963344,3662015478&amp;fm=11&amp;gp=0.jpg&quot;/&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;教书的先生&lt;/title&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt; &lt;meta name=&quot;description&quot; content=&quot;Description&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;//unpkg.com/docsify/lib/themes/vue.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;文章正在加载中哦...&lt;/div&gt; &lt;!-- &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script&gt; window.$docsify = { name: 'Uppez', repo: 'https://github.com/Uppez/myproject.git' } &lt;/script&gt; &lt;script src=&quot;//unpkg.com/docsify/lib/docsify.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; window.$docsify = { loadSidebar: true } &lt;/script&gt; &lt;script src=&quot;//unpkg.com/docsify/lib/docsify.min.js&quot;&gt;&lt;/script&gt; --&gt; &lt;script&gt; window.$docsify = { auto2top: true, //当路线改变时，滚动到屏幕的顶部。 coverpage: true, //激活封面功能。如果为true，则会从中加载_coverpage.md。 executeScript: true, //执行页面上的脚本。只解析第一个脚本标记（演示）。如果存在Vue，则默认开启。 loadSidebar: true, //_sidebar.md如果为真，则从_sidebar.md文件加载边栏，否则从指定的路径加载。 loadNavbar: true,//_navbar.md如果为真，则从_navbar.md文件加载navbar ，否则从指定的路径加载。 mergeNavbar: true,//Navbar将在小屏幕上与侧边栏合并。 maxLevel: 4,//最大的内容表级别。 subMaxLevel: 2,//在自定义边栏中添加目录（TOC）。 //logo: '/_media/icon.svg' //侧边栏logo //name: 'NDZZ' //侧边栏名称 ga: 'UA-106147152-1', name: 'NDZZ', search: { noData: { '/de-de/': 'Keine Ergebnisse!', '/zh-cn/': '没有结果!', '/': 'No results!' }, paths: 'auto', placeholder: { '/de-de/': 'Suche', '/zh-cn/': '搜索', '/': 'Search' } }, formatUpdated: '{MM}/{DD} {HH}:{mm}', plugins: [ function(hook, vm) { hook.beforeEach(function (html) { var url = 'https://github.com/PYfive/docsify/blob/master/' + vm.route.file var editHtml = '[:memo: Edit Document](' + url + ')\\n' return html + '\\n----\\n' + 'Last modified {docsify-updated} ' + editHtml }) } ] } &lt;/script&gt; &lt;script src=&quot;//unpkg.com/docsify/lib/docsify.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//unpkg.com/docsify/lib/plugins/search.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//unpkg.com/docsify/lib/plugins/ga.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//unpkg.com/prismjs/components/prism-bash.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//unpkg.com/prismjs/components/prism-markdown.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//unpkg.com/prismjs/components/prism-nginx.min.js&quot;&gt;&lt;/script&gt; &lt;!-- &lt;script&gt; window.$docsify = { coverpage: true } &lt;/script&gt; &lt;script src=&quot;//unpkg.com/docsify&quot;&gt;&lt;/script&gt; --&gt; &lt;/body&gt; &lt;/html&gt; README.md文件 &lt;img src=&quot;https://i.loli.net/2019/08/12/dK7VPOTrvYeB2GR.jpg&quot; alt=&quot;m16Ikq.png&quot; border=&quot;0&quot; /&gt; 博主姓名:王荣胜 就读:河南理工大学本科生 我深信不疑的就是:他们以梦为马,我偏以码为梦~ 联系方式: - QQ:603329354 - QQ交流群:843108406 - 邮箱:603329354@qq.com 想更加了解我,请转至:[我的主页-教书的先生](https://sqdxwz.com) _coverpage.md文件（封面文件） &lt;img width=&quot;180px&quot; style=&quot;border-radius:50%&quot; bor src=&quot;https://i.loli.net/2019/08/19/83UnV26OjDofulC.jpg&quot;&gt; # 教书先生的学习文档 - 本文档是作者自学习内容，旨在为大家提供一个较详细的学习教程参考，如果本文能为您得到帮助，请给予支持！ [GitHub](&lt;https://github.com/Uppez&gt;) [开始阅读](README.md) 本地预览网站 运行一个本地服务器通过 docsify serve 可以方便的预览效果，而且提供 LiveReload 功能，可以让实时的预览。默认访问 http://localhost:3000 。 docsify serve docs 发布 直接将所有文件上传到Gituhb仓库或者仓库分支 ，然后开启Github Pages即可！ 推荐阅读 docsify官方中文文档 ","link":"https://Wangrongsheng.github.io/post/Z417lawsC/"},{"title":"Latex案例入门与拓展阅读","content":" Latex入门案例 输出一句话 \\documentclass{article} \\begin{document} hello, world \\end{document} 标题、作者和注释 \\documentclass{article} \\author{My Name} \\title{The Title} \\begin{document} \\maketitle hello, world % This is comment \\end{document} 章节和段落 \\documentclass{article} \\title{Hello World} \\begin{document} \\maketitle \\section{Hello China} China is in East Asia. \\subsection{Hello Beijing} Beijing is the capital of China. \\subsubsection{Hello Dongcheng District} \\paragraph{Tian'anmen Square}is in the center of Beijing \\subparagraph{Chairman Mao} is in the center of Tian'anmen Square \\subsection{Hello Guangzhou} \\paragraph{Sun Yat-sen University} is the best university in Guangzhou. \\end{document} 加入目录 \\documentclass{article} \\begin{document} \\tableofcontents \\section{Hello China} China is in East Asia. \\subsection{Hello Beijing} Beijing is the capital of China. \\subsubsection{Hello Dongcheng District} \\paragraph{Hello Tian'anmen Square}is in the center of Beijing \\subparagraph{Hello Chairman Mao} is in the center of Tian'anmen Square \\end{document} 换行 \\documentclass{article} \\begin{document} Beijing is the capital of China. New York is the capital of America. Amsterdam is \\\\ the capital \\\\ of Netherlands. \\end{document} 数学公式 \\documentclass{article} \\usepackage{amsmath} \\usepackage{amssymb} \\begin{document} The Newton's second law is F=ma. The Newton's second law is $F=ma$. The Newton's second law is F=ma The Newton's second law is F=ma Greek Letters $\\eta$ and $\\mu$ Fraction $\\frac{a}{b}$ Power $a^b$ Subscript $a_b$ Derivate $\\frac{\\partial y}{\\partial t} $ Vector $\\vec{n}$ Bold $\\mathbf{n}$ To time differential $\\dot{F}$ Matrix (lcr here means left, center or right for each column) \\[ \\left[ \\begin{array}{lcr} a1 &amp; b22 &amp; c333 \\\\ d444 &amp; e555555 &amp; f6 \\end{array} \\right] \\] Equations(here \\&amp; is the symbol for aligning different rows) \\begin{align} a+b&amp;=c\\\\ d&amp;=e+f+g \\end{align} \\[ \\left\\{ \\begin{aligned} &amp;a+b=c\\\\ &amp;d=e+f+g \\end{aligned} \\right. \\] \\end{document} 插入图片 先搜索到一个将图片转成eps文件的软件，然后将图片保存为一个名字如figure1.eps。 \\documentclass{article} \\usepackage{graphicx} \\begin{document} \\includegraphics[width=4.00in,height=3.00in]{figure1.eps} \\end{document} 简单表格 \\documentclass{article} \\begin{document} \\begin{tabular}{|c|c|} a &amp; b \\\\ c &amp; d\\\\ \\end{tabular} \\begin{tabular}{|c|c|} \\hline a &amp; b \\\\ \\hline c &amp; d\\\\ \\hline \\end{tabular} \\begin{center} \\begin{tabular}{|c|c|} \\hline a &amp; b \\\\ \\hline c &amp; d\\\\ \\hline \\end{tabular} \\end{center} \\end{document} 拓展知识 1.中文支持 曾经的LaTeX的中文支持是比较麻烦的一件事，但是现在使用MikTeX+WinEdt的中文支持非常容易。只需要把开头的\\documentclass{atricle}换成\\documentclass{ctexart}就可以了。如果是第一次使用ctexart的话，会自动下载和安装宏包和模板，之后就不会再下载了。 例子参考如下： \\documentclass{ctexart} \\begin{document} 你好，世界 \\end{document} 2.宏包 \\package{}就是在调用宏包，对计算机实在外行的同学姑且可以理解为工具箱。 每一个宏包里都定义了一些专门的命令，通过这些命令可以实现对于一类对象（如数学公式等）的统一排版（如字号字形），或用来实现一些功能（如插入图片或制作复杂表格）。 通常在\\documentclass之后，在\\begin{document}之前，将文章所需要涉及的宏包都罗列上。 对于新人而言比较常用的宏包有： 编辑数学公式的宏包：\\usepackage{amsmath}和 \\usepackage{amssymb} 编辑数学定理和证明过程的宏包：\\usepackage{amsthm} 插入图片的宏包：\\usepackage{graphicx} 复杂表格的宏包：\\usepackage{multirow} 3.模板 模板就是在\\documentclass{}后面的大括号里的内容。 在这一份教程中，我们使用的是LaTeX默认自带的模板article，以及中文模板ctexart。 模板就是实现我之前所介绍的LaTeX的经验总结的第二点的实现方式。 一篇文章，我们定义了section，定义了paragraph，就是没有定义字体字号，因为字体字号这一部分通常来说是在模板中实现的。 一个模板可以规定，section这个层级都用什么字体什么字号怎么对齐，subsection这个层级用什么字体什么字号怎么对齐，paragraph又用什么字体什么字号怎么对齐。 当然模板里还可以包含一些自定义的口令，以及页眉页脚页边距一类的页面设置。 由于模板的使用，在我的使用经验里来看，绝对不可能算是基本入门级的内容，所以在正文里当然不会提及。 如果有人实在想学，如果LaTeX已经接触到这个程度上了，那么再去翻其他厚一些的教材，也不亏了。 4.参考文献和制作幻灯片 做参考文献的时候，文章也已经快写到尾声了，而幻灯片更不是进阶一些的需求。对这两个功能有需求的LaTeX user，使用LaTeX也已经相当熟练了，自己去google一下或查阅其他厚教程是很理所当然的，一点也不冤枉。 在此我就只提供两个搜索关键词，参考文献可以搜bibtex，制作幻灯片可以搜beamer。 学习资源 中文LaTeX安装与使用 黄正华 LaTeX 中文模版收集 国外LaTex模板网站 LATEX排版心得-北京大学李东风 LaTex文档 bibTeX生成参考文献 ","link":"https://Wangrongsheng.github.io/post/q_XO3LDp-/"},{"title":"将Git与GitHub进行SSH连接","content":" Githu与Github 首先， Git是一款免费、开源的分布式版本控制系统； Github是用Git做版本控制的代码托管平台； 用一句话形容这二者的关系：Git是弓，你的代码是箭，Github是靶子。 Git是软件,它可在本地建立仓库,你写的代码的各个版本都可以存着 Github是网上仓库,你写的代码的各个版本都可以存着。 安装使用 安装Git 到Git官网下载与你正在使用的操作系统(本文以windows为例)相对应的文件。一般地，选择64-bit Git for Windows Setup。 安装时注意：勾选添加git到环境变量；在Windows Explorer Integration中勾选Git Bash Here。其余配置默认即可。 安装完成后(可能需要注销或重启)，在任意一个文件夹空白处右键，检查是否有Git Bash Here的选项。 注册GitHub 到GitHub官网注册一个账号。这里我以我的Github账号：WangRongsheng 为例进行演示。 配置git与github关联 设置邮箱和用户名 打开Git Bash(输入命令均在Git Bash中进行，以后不再声明)，分别输入下列命令(输入一行命令后需要回车，以后不再声明)： git config --global user.name &quot;WangRongsheng&quot; git config --global user.email &quot;603329354@qq.com&quot; 下面这一行设置可以增强输出命令的可读性： git config --global color.ui auto 用ssh生成公钥 输入： ssh-keygen -t rsa -C &quot;603329354@qq.com&quot; 回车之后会出现如下所示的输出，直接按回车即可： Generating public/private rsa key pair. Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa): (按回车键) Enter passphrase (empty for no passphrase): (按回车键) Enter same passphrase again: (按回车键) 这样密钥文件就生成了，默认在用户目录下，如：C:\\User\\xxx\\.ssh\\ 这个文件夹中。其中的xxx是你的windows用户名。 将公钥添加到github中 在C:\\user\\xxx\\.ssh\\文件夹中找到id_rsa.pub这个文件，用文本编辑器(如记事本)打开，复制里面的所有内容。 登陆github账号，点击头像旁的小三角展开，点击settings-SSH and GPG keys-New SSH key，在Title中取一个名字（任意），key中粘贴你刚刚复制的内容。然后点击Add SSH key即可。 测试是否关联成功 输入： ssh -T git@github.com 出现以下结果即为成功： Hi WangRongsheng! You've successfully authenticated, but GitHub does not provide shell access. ","link":"https://Wangrongsheng.github.io/post/hseFbgWv8/"},{"title":"Win10配置Java开发环境","content":" 前言 软件开发环境，是一个程序的运行的支撑，Java作为近年来最热门的编程语言之一，越来越多的新人程序员选择Java来学习，它的开发环境搭建也是学习和使用这一编程语言的基础。今天我们将在Windows上配置Java的开发环境。 安装使用 下载并安装JDK(JAVA Development Kit) JDK是整个Java开发的核心，它包含了Java的运行环境，Java工具和Java基础的类库。 下载地址： http://www.oracle.com/technetwork/java/javase/downloads/index.html 安装JDK只需要按正常步骤安装即可。 配置环境变量 基础配置 打开我的电脑，按照如下操作顺序：鼠标右键--&gt;属性--&gt;高级系统设置--&gt;高级--&gt;环境变量： 选择环境变量过后，我们可以看到如下界面，此时再选择系统变量--&gt;新建，此时将会弹出新建系统变量的对话框，在变量名处输入JAVA_HOME，在变量值中输入JDK的安装路径，点击确定。 修改path变量。在变量后增加两条路径： %JAVA_HOME%\\bin %JAVA_HOME%\\jre\\bin 新建/修改CLASSPATH 变量 如果存在 CLASSPATH 变量，选中点击 编辑。 如果没有，点击 新建。 输入/在已有的变量值后面添加： 变量名：CLASSPATH 变量值：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; 检验环境变量是否配置成功 Win+R打开dos窗口，分别输入java ,javac ,java –version： 如果你看到以上的内容，那么，恭喜，你的Java开发环境搭建成功了。 😁 ","link":"https://Wangrongsheng.github.io/post/HLzk_8i9x/"},{"title":"利用宝塔对服务器进行管理操作","content":" 域名与服务器购买 推荐服务器商： 阿里云 腾讯云 华为云 说明：建议在购买服务器商这里购买域名，不用来回切换界面操作吧！ 注意：如果你是学生，这些厂商都是有学生优惠的，一定要去用，可以便宜很多。 提示：不管在哪里购买域名，都是需要进行备案的。 服务器管理软件安装 那么服务器的管理软件都有什么呢？ 宝塔 Appnode 在这里，我以我的一个阿里云服务器+宝塔为例进行服务器的安装管理操作。 首先我们了解下宝塔是什么？ 宝塔Linux面板是提升运维效率的服务器管理软件，支持一键LAMP/LNMP/集群/监控/网站/FTP/数据库/JAVA等100多项服务器管理功能。 安装Putty Putty是一个SSH的服务器远程连接软件。 Putty官网下载 安装完成后是这样的： 获取服务器Ip和实例密码 首先我们去阿里云找到自己的服务器公网Ip和实例密码 ： 建议重置下实例密码，不然记不住啊： 拿到密码和ip我们就可以进行连接服务器了！ 连接远程服务器 我们打开Putty，并且填入公网Ip： 点击Open后，就可以进行登录了，这里： login as：root root@....'s password：（填写你的实例密码） 注意：你填写密码是不显示的，你直接进行回车登录就行。 像这个样子，你就可以登录上了： 然后我们去到宝塔 去复制安装命令，在这里解释下你的服务器其实就是一台远程可以操作的电脑，你可以安装Windows、Linux...等其他系统，当然你后期也可以对服务器的系统进行更换 。 我建议安装CentOS系统，别问我为什么，我就是！ 安装宝塔 贴进去运行就可以了： 安装完成后就会得到：管理台网址、登录账号、登录密码： 记得保存好！ 然后我们就可以登录到我们的服务器管理页面了！ 然后你就可以进行享用了，建博客、论坛... ","link":"https://Wangrongsheng.github.io/post/zpQW3OMHo/"},{"title":"Latex安装与使用入门","content":" LaTeX概览 摘自维基百科： LaTeX， 是一种基于TEX的排版系统，由美国电脑学家莱斯利·兰伯特在20世纪80年代初期开发，利用这种格式，即使用户没有排版和程序设计的知识也可以充分发挥由TEX所提供的强大功能，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学类文档。这个系统同样适用于生成从简单的信件到完整书籍的所有其他种类的文档。 简单点说：LaTeX 基于 TeX，主要目的是为了方便排版。在学术界的论文，尤其是数学、计算机等学科论文都是由 LaTeX 编写, 因为用它写数学公式非常漂亮。 我的一点理解： 在稍微了解一点 LaTeX 后，你会发现 LaTeX 的工作方式类似 web page，都是由源文件（.tex or .html）经由引擎（TeX or browser）渲染产生最终效果（得到 PDF 文件 或者 生成页面）。两者极其神似，包括语法规则与工作方式。所以呢，与 HTML 一样，入门其实很简单。 一般的规范写法中都是在 HTML 文件中写入 web page 的结构与内容，再由 css 控制页面生成的样式。当然你也可以选择在 HTML 中直接写入样式内容，不过这并不提倡。同样，在 LaTeX 有着同样的情况，你可以在 tex 源文件中同时写入内容和样式，也可以内容与样式分离，以网络上流传广泛的 清华大学 LaTeX 模板 为例，以.cls(class)结尾的 thuthesis.cls 便可看作是与 css 起到同样作用的样式文件。 LaTeX 有所谓宏包的概念，\\usepackage{foo} 即可使用宏包 foo 中定义的内容。所谓宏包就是一些写好的内容打包出来以便大家使用而已。这跟 C 语言的 include 是一致的，将文件加载进来进行使用。利用宏包，我们可以使用很多现成的好用的样式。当然了，如果要编写一个自己的个性化的宏包也是可以的，不过需要学习成本。 初期的话，我们可以选择一个 LaTeX 模板进行改造。不过第一次见到一些模板，可能会对其中很多文件的作用一头雾水. 下面是简单的介绍，详细内容可见在 LaTeX 中进行文学编程 ，当然更多介绍的话可以自行搜索。 LaTeX模板常见文件类型 功能简要介绍 .dtx Documented LaTeX sources，宏包重要部分 .ins installation，控制 TeX 从 .dtx 文件里释放宏包文件 .cfg config， 配置文件，可由上面两个文件生成 .sty style files，使用\\usepackage{...}命令进行加载 .cls classes files，类文件，使用\\documentclass{...}命令进行加载 .aux auxiliary， 辅助文件，不影响正常使用 .bst BibTeX style file，用来控制参考文献样式 class 与 style 似乎十分相像，它们在功能上的确很相似，但是也有区别。这里 是关于 .cls 与 .sty 文件的区别. 额外推荐阅读材料: 来自北京大学李东风老师的 LaTeX 排版心得 . 安装配置LaTeX LaTeX 配置环境很简单，只需 2 步： 根据平台选择一个 TeX 发行版 进行安装，建议选择最全功能最多的版本。 选择一个合适的 LaTeX 编辑器。 安装Tex发行版 TeX 发行版的概念相当于 Linux 及其发行版，Linux 内核虽然只有一个，但是有很多基于内核的不同特色的 Linux 发行版，Ubuntu，Fedora 等等不胜枚举。 OS TeX Distribution Windows CTeX Mac MacTeX Windows, Linux TeXLive Windows 用户推荐 TeXlive，不推荐 CTeX。 1.下载 官网下载 2.安装 解压后点击运行程序。 在线安装三个多G，有点慢，可以做点别的事情。 安装LaTeX 编辑器 建议编辑器安装texstudio。 1.下载 官网下载 直接download，然后安装 2.使用 修改语言： Options—-Configure TexStudio…—-General—-Language—-zh_CN 命令里正常的，如果不一样需要手动修改： 开始第一个 LaTeX 文档 打开 TeXstudio，新建一个 TeX 文件，写入以下内容： \\documentclass{article} \\begin{document} Here comes \\LaTeX! \\end{document} 点击 F5（默认快捷键）compile and view（编译并查看），即可看到效果。 至此，一个极简易的 LaTeX 文档已经完成。以后要做的事情不过是多用多查，熟能生巧。此外记得找本 LaTeX 的书籍看一下，一来对于更为精细的知识做一个了解，二来可以作为工具书查询。 推荐学习 B站-Latex入门 Latex编辑部 ","link":"https://Wangrongsheng.github.io/post/A6W5iJsli/"},{"title":"基于Mkdocs+Github建立自己的项目文档","content":" Mkdocs-material介绍 符合google material ui规范的静态文档网站生成器，使用markdown进行文档书写。 mkdocs python编写的markdown解释器、编译器，带有本地cli工具； 自带基于Tornado的小型http服务，用于本地调试； 内置一键式发布至GitHub Pages； 内置mkdocs风格、readthedocs风格的主题，并支持自定义主题； 支持调用python模块实现语法及渲染的扩展； mkdocs-material python模块，符合google material ui规范的mkdocs自定义主题； 针对特定语法、功能做了渲染优化； 根据客户端浏览器页面尺寸自动缩放，对PC、移动设备都友好； 丰富的页面配色，多达19种主体配色和16种悬停链接文字配色； 支持中文搜索； 支持统计功能，如百度统计，谷歌统计； 安装 命令安装 打开命令行并运行命令： pip install mkdocs mkdocs-material 若下载慢，可更换安装源为豆瓣： pip install --trusted-host pypi.douban.com -i http://pypi.douban.com/simple/ mkdocs mkdocs-material 这里放出一个我的环境配置： python环境: 3.6.6 python包环境： 包名 模块名 版本 mkdocs mkdocs 1.0.4 mkdocs-material material 3.0.6 Markdown markdown 3.0.1 pymdown-extensions pymdownx 6.0 初始化项目 mkdocs new my-project 命令中的my-project为生成的文件包的名称，可以修改为自己想要的。 会生成my-project目录，进入该目录里，可以看到默认放置了一些文件，包括mkdocs.yml，这是主配置文件。 修改样式 通过上一步我们生成了一个.yml文件，也就是我们的配置文件，接下来就是按照自己的想法配置啦。 注意要修改的东西的代码全部放在.yml文件就可以，会自动解析的。 修改主题 Mkdocs生成后会有一个自带的主题，大概是这个样子的：主题参考网站 ，但是如果你不喜欢，你可以修改成另外一个：第二种主题参考网站 。 第二种主题在mkdocs.yml里添加配置： theme: name: material 添加扩展 在mkdocs.yml里添加配置： markdown_extensions: - admonition - codehilite: guess_lang: false linenums: false - toc: permalink: true - footnotes - meta - def_list - pymdownx.arithmatex - pymdownx.betterem: smart_enable: all - pymdownx.caret - pymdownx.critic - pymdownx.details - pymdownx.emoji: emoji_generator: !!python/name:pymdownx.emoji.to_png - pymdownx.inlinehilite - pymdownx.magiclink - pymdownx.mark - pymdownx.smartsymbols - pymdownx.superfences - pymdownx.tasklist - pymdownx.tilde 添加百度统计 在百度统计里创建添加站点，确定后会看到javascript代码，复制代码； 在docs目录下新建js目录，并在docs/js目录里放置baidu-tongji.js，将复制的代码粘贴进来； 最后在mkdocs.yml里新增如下配置: extra_javascript: - 'js/baidu-tongji.js' 修改配色 mkdocs-material支持google material ui规范定义的19种主体配色和16种鼠标悬停超链接文字配色。 在mkdocs.yml里添加配置: extra: palette: primary: 'Blue Grey' accent: 'Pink' 代码后面的颜色可以修改为自己喜欢的！ 添加中文搜索 虽然search功能(lunr.js)暂不直接支持中文，但测试发现设置为日语后，中文和英文搜索都可以使用。 extra: search: language: 'jp' 另外，搜索对话框的显示文字，默认为英文，可以设置为中文。例如&quot;search&quot;改为中文后就叫&quot;搜索&quot;。 theme: language: 'zh' 添加页面 在my-project/docs/里放置.md文件，可以自行组织目录结构。 然后在mkdocs.yml里添加，比如这样: nav: - 介绍: index.md - 安装: - 本地环境搭建: install/local.md - 发布至GitHub Pages: install/github-pages.md - 发布至自己的HTTP Server: install/http-server.md - 语法: - 语法总览: syntax/main.md - 标题: syntax/headline.md - 段落: syntax/paragraph.md 上面的index.md就是放置在my-project/docs/index.md。 上面的local.md就是放置在my-project/docs/install/local.md。 注意：由于是yaml格式，因此首先要符合yaml的语法要求，docs下需要一个index.md，作为站点首页，文档层次结构虽然可以很多层，但最佳实践是控制在2层内，最多不要超过3层，否则展示会不够友好。 主题范例 这里我给出一个我的主题内容搭配，可以直接使用： site_name: AI学习 site_author: 王荣胜 repo_url: https://github.com/WangRongsheng site_url: https://github.com/WangRongsheng site_description: 越努力越幸运 theme: language: 'zh' feature: tabs: true name: 'material' palette: primary: 'indigo' accent: 'indigo' font: text: 'Ubuntu' code: 'Ubuntu Mono' include_search_page: false search_index_only: true extra: search: language: 'zh' social: - type: 'github' link: 'https://github.com/WangRongsheng' markdown_extensions: - admonition - codehilite: guess_lang: false - toc: permalink: true extra_css: - '_static/extra.css' nav: - 介绍: - 介绍: index.md - 关于: about.md - 信息: tj.md - 机器学习: - 1. K-最近邻算法: ai/knn.md - 2. K-均值算法: ai/k-means.md - 3. 基于矩阵分解的推荐系统: ai/mf.md - 4. 基于用户的协同过滤: ai/usercf.md - 5. 基于项目的协同过滤: ai/itemcf.md - 6. 朴素贝叶斯分类: ai/psbys.md - 7. 贝叶斯个性化排序: ai/bpr.md - 8. 决策树: ai/jcs.md - 9. 随机森林: ai/sjsl.md markdown_extensions: - admonition - codehilite: guess_lang: false - toc: permalink: true # Extensions markdown_extensions: - admonition - codehilite: guess_lang: false linenums: true - def_list - footnotes - meta - toc: permalink: true - pymdownx.arithmatex - pymdownx.caret - pymdownx.critic - pymdownx.details - pymdownx.emoji: emoji_generator: !!python/name:pymdownx.emoji.to_svg - pymdownx.inlinehilite - pymdownx.keys - pymdownx.magiclink - pymdownx.mark - pymdownx.progressbar - pymdownx.smartsymbols - pymdownx.superfences: custom_fences: - name: math class: arithmatex format: !!python/name:pymdownx.arithmatex.fence_mathjax_format - pymdownx.tasklist: custom_checkbox: true - pymdownx.tilde 运行 在my-project目录里执行： mkdocs serve 通过浏览器访问本地ip的8000端口（比如http://127.0.0.1:8000/） 注意一定要在my-project目录执行！ 发布 发布到GitHub pages 通过mkdocs gh-deploy这行命令自动编译出html并发布至GitHub pages，步骤如下： 初始化repo 在github上创建一个repo，名字叫my-project（可以是其他名，这里先假设叫my-project），创建repo时候选择初始化带有README.md； 将repo同步到本地，使用git clone； 导入项目 将mkdocs根目录（即my-project目录）下的所有东西移到刚刚git clone下来的git目录下； 然后可以将最早创建的mkdocs根目录（即my-project目录）删除了； 发布 在本地git目录下执行： mkdocs gh-deploy 发布到个人HTTP Server 通过mkdocs build这行命令编译出html并手动同步至http server的根目录： 生成站点文件 在git目录下执行命令： mkdocs build 命令执行完毕后可以看到site目录。 发布至http server 将site目录里的所有东西拷贝到http server的根目录下。 最佳实践 如果你想要写好一份项目或者其他的文档，你不可避免的要去学习使用Markdown ，这里推荐你去多多练习下： Markdown在线编译器 Markdown基础语法 ","link":"https://Wangrongsheng.github.io/post/WPxZVmq1t/"},{"title":"Latex公式大全","content":" Latex简介 LaTeX是一种基于ΤΕΧ的排版系统，由美国计算机学家莱斯利·兰伯特（Leslie Lamport）在20世纪80年代初期开发。 利用这种格式，即使使用者没有排版和程序设计的知识也可以充分发挥由TeX所提供的强大功能，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。 对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学类文档。这个系统同样适用于生成从简单的信件到完整书籍的所有其他种类的文档。 Latex语法基础 如何插入公式 LaTeX\\LaTeXLATE​X 的数学公式有两种：行中公式和独立公式（行间公式）。行中公式放在文中与其它文字混编，独立公式单独成行。 行中公式可以用如下方法表示： $ 数学公式 $ 独立公式可以用如下方法表示： $$ 数学公式 $$ 函数、符号及特殊字符 声调 / 变音符号 \\dot{a}, \\ddot{a}, \\acute{a}, \\grave{a} a˙,a¨,aˊ,aˋ{\\displaystyle {\\dot {a}},{\\ddot {a}},{\\acute {a}},{\\grave {a}}}a˙,a¨,aˊ,aˋ \\check{a}, \\breve{a}, \\tilde{a}, \\bar{a} aˇ,a˘,a~,aˉ{\\displaystyle {\\check {a}},{\\breve {a}},{\\tilde {a}},{\\bar {a}}}aˇ,a˘,a~,aˉ \\hat{a}, \\widehat{a}, \\vec{a} a^,a^,a⃗{\\displaystyle {\\hat {a}},{\\widehat {a}},{\\vec {a}}}a^,a,a 标准函数 指数 \\exp_a b = a^b, \\exp b = e^b, 10^m exp⁡ab=ab,exp⁡b=eb,10m{\\displaystyle \\exp _{a}b=a^{b},\\exp b=e^{b},10^{m}}expa​b=ab,expb=eb,10m 对数 \\ln c, \\lg d = \\log e, \\log_{10} f ln⁡c,lg⁡d=log⁡e,log⁡10f{\\displaystyle \\ln c,\\lg d=\\log e,\\log _{10}f}lnc,lgd=loge,log10​f 三角函数 \\sin a, \\cos b, \\tan c, \\cot d, \\sec e, \\csc f sin⁡a,cos⁡b,tan⁡c,cot⁡d,sec⁡e,csc⁡f{\\displaystyle \\sin a,\\cos b,\\tan c,\\cot d,\\sec e,\\csc f}sina,cosb,tanc,cotd,sece,cscf \\arcsin a, \\arccos b, \\arctan c arcsin⁡a,arccos⁡b,arctan⁡c{\\displaystyle \\arcsin a,\\arccos b,\\arctan c}arcsina,arccosb,arctanc \\arccot d, \\arcsec e, \\arccsc f arccot⁡d,arcsec⁡e,arccsc⁡f{\\displaystyle \\operatorname {arccot} d,\\operatorname {arcsec} e,\\operatorname {arccsc} f}arccotd,arcsece,arccscf \\sinh a, \\cosh b, \\tanh c, \\coth d sinh⁡a,cosh⁡b,tanh⁡c,coth⁡d{\\displaystyle \\sinh a,\\cosh b,\\tanh c,\\coth d}sinha,coshb,tanhc,cothd \\operatorname{sh}k, \\operatorname{ch}l, \\operatorname{th}m, \\operatorname{coth}n sh⁡k,ch⁡l,th⁡m,coth⁡n{\\displaystyle \\operatorname {sh} k,\\operatorname {ch} l,\\operatorname {th} m,\\operatorname {coth} n}shk,chl,thm,cothn \\operatorname{argsh}o, \\operatorname{argch}p, \\operatorname{argth}q argsh⁡o,argch⁡p,argth⁡q{\\displaystyle \\operatorname {argsh} o,\\operatorname {argch} p,\\operatorname {argth} q}argsho,argchp,argthq 符号函数，绝对值 \\sgn r, \\left\\vert s \\right\\vert sgn⁡r,∣s∣{\\displaystyle \\operatorname {sgn} r,\\left\\vert s\\right\\vert }sgnr,∣s∣ 最大值，最小值 \\min(x,y), \\max(x,y) min⁡(x,y),max⁡(x,y){\\displaystyle \\min(x,y),\\max(x,y)}min(x,y),max(x,y) 界限，极限 \\min x, \\max y, \\inf s, \\sup t min⁡x,max⁡y,inf⁡s,sup⁡t{\\displaystyle \\min x,\\max y,\\inf s,\\sup t}minx,maxy,infs,supt \\lim u, \\liminf v, \\limsup w lim⁡u,lim inf⁡v,lim sup⁡w{\\displaystyle \\lim u,\\liminf v,\\limsup w}limu,liminfv,limsupw \\lim_{x \\to \\infty} \\frac{1}{n(n+1)} lim⁡x→∞1n(n+1){\\displaystyle \\lim_{x \\to \\infty} \\frac{1}{n(n+1)}}x→∞lim​n(n+1)1​ \\dim p, \\deg q, \\det m, \\ker\\phi dim⁡p,deg⁡q,det⁡m,ker⁡ϕ{\\displaystyle \\dim p,\\deg q,\\det m,\\ker \\phi}dimp,degq,detm,kerϕ 投射 \\Pr j, \\hom l, \\lVert z \\rVert, \\arg z Pr⁡j,hom⁡l,∥z∥,arg⁡z{\\displaystyle \\Pr j,\\hom l,\\lVert z\\rVert ,\\arg z}Prj,homl,∥z∥,argz 微分及导数 dt, \\mathrm{d}t, \\partial t, \\nabla\\psi dt,dt,∂t,∇ψ{\\displaystyle dt,\\mathrm {d} t,\\partial t,\\nabla \\psi }dt,dt,∂t,∇ψ dy/dx, \\mathrm{d}y/\\mathrm{d}x, \\frac{dy}{dx}, \\frac{\\mathrm{d}y}{\\mathrm{d}x}, \\frac{\\partial^2}{\\partial x_1\\partial x_2}y dy/dx,dy/dx,dydx,dydx,∂2∂x1∂x2y{\\displaystyle dy/dx,\\mathrm {d} y/\\mathrm {d} x,{\\frac {dy}{dx}},{\\frac {\\mathrm {d} y}{\\mathrm {d} x}},{\\frac {\\partial ^{2}}{\\partial x_{1}\\partial x_{2}}}y}dy/dx,dy/dx,dxdy​,dxdy​,∂x1​∂x2​∂2​y \\prime, \\backprime, f^\\prime, f', f'', f^{(3)}, \\dot y, \\ddot y ′,‵,f′,f′,f′′,f(3) ⁣,y˙,y¨{\\displaystyle \\prime ,\\backprime ,f^{\\prime},f&#x27;,f&#x27;&#x27;,f^{(3)}\\!,{\\dot {y}},{\\ddot {y}}}′,‵,f′,f′,f′′,f(3),y˙​,y¨​ 类字母符号及常数 \\infty, \\aleph, \\complement, \\backepsilon, \\eth, \\Finv, \\hbar ∞,ℵ,∁,∍,ð,Ⅎ,ℏ{\\displaystyle \\infty ,\\aleph ,\\complement ,\\backepsilon ,\\eth ,\\Finv ,\\hbar}∞,ℵ,∁,∍,ð,Ⅎ,ℏ \\Im, \\imath, \\jmath, \\Bbbk, \\ell, \\mho, \\wp, \\Re, \\circledS ℑ,ı,ȷ,k,ℓ,℧,℘,ℜ,Ⓢ{\\displaystyle \\Im ,\\imath ,\\jmath ,\\Bbbk ,\\ell ,\\mho ,\\wp ,\\Re ,\\circledS }ℑ,ı,ȷ,k,ℓ,℧,℘,ℜ,Ⓢ 模运算 s_k \\equiv 0 \\pmod{m} sk≡0(modm){\\displaystyle s_{k}\\equiv 0{\\pmod {m}}}sk​≡0(modm) a \\bmod b a mod b{\\displaystyle a \\bmod b}amodb \\gcd(m, n), \\operatorname{lcm}(m, n) gcd⁡(m,n),lcm⁡(m,n){\\displaystyle \\gcd(m,n),\\operatorname {lcm} (m,n)}gcd(m,n),lcm(m,n) \\mid, \\nmid, \\shortmid, \\nshortmid ∣,∤,∣,{\\displaystyle \\mid ,\\nmid ,\\shortmid ,\\nshortmid}∣,∤,∣, 根号 \\surd, \\sqrt{2}, \\sqrt[n]{}, \\sqrt[3]{\\frac{x^3+y^3}{2}} √,2,n,x3+y323{\\displaystyle \\surd ,{\\sqrt {2}},{\\sqrt[{n}]{}},{\\sqrt[{3}]{\\frac {x^{3}+y^{3}}{2}}}}√,2​,n​,32x3+y3​​ 运算符 +, -, \\pm, \\mp, \\dotplus +,−,±,∓,∔{\\displaystyle +,-,\\pm ,\\mp ,\\dotplus}+,−,±,∓,∔ \\times, \\div, \\divideontimes, /, \\backslash ×,÷,⋇,/,\\{\\displaystyle \\times ,\\div ,\\divideontimes ,/,\\backslash}×,÷,⋇,/,\\ \\cdot, * \\ast, \\star, \\circ, \\bullet ⋅,∗∗,⋆,∘,∙{\\displaystyle \\cdot ,*\\ast ,\\star ,\\circ ,\\bullet}⋅,∗∗,⋆,∘,∙ \\boxplus, \\boxminus, \\boxtimes, \\boxdot ⊞,⊟,⊠,⊡{\\displaystyle \\boxplus ,\\boxminus ,\\boxtimes ,\\boxdot}⊞,⊟,⊠,⊡ \\oplus, \\ominus, \\otimes, \\oslash, \\odot ⊕,⊖,⊗,⊘,⊙{\\displaystyle \\oplus ,\\ominus ,\\otimes ,\\oslash ,\\odot}⊕,⊖,⊗,⊘,⊙ \\circleddash, \\circledcirc, \\circledast ⊝,⊚,⊛{\\displaystyle \\circleddash ,\\circledcirc ,\\circledast}⊝,⊚,⊛ \\bigoplus, \\bigotimes, \\bigodot ⨁,⨂,⨀{\\displaystyle \\bigoplus ,\\bigotimes ,\\bigodot}⨁,⨂,⨀ 集合 \\{ \\}, \\O \\empty \\emptyset, \\varnothing {},∅∅∅,∅{\\displaystyle \\{\\},\\emptyset \\emptyset \\emptyset ,\\varnothing }{},∅∅∅,∅ \\in, \\notin \\not\\in, \\ni, \\not\\ni ∈,∉∈,∋,∋{\\displaystyle \\in ,\\notin \\not \\in ,\\ni ,\\not \\ni}∈,∈/​​∈,∋,​∋ \\cap, \\Cap, \\sqcap, \\bigcap ∩,⋒,⊓,⋂{\\displaystyle \\cap ,\\Cap ,\\sqcap ,\\bigcap}∩,⋒,⊓,⋂ \\cup, \\Cup, \\sqcup, \\bigcup, \\bigsqcup, \\uplus, \\biguplus ∪,⋓,⊔,⋃,⨆,⊎,⨄{\\displaystyle \\cup ,\\Cup ,\\sqcup ,\\bigcup ,\\bigsqcup ,\\uplus ,\\biguplus}∪,⋓,⊔,⋃,⨆,⊎,⨄ \\setminus, \\smallsetminus, \\times ∖,∖,×{\\displaystyle \\setminus ,\\smallsetminus ,\\times}∖,∖,× \\subset, \\Subset, \\sqsubset ⊂,⋐,⊏{\\displaystyle \\subset ,\\Subset ,\\sqsubset}⊂,⋐,⊏ \\supset, \\Supset, \\sqsupset ⊃,⋑,⊐{\\displaystyle \\supset ,\\Supset ,\\sqsupset}⊃,⋑,⊐ \\subseteq, \\nsubseteq, \\subsetneq, \\varsubsetneq, \\sqsubseteq ⊆,⊈,⊊,,⊑{\\displaystyle \\subseteq ,\\nsubseteq ,\\subsetneq ,\\varsubsetneq ,\\sqsubseteq}⊆,⊈,⊊,,⊑ \\supseteq, \\nsupseteq, \\supsetneq, \\varsupsetneq, \\sqsupseteq ⊇,⊉,⊋,,⊒{\\displaystyle \\supseteq ,\\nsupseteq ,\\supsetneq ,\\varsupsetneq ,\\sqsupseteq}⊇,⊉,⊋,,⊒ \\subseteqq, \\nsubseteqq, \\subsetneqq, \\varsubsetneqq ⫅,,⫋,{\\displaystyle \\subseteqq ,\\nsubseteqq ,\\subsetneqq ,\\varsubsetneqq}⫅,,⫋, \\supseteqq, \\nsupseteqq, \\supsetneqq, \\varsupsetneqq ⫆,,⫌,{\\displaystyle \\supseteqq ,\\nsupseteqq ,\\supsetneqq ,\\varsupsetneqq}⫆,,⫌, 关系符号 =, \\ne, \\neq, \\equiv, \\not\\equiv =,≠,≠,≡,≡{\\displaystyle =,\\neq ,\\neq ,\\equiv ,\\not \\equiv}=,​=,​=,≡,​≡ \\doteq, \\doteqdot, \\overset{\\underset{\\mathrm{def}}{}}{=}, := ≐,≑,=def,:={\\displaystyle \\doteq ,\\doteqdot ,{\\overset {\\underset {\\mathrm {def} }{}}{=}},:=}≐,≑,=def​,:= \\sim, \\nsim, \\backsim, \\thicksim, \\simeq, \\backsimeq, \\eqsim, \\cong, \\ncong ∼,≁,∽,∼,≃,⋍,≂,≅,≆{\\displaystyle \\sim ,\\nsim ,\\backsim ,\\thicksim ,\\simeq ,\\backsimeq ,\\eqsim ,\\cong ,\\ncong}∼,≁,∽,∼,≃,⋍,≂,≅,≆ \\approx, \\thickapprox, \\approxeq, \\asymp, \\propto, \\varpropto ≈,≈,≊,≍,∝,∝{\\displaystyle \\approx ,\\thickapprox ,\\approxeq ,\\asymp ,\\propto ,\\varpropto}≈,≈,≊,≍,∝,∝ &lt;, \\nless, \\ll, \\not\\ll, \\lll, \\not\\lll, \\lessdot &lt;,≮,≪,≪,⋘,⋘,⋖{\\displaystyle &lt;,\\nless ,\\ll ,\\not \\ll ,\\lll ,\\not \\lll ,\\lessdot}&lt;,≮,≪,​≪,⋘,​⋘,⋖ &gt;, \\ngtr, \\gg, \\not\\gg, \\ggg, \\not\\ggg, \\gtrdot &gt;,≯,≫,≫,⋙,⋙,⋗{\\displaystyle&gt;,\\ngtr ,\\gg ,\\not \\gg ,\\ggg ,\\not \\ggg ,\\gtrdot }&gt;,≯,≫,​≫,⋙,​⋙,⋗ \\le, \\leq, \\lneq, \\leqq, \\nleq, \\nleqq, \\lneqq, \\lvertneqq ≤,≤,⪇,≦,≰,,≨,{\\displaystyle \\leq ,\\leq ,\\lneq ,\\leqq ,\\nleq ,\\nleqq ,\\lneqq ,\\lvertneqq}≤,≤,⪇,≦,≰,,≨, \\ge, \\geq, \\gneq, \\geqq, \\ngeq, \\ngeqq, \\gneqq, \\gvertneqq ≥,≥,⪈,≧,≱,,≩,{\\displaystyle \\geq ,\\geq ,\\gneq ,\\geqq ,\\ngeq ,\\ngeqq ,\\gneqq ,\\gvertneqq}≥,≥,⪈,≧,≱,,≩, \\lessgtr, \\lesseqgtr, \\lesseqqgtr, \\gtrless, \\gtreqless, \\gtreqqless ≶,⋚,⪋,≷,⋛,⪌{\\displaystyle \\lessgtr ,\\lesseqgtr ,\\lesseqqgtr ,\\gtrless ,\\gtreqless ,\\gtreqqless}≶,⋚,⪋,≷,⋛,⪌ \\leqslant, \\nleqslant, \\eqslantless ⩽,,⪕{\\displaystyle \\leqslant ,\\nleqslant ,\\eqslantless}⩽,,⪕ \\geqslant, \\ngeqslant, \\eqslantgtr ⩾,,⪖{\\displaystyle \\geqslant ,\\ngeqslant ,\\eqslantgtr}⩾,,⪖ \\lesssim, \\lnsim, \\lessapprox, \\lnapprox ≲,⋦,⪅,⪉{\\displaystyle \\lesssim ,\\lnsim ,\\lessapprox ,\\lnapprox}≲,⋦,⪅,⪉ \\gtrsim, \\gnsim, \\gtrapprox, \\gnapprox ≳,⋧,⪆,⪊{\\displaystyle \\gtrsim ,\\gnsim ,\\gtrapprox ,\\gnapprox}≳,⋧,⪆,⪊ \\prec, \\nprec, \\preceq, \\npreceq, \\precneqq ≺,⊀,⪯,⋠,⪵{\\displaystyle \\prec ,\\nprec ,\\preceq ,\\npreceq ,\\precneqq}≺,⊀,⪯,⋠,⪵ \\succ, \\nsucc, \\succeq, \\nsucceq, \\succneqq ≻,⊁,⪰,⋡,⪶{\\displaystyle \\succ ,\\nsucc ,\\succeq ,\\nsucceq ,\\succneqq}≻,⊁,⪰,⋡,⪶ \\preccurlyeq, \\curlyeqprec ≼,⋞{\\displaystyle \\preccurlyeq ,\\curlyeqprec}≼,⋞ \\succcurlyeq, \\curlyeqsucc ≽,⋟{\\displaystyle \\succcurlyeq ,\\curlyeqsucc}≽,⋟ \\precsim, \\precnsim, \\precapprox, \\precnapprox ≾,⋨,⪷,⪹{\\displaystyle \\precsim ,\\precnsim ,\\precapprox ,\\precnapprox}≾,⋨,⪷,⪹ \\succsim, \\succnsim, \\succapprox, \\succnapprox ≿,⋩,⪸,⪺{\\displaystyle \\succsim ,\\succnsim ,\\succapprox ,\\succnapprox}≿,⋩,⪸,⪺ 几何符号 \\parallel, \\nparallel, \\shortparallel, \\nshortparallel ∥,∦,∥,{\\displaystyle \\parallel ,\\nparallel ,\\shortparallel ,\\nshortparallel}∥,∦,∥, \\perp, \\angle, \\sphericalangle, \\measuredangle, 45^\\circ ⊥,∠,∢,∡,45∘{\\displaystyle \\perp ,\\angle ,\\sphericalangle ,\\measuredangle ,45^{\\circ}}⊥,∠,∢,∡,45∘ \\Box, \\blacksquare, \\diamond, \\Diamond \\lozenge, \\blacklozenge, \\bigstar □,■,⋄,◊◊,⧫,★{\\displaystyle \\Box ,\\blacksquare ,\\diamond ,\\Diamond \\lozenge ,\\blacklozenge ,\\bigstar}□,■,⋄,◊◊,⧫,★ \\bigcirc, \\triangle, \\bigtriangleup, \\bigtriangledown ◯,△,△,▽{\\displaystyle \\bigcirc ,\\triangle ,\\bigtriangleup ,\\bigtriangledown}◯,△,△,▽ \\vartriangle, \\triangledown △,▽{\\displaystyle \\vartriangle ,\\triangledown}△,▽ \\blacktriangle, \\blacktriangledown, \\blacktriangleleft, \\blacktriangleright ▲,▼,◀,▶{\\displaystyle \\blacktriangle ,\\blacktriangledown ,\\blacktriangleleft ,\\blacktriangleright}▲,▼,◀,▶ 逻辑符号 \\forall, \\exists, \\nexists ∀,∃,∄{\\displaystyle \\forall ,\\exists ,\\nexists}∀,∃,∄ \\therefore, \\because, \\And ∴,∵,&amp;{\\displaystyle \\therefore ,\\because ,\\And}∴,∵,&amp; \\or \\lor \\vee, \\curlyvee, \\bigvee ∨,∨,∨,⋎,⋁{\\displaystyle \\lor ,\\lor ,\\vee ,\\curlyvee ,\\bigvee}∨,∨,∨,⋎,⋁ \\and \\land \\wedge, \\curlywedge, \\bigwedge ∧,∧,∧,⋏,⋀{\\displaystyle \\land ,\\land ,\\wedge ,\\curlywedge ,\\bigwedge}∧,∧,∧,⋏,⋀ \\bar{q}, \\bar{abc}, \\overline{q}, \\overline{abc}, \\lnot \\neg, \\not\\operatorname{R}, \\bot, \\top qˉ,abcˉ,q‾,abc‾,{\\displaystyle {\\bar {q}},{\\bar {abc}},{\\overline {q}},{\\overline {abc}},}qˉ​,abcˉ,q​,abc, ¬¬,R⁡,⊥,⊤{\\displaystyle \\lnot \\neg ,\\not \\operatorname {R} ,\\bot ,\\top }¬¬,​R,⊥,⊤ \\vdash \\dashv, \\vDash, \\Vdash, \\models ⊢,⊣,⊨,⊩,⊨{\\displaystyle \\vdash ,\\dashv ,\\vDash ,\\Vdash ,\\models}⊢,⊣,⊨,⊩,⊨ \\Vvdash \\nvdash \\nVdash \\nvDash \\nVDash ⊪,⊬,⊮,⊭,⊯{\\displaystyle \\Vvdash ,\\nvdash ,\\nVdash ,\\nvDash ,\\nVDash}⊪,⊬,⊮,⊭,⊯ \\ulcorner \\urcorner \\llcorner \\lrcorner ┌┐└┘{\\displaystyle \\ulcorner \\urcorner \\llcorner \\lrcorner}┌┐└┘ 箭头 \\Rrightarrow, \\Lleftarrow ⇛,⇚{\\displaystyle \\Rrightarrow ,\\Lleftarrow}⇛,⇚ \\Rightarrow, \\nRightarrow, \\Longrightarrow \\implies ⇒,⇏,⟹, ⟹ {\\displaystyle \\Rightarrow ,\\nRightarrow ,\\Longrightarrow ,\\implies}⇒,⇏,⟹,⟹ \\Leftarrow, \\nLeftarrow, \\Longleftarrow ⇐,⇍,⟸{\\displaystyle \\Leftarrow ,\\nLeftarrow ,\\Longleftarrow}⇐,⇍,⟸ \\Leftrightarrow, \\nLeftrightarrow, \\Longleftrightarrow \\iff ⇔,⇎,⟺ ⟺ {\\displaystyle \\Leftrightarrow ,\\nLeftrightarrow ,\\Longleftrightarrow \\iff}⇔,⇎,⟺⟺ \\Uparrow, \\Downarrow, \\Updownarrow ⇑,⇓,⇕{\\displaystyle \\Uparrow ,\\Downarrow ,\\Updownarrow}⇑,⇓,⇕ \\rightarrow \\to, \\nrightarrow, \\longrightarrow →→,↛,⟶{\\displaystyle \\rightarrow \\to ,\\nrightarrow ,\\longrightarrow}→→,↛,⟶ \\leftarrow \\gets, \\nleftarrow, \\longleftarrow ←←,↚,⟵{\\displaystyle \\leftarrow \\gets ,\\nleftarrow ,\\longleftarrow}←←,↚,⟵ \\leftrightarrow, \\nleftrightarrow, \\longleftrightarrow ↔,↮,⟷{\\displaystyle \\leftrightarrow ,\\nleftrightarrow ,\\longleftrightarrow}↔,↮,⟷ \\uparrow, \\downarrow, \\updownarrow ↑,↓,↕{\\displaystyle \\uparrow ,\\downarrow ,\\updownarrow}↑,↓,↕ \\nearrow, \\swarrow, \\nwarrow, \\searrow ↗,↙,↖,↘{\\displaystyle \\nearrow ,\\swarrow ,\\nwarrow ,\\searrow}↗,↙,↖,↘ \\mapsto, \\longmapsto ↦,⟼{\\displaystyle \\mapsto ,\\longmapsto}↦,⟼ \\rightharpoonup \\rightharpoondown \\leftharpoonup \\leftharpoondown \\upharpoonleft \\upharpoonright \\downharpoonleft \\downharpoonright \\rightleftharpoons \\leftrightharpoons ⇀,⇁,↼,↽,↿,↾,⇃,⇂,⇌,⇋{\\displaystyle \\rightharpoonup ,\\rightharpoondown ,\\leftharpoonup ,\\leftharpoondown ,\\upharpoonleft ,\\upharpoonright ,\\downharpoonleft ,\\downharpoonright ,\\rightleftharpoons ,\\leftrightharpoons}⇀,⇁,↼,↽,↿,↾,⇃,⇂,⇌,⇋ \\curvearrowleft \\circlearrowleft \\Lsh \\upuparrows \\rightrightarrows \\rightleftarrows \\rightarrowtail \\looparrowright ↶,↺,↰,⇈,⇉,⇄,↣,↬{\\displaystyle \\curvearrowleft ,\\circlearrowleft ,\\Lsh ,\\upuparrows ,\\rightrightarrows ,\\rightleftarrows ,\\rightarrowtail ,\\looparrowright}↶,↺,↰,⇈,⇉,⇄,↣,↬ \\curvearrowright \\circlearrowright \\Rsh \\downdownarrows \\leftleftarrows \\leftrightarrows \\leftarrowtail \\looparrowleft ↷,↻,↱,⇊,⇇,⇆,↢,↫{\\displaystyle \\curvearrowright ,\\circlearrowright ,\\Rsh ,\\downdownarrows ,\\leftleftarrows ,\\leftrightarrows ,\\leftarrowtail ,\\looparrowleft}↷,↻,↱,⇊,⇇,⇆,↢,↫ \\hookrightarrow \\hookleftarrow \\multimap \\leftrightsquigarrow \\rightsquigarrow \\twoheadrightarrow \\twoheadleftarrow ↪,↩,⊸,↭,⇝,↠,↞{\\displaystyle \\hookrightarrow ,\\hookleftarrow ,\\multimap ,\\leftrightsquigarrow ,\\rightsquigarrow ,\\twoheadrightarrow ,\\twoheadleftarrow}↪,↩,⊸,↭,⇝,↠,↞ 特殊符号 省略号：数学公式中常见的省略号有两种，\\ldots 表示与文本底线对齐的省略号，\\cdots 表示与文本中线对齐的省略号。 \\amalg \\% \\dagger \\ddagger \\ldots \\cdots ⨿%†‡…⋯{\\displaystyle \\amalg \\%\\dagger \\ddagger \\ldots \\cdots}⨿%†‡…⋯ \\smile \\frown \\wr \\triangleleft \\triangleright ⌣⌢≀◃▹{\\displaystyle \\smile \\frown \\wr \\triangleleft \\triangleright}⌣⌢≀◃▹ \\diamondsuit, \\heartsuit, \\clubsuit, \\spadesuit, \\Game, \\flat, \\natural, \\sharp ♢,♡,♣,♠,⅁,♭,♮,♯{\\displaystyle \\diamondsuit ,\\heartsuit ,\\clubsuit ,\\spadesuit ,\\Game ,\\flat ,\\natural ,\\sharp}♢,♡,♣,♠,⅁,♭,♮,♯ 未分类 \\diagup \\diagdown \\centerdot \\ltimes \\rtimes \\leftthreetimes \\rightthreetimes ╱,╲,⋅,⋉,⋊,⋋,⋌{\\displaystyle \\diagup ,\\diagdown ,\\centerdot ,\\ltimes ,\\rtimes ,\\leftthreetimes ,\\rightthreetimes}╱,╲,⋅,⋉,⋊,⋋,⋌ \\eqcirc \\circeq \\triangleq \\bumpeq \\Bumpeq \\doteqdot \\risingdotseq \\fallingdotseq ≖,≗,≜,≏,≎,≑,≓,≒{\\displaystyle \\eqcirc ,\\circeq ,\\triangleq ,\\bumpeq ,\\Bumpeq ,\\doteqdot ,\\risingdotseq ,\\fallingdotseq}≖,≗,≜,≏,≎,≑,≓,≒ \\intercal \\barwedge \\veebar \\doublebarwedge \\between \\pitchfork ⊺,⊼,⊻,⩞,≬,⋔{\\displaystyle \\intercal ,\\barwedge ,\\veebar ,\\doublebarwedge ,\\between ,\\pitchfork}⊺,⊼,⊻,⩞,≬,⋔ \\vartriangleleft \\ntriangleleft \\vartriangleright \\ntriangleright ⊲,⋪,⊳,⋫{\\displaystyle \\vartriangleleft ,\\ntriangleleft ,\\vartriangleright ,\\ntriangleright}⊲,⋪,⊳,⋫ \\trianglelefteq \\ntrianglelefteq \\trianglerighteq \\ntrianglerighteq ⊴,⋬,⊵,⋭{\\displaystyle \\trianglelefteq ,\\ntrianglelefteq ,\\trianglerighteq ,\\ntrianglerighteq}⊴,⋬,⊵,⋭ 关于这些符号的更多语义，参阅 TeX Cookbook 的简述。 上标、下标及积分等 功能|语法|效果 ^ 表示上标, _ 表示下标。如果上下标的内容多于一个字符，需要用 {} 将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。 上标 a^2 a2{\\displaystyle a^{2}}a2 下标 a_2 a2{\\displaystyle a_{2}}a2​ 组合 a^{2+2} a2+2{\\displaystyle a^{2+2}}a2+2 a_{i,j} ai,j{\\displaystyle a_{i,j}}ai,j​ 结合上下标 x_2^3 x23{\\displaystyle x_{2}^{3}}x23​ 前置上下标 {}_1^2\\!X_3^4 12 ⁣X34{\\displaystyle {}_{1}^{2}\\!X_{3}^{4}}12​X34​ 导数（HTML） x' x′{\\displaystyle x&#x27;}x′ 导数（PNG） x^\\prime x′{\\displaystyle x^{\\prime}}x′ 导数（错误） x\\prime x′{\\displaystyle x\\prime}x′ 导数点 \\dot{x} x˙{\\displaystyle {\\dot {x}}}x˙ \\ddot{y} y¨{\\displaystyle {\\ddot {y}}}y¨​ 向量 \\vec{c}（只有一个字母） c⃗{\\displaystyle {\\vec {c}}}c \\overleftarrow{a b} ab←{\\displaystyle {\\overleftarrow {ab}}}ab \\overrightarrow{c d} cd→{\\displaystyle {\\overrightarrow {cd}}}cd \\overleftrightarrow{a b} ab↔{\\displaystyle {\\overleftrightarrow {ab}}}ab \\widehat{e f g} efg^{\\displaystyle {\\widehat {efg}}}efg​ 上弧 （注: 正确应该用 \\overarc，但在这里行不通。要用建议的语法作为解决办法。）（使用 \\ overarc 时需要引入 {arcs} 包。） \\overset{\\frown} {AB} AB⌢{\\displaystyle {\\overset {\\frown}{AB}}}AB⌢ 上划线 \\overline{h i j} hij‾{\\displaystyle {\\overline {hij}}}hij​ 下划线 \\underline{k l m} klm‾{\\displaystyle {\\underline {klm}}}klm​ 上括号 \\overbrace{1+2+\\cdots+100} 1+2+⋯+100⏞{\\displaystyle \\overbrace {1+2+\\cdots +100} }1+2+⋯+100​ \\begin{matrix} 5050 \\\\ \\overbrace{ 1+2+\\cdots+100 } \\end{matrix} 50501+2+⋯+100⏞{\\displaystyle {\\begin{matrix}5050\\\\\\overbrace {1+2+\\cdots +100} \\end{matrix}}}50501+2+⋯+100​​ 下括号 \\underbrace{a+b+\\cdots+z} a+b+⋯+z⎵{\\displaystyle \\underbrace {a+b+\\cdots +z} }a+b+⋯+z​ \\begin{matrix} \\underbrace{ a+b+\\cdots+z } \\\\ 26 \\end{matrix} a+b+⋯+z⎵26{\\displaystyle {\\begin{matrix}\\underbrace {a+b+\\cdots +z} \\\\26\\end{matrix}}}a+b+⋯+z​26​ 求和（累加） \\sum_{k=1}^N k^2 ∑k=1Nk2{\\displaystyle \\sum _{k=1}^{N}k^{2}}k=1∑N​k2 \\begin{matrix} \\sum_{k=1}^N k^2 \\end{matrix} ∑k=1Nk2{\\displaystyle {\\begin{matrix}\\sum _{k=1}^{N}k^{2}\\end{matrix}}}∑k=1N​k2​ 求积（累乘） \\prod_{i=1}^N x_i ∏i=1Nxi{\\displaystyle \\prod _{i=1}^{N}x_{i}}i=1∏N​xi​ \\begin{matrix} \\prod_{i=1}^N x_i \\end{matrix} ∏i=1Nxi{\\displaystyle {\\begin{matrix}\\prod _{i=1}^{N}x_{i}\\end{matrix}}}∏i=1N​xi​​ 上积 \\coprod_{i=1}^N x_i ∐i=1Nxi{\\displaystyle \\coprod _{i=1}^{N}x_{i}}i=1∐N​xi​ \\begin{matrix} \\coprod_{i=1}^N x_i \\end{matrix} ∐i=1Nxi{\\displaystyle {\\begin{matrix}\\coprod _{i=1}^{N}x_{i}\\end{matrix}}}∐i=1N​xi​​ 极限 \\lim_{n \\to \\infty}x_n lim⁡n→∞xn{\\displaystyle \\lim _{n\\to \\infty}x_{n}}n→∞lim​xn​ \\begin{matrix} \\lim_{n \\to \\infty}x_n \\end{matrix} lim⁡n→∞xn{\\displaystyle {\\begin{matrix}\\lim _{n\\to \\infty }x_{n}\\end{matrix}}}limn→∞​xn​​ 积分 \\int_{-N}^{N} e^x\\, {\\rm d}x ∫−NNex dx{\\displaystyle \\int _{-N}^{N}e^{x}\\,{\\rm d} x}∫−NN​exdx 本例中 \\, 和 {\\rm d} 部分可省略，但建议加入，能使式子更美观。{\\rm d}可以用\\mathrm{d}等价替换。 \\begin{matrix} \\int_{-N}^{N} e^x\\, \\mathrm{d}x \\end{matrix}（矩阵中积分符号变小） ∫−NNex dx{\\displaystyle {\\begin{matrix}\\int _{-N}^{N}e^{x}\\,\\mathrm {d} x\\end{matrix}}}∫−NN​exdx​ 双重积分 \\iint_{D}^{W} \\, \\mathrm{d}x\\,\\mathrm{d}y ∬DW dx dy{\\displaystyle \\iint _{D}^{W}\\,\\mathrm {d} x\\,\\mathrm {d} y}∬DW​dxdy 三重积分 \\iiint_{E}^{V} \\, \\mathrm{d}x\\,\\mathrm{d}y\\,\\mathrm{d}z ∭EV dx dy dz{\\displaystyle \\iiint _{E}^{V}\\,\\mathrm {d} x\\,\\mathrm {d} y\\,\\mathrm {d} z}∭EV​dxdydz 闭合的曲线、曲面积分 \\oint_{C} x^3\\, \\mathrm{d}x + 4y^2\\, \\mathrm{d}y ∮Cx3 dx+4y2 dy{\\displaystyle \\oint _{C}x^{3}\\,\\mathrm {d} x+4y^{2}\\,\\mathrm {d} y}∮C​x3dx+4y2dy 交集 \\bigcap_1^{n} p ⋂1np{\\displaystyle \\bigcap _{1}^{n}p}1⋂n​p 并集 \\bigcup_1^{k} p ⋃1kp{\\displaystyle \\bigcup _{1}^{k}p}1⋃k​p 分数 通常使用 \\frac {分子} {分母} 命令产生一个分数，分数可嵌套。 便捷情况可直接输入 \\frac ab 来快速生成一个 ab\\frac abba​ 。 如果分式很复杂，亦可使用 分子 \\over 分母 命令，此时分数仅有一层。 功能|语法|效果 分数 \\frac{2}{4}=0.5 24=0.5{\\displaystyle {\\frac {2}{4}}=0.5}42​=0.5 小型分数 \\tfrac{2}{4} = 0.5 24=0.5{\\displaystyle {\\tfrac {2}{4}}=0.5}42​=0.5 连分式（大型嵌套分式） \\cfrac{2}{c + \\cfrac{2}{d + \\cfrac{2}{4}}} = a 2c+2d+24=a{\\displaystyle {\\cfrac {2}{c+{\\cfrac {2}{d+{\\cfrac {2}{4}}}}}}=a}c+d+42​2​2​=a 大型不嵌套分式 \\dfrac{2}{4} = 0.5 \\qquad \\dfrac{2}{c + \\dfrac{2}{d + \\dfrac{2}{4}}} = a 24=0.52c+2d+24=a{\\displaystyle {\\dfrac {2}{4}}=0.5\\qquad {\\dfrac {2}{c+{\\dfrac {2}{d+{\\dfrac {2}{4}}}}}}=a}42​=0.5c+d+42​2​2​=a 二项式系数 \\dbinom{n}{r}=\\binom{n}{n-r}=\\mathrm{C}_n^r=\\mathrm{C}_n^{n-r} (nr)=(nn−r)=Cnr=Cnn−r{\\displaystyle {\\dbinom {n}{r}}={\\binom {n}{n-r}}=\\mathrm {C} _{n}^{r}=\\mathrm {C} _{n}^{n-r}}(rn​)=(n−rn​)=Cnr​=Cnn−r​ 小型二项式系数 \\tbinom{n}{r}=\\tbinom{n}{n-r}=\\mathrm{C}_n^r=\\mathrm{C}_n^{n-r} (nr)=(nn−r)=Cnr=Cnn−r{\\displaystyle {\\tbinom {n}{r}}={\\tbinom {n}{n-r}}=\\mathrm {C} _{n}^{r}=\\mathrm {C} _{n}^{n-r}}(rn​)=(n−rn​)=Cnr​=Cnn−r​ 大型二项式系数 \\binom{n}{r}=\\dbinom{n}{n-r}=\\mathrm{C}_n^r=\\mathrm{C}_n^{n-r} (nr)=(nn−r)=Cnr=Cnn−r{\\displaystyle {\\binom {n}{r}}={\\dbinom {n}{n-r}}=\\mathrm {C} _{n}^{r}=\\mathrm {C} _{n}^{n-r}}(rn​)=(n−rn​)=Cnr​=Cnn−r​ 在以e为底的指数函数、极限和积分中尽量不要使用 \\frac 符号：它会使整段函数看起来很怪，而且可能产生歧义。也正是因此它在专业数学排版中几乎从不出现。 横着写这些分式，中间使用斜线间隔 / （用斜线代替分数线）。 例子： \\begin{array}{cc} \\mathrm{Bad} &amp; \\mathrm{Better} \\\\ \\hline \\\\ e^{i\\frac{\\pi}2} \\quad e^{\\frac{i\\pi}2}&amp; e^{i\\pi/2} \\\\ \\int_{-\\frac\\pi2}^\\frac\\pi2 \\sin x\\,dx &amp; \\int_{-\\pi/2}^{\\pi/2}\\sin x\\,dx \\\\ \\end{array} 显示： BadBettereiπ2eiπ2eiπ/2∫−π2π2sin⁡x dx∫−π/2π/2sin⁡x dx\\begin{array}{cc} \\mathrm{Bad} &amp; \\mathrm{Better} \\\\ \\hline \\\\ e^{i\\frac{\\pi}2} \\quad e^{\\frac{i\\pi}2}&amp; e^{i\\pi/2} \\\\ \\int_{-\\frac\\pi2}^\\frac\\pi2 \\sin x\\,dx &amp; \\int_{-\\pi/2}^{\\pi/2}\\sin x\\,dx \\\\ \\end{array} Badei2π​e2iπ​∫−2π​2π​​sinxdx​Bettereiπ/2∫−π/2π/2​sinxdx​​ 矩阵、条件表达式、方程组 语法： \\begin{类型} 公式内容 \\end{类型} 类型可以是：矩阵 matrix pmatrix bmatrix Bmatrix vmatrix Vmatrix、条件表达式 cases、多行对齐方程式 aligned、数组 array。 在公式内容中：在每一行中插入 &amp; 来指定需要对齐的内容，在每行结尾处使用 \\\\ 换行。 无框矩阵 在开头使用 begin{matrix}，在结尾使用 end{matrix}，在中间插入矩阵元素，每个元素之间插入 &amp; ，并在每行结尾处使用 \\\\ 。 \\begin{matrix} x &amp; y \\\\ z &amp; v \\end{matrix} xyzv{\\displaystyle {\\begin{matrix}x&amp;y\\\\z&amp;v\\end{matrix}}}xz​yv​ 有框矩阵 在开头将 matrix 替换为 pmatrix bmatrix Bmatrix vmatrix Vmatrix 。 \\begin{vmatrix} x &amp; y \\\\ z &amp; v \\end{vmatrix} ∣xyzv∣{\\displaystyle {\\begin{vmatrix}x&amp;y\\\\z&amp;v\\end{vmatrix}}}∣∣∣∣​xz​yv​∣∣∣∣​ \\begin{Vmatrix} x &amp; y \\\\ z &amp; v \\end{Vmatrix} ∥xyzv∥{\\displaystyle {\\begin{Vmatrix}x&amp;y\\\\z&amp;v\\end{Vmatrix}}}∥∥∥∥​xz​yv​∥∥∥∥​ 使用 \\cdots ⋯\\cdots⋯ , \\ddots ⋱\\ddots⋱ , \\vdots ⋮\\vdots⋮ 来输入省略符号。 \\begin{bmatrix} 0 &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; \\cdots &amp; 0 \\end{bmatrix} [0⋯0⋮⋱⋮0⋯0]{\\displaystyle {\\begin{bmatrix}0&amp;\\cdots &amp;0\\\\\\vdots &amp;\\ddots &amp;\\vdots \\\\0&amp;\\cdots &amp;0\\end{bmatrix}}}⎣⎢⎡​0⋮0​⋯⋱⋯​0⋮0​⎦⎥⎤​ \\begin{Bmatrix} x &amp; y \\\\ z &amp; v \\end{Bmatrix} {xyzv}{\\displaystyle {\\begin{Bmatrix}x&amp;y\\\\z&amp;v\\end{Bmatrix}}}{xz​yv​} \\begin{pmatrix} x &amp; y \\\\ z &amp; v \\end{pmatrix} (xyzv){\\displaystyle {\\begin{pmatrix}x&amp;y\\\\z&amp;v\\end{pmatrix}}}(xz​yv​) 条件表达式 f(n) = \\begin{cases} n/2, &amp; \\text{if }n\\text{ is even} \\\\ 3n+1, &amp; \\text{if }n\\text{ is odd} \\end{cases} f(n)={n/2,if n is even3n+1,if n is odd{\\displaystyle f(n)={\\begin{cases}n/2,&amp;{\\text{if }}n{\\text{ is even}}\\\\3n+1,&amp;{\\text{if }}n{\\text{ is odd}}\\end{cases}}}f(n)={n/2,3n+1,​if n is evenif n is odd​ 多行等式、同余式 人们经常想要一列整齐且居中的方程式序列。使用 \\begin{aligned}…\\end{aligned}。 \\begin{aligned} f(x) &amp; = (m+n)^2 \\\\ &amp; = m^2+2mn+n^2 \\\\ \\end{aligned} f(x)=(m+n)2=m2+2mn+n2{\\displaystyle {\\begin{aligned}f(x)&amp;=(m+n)^{2}\\\\&amp;=m^{2}+2mn+n^{2}\\\\\\end{aligned}}}f(x)​=(m+n)2=m2+2mn+n2​ begin{aligned} 3^{6n+3}+4^{6n+3} &amp; \\equiv (3^3)^{2n+1}+(4^3)^{2n+1}\\\\ &amp; \\equiv 27^{2n+1}+64^{2n+1}\\\\ &amp; \\equiv 27^{2n+1}+(-27)^{2n+1}\\\\ &amp; \\equiv 27^{2n+1}-27^{2n+1}\\\\ &amp; \\equiv 0 \\pmod{91}\\\\ \\end{aligned} 36n+3+46n+3≡(33)2n+1+(43)2n+1≡272n+1+642n+1≡272n+1+(−27)2n+1≡272n+1−272n+1≡0(mod91){\\displaystyle {\\begin{aligned}3^{6n+3}+4^{6n+3}&amp;\\equiv (3^{3})^{2n+1}+(4^{3})^{2n+1}\\\\&amp;\\equiv 27^{2n+1}+64^{2n+1}\\\\&amp;\\equiv 27^{2n+1}+(-27)^{2n+1}\\\\&amp;\\equiv 27^{2n+1}-27^{2n+1}\\\\&amp;\\equiv 0{\\pmod {91}}\\\\\\end{aligned}}}36n+3+46n+3​≡(33)2n+1+(43)2n+1≡272n+1+642n+1≡272n+1+(−27)2n+1≡272n+1−272n+1≡0(mod91)​ \\begin{alignedat}{3} f(x) &amp; = (m-n)^2 \\\\ f(x) &amp; = (-m+n)^2 \\\\ &amp; = m^2-2mn+n^2 \\\\ \\end{alignedat} f(x)=(m−n)2f(x)=(−m+n)2=m2−2mn+n2{\\displaystyle {\\begin{alignedat}{3}f(x)&amp;=(m-n)^{2}\\\\f(x)&amp;=(-m+n)^{2}\\\\&amp;=m^{2}-2mn+n^{2}\\\\\\end{alignedat}}}f(x)f(x)​=(m−n)2=(−m+n)2=m2−2mn+n2​ 方程组 \\begin{cases} 3x + 5y + z \\\\ 7x - 2y + 4z \\\\ -6x + 3y + 2z \\end{cases} {3x+5y+z7x−2y+4z−6x+3y+2z{\\displaystyle {\\begin{cases}3x+5y+z\\\\7x-2y+4z\\\\-6x+3y+2z\\end{cases}}} ⎩⎪⎨⎪⎧​3x+5y+z7x−2y+4z−6x+3y+2z​ 或 \\left\\{\\begin{aligned} 3x + 5y + z \\\\ 7x - 2y + 4z \\\\ -6x + 3y + 2z \\end{aligned}\\right. {3x+5y+z7x−2y+4z−6x+3y+2z\\left\\{\\begin{aligned} 3x + 5y + z \\\\ 7x - 2y + 4z \\\\ -6x + 3y + 2z \\end{aligned}\\right. ⎩⎪⎨⎪⎧​3x+5y+z7x−2y+4z−6x+3y+2z​ 数组与表格 通常，一个格式化后的表格比单纯的文字或排版后的文字更具有可读性。数组和表格均以 \\begin{array} 开头，并在其后定义列数及每一列的文本对齐属性，c l r 分别代表居中、左对齐及右对齐。若需要插入垂直分割线，在定义式中插入 | ，若要插入水平分割线，在下一行输入前插入 \\hline 。与矩阵相似，每行元素间均须要插入 &amp; ，每行元素以 \\\\ 结尾，最后以 \\end{array} 结束数组。 例子： \\begin{array}{c|lcr} n &amp; \\text{左对齐} &amp; \\text{居中对齐} &amp; \\text{右对齐} \\\\ \\hline 1 &amp; 0.24 &amp; 1 &amp; 125 \\\\ 2 &amp; -1 &amp; 189 &amp; -8 \\\\ 3 &amp; -20 &amp; 2000 &amp; 1+10i \\end{array} 显示： n左对齐居中对齐右对齐10.2411252−1189−83−2020001+10i\\begin{array}{c|lcr} n &amp; \\text{左对齐} &amp; \\text{居中对齐} &amp; \\text{右对齐} \\\\ \\hline 1 &amp; 0.24 &amp; 1 &amp; 125 \\\\ 2 &amp; -1 &amp; 189 &amp; -8 \\\\ 3 &amp; -20 &amp; 2000 &amp; 1+10i \\end{array} n123​左对齐0.24−1−20​居中对齐11892000​右对齐125−81+10i​​ 例子: \\begin{array}{lcl} z &amp; = &amp; a \\\\ f(x,y,z) &amp; = &amp; x + y + z \\end{array} 显示： z=af(x,y,z)=x+y+z{\\displaystyle {\\begin{array}{lcl}z&amp;=&amp;a\\\\f(x,y,z)&amp;=&amp;x+y+z\\end{array}}}zf(x,y,z)​==​ax+y+z​ 例子: \\begin{array}{lcr} z &amp; = &amp; a \\\\ f(x,y,z) &amp; = &amp; x + y + z \\end{array} 显示: z=af(x,y,z)=x+y+z{\\displaystyle {\\begin{array}{lcr}z&amp;=&amp;a\\\\f(x,y,z)&amp;=&amp;x+y+z\\end{array}}}zf(x,y,z)​==​ax+y+z​ 例子: \\begin{array}{ccc} a &amp; b &amp; S \\\\ \\hline 0&amp;0&amp;1\\\\ 0&amp;1&amp;1\\\\ 1&amp;0&amp;1\\\\ 1&amp;1&amp;0\\\\ \\end{array} 显示: abS001011101110{\\displaystyle {\\begin{array}{ccc}a&amp;b&amp;S\\\\\\hline 0&amp;0&amp;1\\\\0&amp;1&amp;1\\\\1&amp;0&amp;1\\\\1&amp;1&amp;0\\\\\\end{array}}} a0011​b0101​S1110​​ 嵌套数组或表格 多个数组/表格可 互相嵌套 并组成一组数组/一组表格。 使用嵌套前必须声明 $$ 符号。 例子： % outer vertical array of arrays 外层垂直表格 \\begin{array}{c} % inner horizontal array of arrays 内层水平表格 \\begin{array}{cc} % inner array of minimum values 内层&quot;最小值&quot;数组 \\begin{array}{c|cccc} \\text{min} &amp; 0 &amp; 1 &amp; 2 &amp; 3\\\\ \\hline 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 1 &amp; 0 &amp; 1 &amp; 1 &amp; 1\\\\ 2 &amp; 0 &amp; 1 &amp; 2 &amp; 2\\\\ 3 &amp; 0 &amp; 1 &amp; 2 &amp; 3 \\end{array} &amp; % inner array of maximum values 内层&quot;最大值&quot;数组 \\begin{array}{c|cccc} \\text{max}&amp;0&amp;1&amp;2&amp;3\\\\ \\hline 0 &amp; 0 &amp; 1 &amp; 2 &amp; 3\\\\ 1 &amp; 1 &amp; 1 &amp; 2 &amp; 3\\\\ 2 &amp; 2 &amp; 2 &amp; 2 &amp; 3\\\\ 3 &amp; 3 &amp; 3 &amp; 3 &amp; 3 \\end{array} \\end{array} % 内层第一行表格组结束 \\\\ % inner array of delta values 内层第二行Delta值数组 \\begin{array}{c|cccc} \\Delta&amp;0&amp;1&amp;2&amp;3\\\\ \\hline 0 &amp; 0 &amp; 1 &amp; 2 &amp; 3\\\\ 1 &amp; 1 &amp; 0 &amp; 1 &amp; 2\\\\ 2 &amp; 2 &amp; 1 &amp; 0 &amp; 1\\\\ 3 &amp; 3 &amp; 2 &amp; 1 &amp; 0 \\end{array} % 内层第二行表格组结束 \\end{array} 显示： min012300000101112012230123max012300123111232222333333Δ012300123110122210133210% outer vertical array of arrays 外层垂直表格 \\begin{array}{c} % inner horizontal array of arrays 内层水平表格 \\begin{array}{cc} % inner array of minimum values 内层&quot;最小值&quot;数组 \\begin{array}{c|cccc} \\text{min} &amp; 0 &amp; 1 &amp; 2 &amp; 3\\\\ \\hline 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 1 &amp; 0 &amp; 1 &amp; 1 &amp; 1\\\\ 2 &amp; 0 &amp; 1 &amp; 2 &amp; 2\\\\ 3 &amp; 0 &amp; 1 &amp; 2 &amp; 3 \\end{array} &amp; % inner array of maximum values 内层&quot;最大值&quot;数组 \\begin{array}{c|cccc} \\text{max}&amp;0&amp;1&amp;2&amp;3\\\\ \\hline 0 &amp; 0 &amp; 1 &amp; 2 &amp; 3\\\\ 1 &amp; 1 &amp; 1 &amp; 2 &amp; 3\\\\ 2 &amp; 2 &amp; 2 &amp; 2 &amp; 3\\\\ 3 &amp; 3 &amp; 3 &amp; 3 &amp; 3 \\end{array} \\end{array} % 内层第一行表格组结束 \\\\ % inner array of delta values 内层第二行Delta值数组 \\begin{array}{c|cccc} \\Delta&amp;0&amp;1&amp;2&amp;3\\\\ \\hline 0 &amp; 0 &amp; 1 &amp; 2 &amp; 3\\\\ 1 &amp; 1 &amp; 0 &amp; 1 &amp; 2\\\\ 2 &amp; 2 &amp; 1 &amp; 0 &amp; 1\\\\ 3 &amp; 3 &amp; 2 &amp; 1 &amp; 0 \\end{array} % 内层第二行表格组结束 \\end{array} min0123​00000​10111​20122​30123​​​max0123​00123​11123​22223​33333​​​Δ0123​00123​11012​22101​33210​​​ 用数组实现带分割符号的矩阵 例子： $$ \\left[ \\begin{array}{cc|c} 1&amp;2&amp;3\\\\ 4&amp;5&amp;6 \\end{array} \\right] $$ 显示： [123456]\\left[ \\begin{array}{cc|c} 1&amp;2&amp;3\\\\ 4&amp;5&amp;6 \\end{array} \\right] [14​25​36​] 其中 cc|c 代表在一个三列矩阵中的第二和第三列之间插入分割线。 字体 希腊字母 输入 \\小写希腊字母英文全称 和 \\首字母大写希腊字母英文全称 来分别输入小写和大写希腊字母。 \\Alpha \\Beta \\Gamma \\Delta \\Epsilon \\Zeta \\Eta \\Theta ABΓΔEZHΘ{\\displaystyle \\mathrm {A} \\mathrm {B} \\Gamma \\Delta \\mathrm {E} \\mathrm {Z} \\mathrm {H} \\Theta }ABΓΔEZHΘ \\Iota \\Kappa \\Lambda \\Mu \\Nu \\Xi \\Omicron \\Pi IKΛMNOΞΠ{\\displaystyle \\mathrm {I} \\mathrm {K} \\Lambda \\mathrm {M} \\mathrm {N} \\mathrm {O} \\Xi \\Pi }IKΛMNOΞΠ \\Rho \\Sigma \\Tau \\Upsilon \\Phi \\Chi \\Psi \\Omega PΣTΥΦXΨΩ{\\displaystyle \\mathrm {P} \\Sigma \\mathrm {T} \\Upsilon \\Phi \\mathrm {X} \\Psi \\Omega }PΣTΥΦXΨΩ \\alpha \\beta \\gamma \\delta \\epsilon \\zeta \\eta \\theta αβγδϵζηθ{\\displaystyle \\alpha \\beta \\gamma \\delta \\epsilon \\zeta \\eta \\theta}αβγδϵζηθ \\iota \\kappa \\lambda \\mu \\nu \\omicron \\xi \\pi ικλμνoξπ{\\displaystyle \\iota \\kappa \\lambda \\mu \\nu \\mathrm {o} \\xi \\pi }ικλμνoξπ \\rho \\sigma \\tau \\upsilon \\phi \\chi \\psi \\omega ρστυϕχψω{\\displaystyle \\rho \\sigma \\tau \\upsilon \\phi \\chi \\psi \\omega}ρστυϕχψω 部分字母有变量专用形式，以 \\var- 开头。 \\varepsilon \\digamma \\varkappa \\varpi εϝϰϖ{\\displaystyle \\varepsilon \\digamma \\varkappa \\varpi}εϝϰϖ \\varrho \\varsigma \\vartheta \\varphi ϱςϑφ{\\displaystyle \\varrho \\varsigma \\vartheta \\varphi}ϱςϑφ 希伯来符号 \\aleph \\beth \\gimel \\daleth ℵℶℷℸ{\\displaystyle \\aleph \\beth \\gimel \\daleth}ℵℶℷℸ 部分字体的简称 若要对公式的某一部分字符进行字体转换，可以用 {\\字体 {需转换的部分字符}} 命令，其中 \\字体 部分可以参照下表选择合适的字体。一般情况下，公式默认为意大利体 italicitalicitalic 。 输入 说明 显示 输入 说明 显示 \\rm 罗马体 Sample\\rm{Sample}Sample \\cal 花体 \\cal{SAMPLE} \\it 意大利体 Sample\\it{Sample}Sample \\Bbb 黑板粗体 SAMPLE\\Bbb{SAMPLE}SAMPLE \\bf 粗体 Sample\\bf{Sample}Sample \\mit 数学斜体 \\mit{SAMPLE} \\sf 等线体 Sample\\sf{Sample}Sample \\scr 手写体 \\scr{SAMPLE} \\tt 打字机体 Sample\\tt{Sample}Sample \\frak 旧德式字体 Sample\\frak{Sample}Sample 所有字体 黑板报粗体 \\mathbb{ABCDEFGHI} ABCDEFGHI{\\displaystyle \\mathbb {ABCDEFGHI} }ABCDEFGHI \\mathbb{JKLMNOPQR} JKLMNOPQR{\\displaystyle \\mathbb {JKLMNOPQR} }JKLMNOPQR \\mathbb{STUVWXYZ} STUVWXYZ{\\displaystyle \\mathbb {STUVWXYZ} }STUVWXYZ 粗体 \\mathbf{ABCDEFGHI} ABCDEFGHI{\\displaystyle \\mathbf {ABCDEFGHI} }ABCDEFGHI \\mathbf{JKLMNOPQR} JKLMNOPQR{\\displaystyle \\mathbf {JKLMNOPQR} }JKLMNOPQR \\mathbf{STUVWXYZ} STUVWXYZ{\\displaystyle \\mathbf {STUVWXYZ} }STUVWXYZ \\mathbf{abcdefghijklm} abcdefghijklm{\\displaystyle \\mathbf {abcdefghijklm} }abcdefghijklm \\mathbf{nopqrstuvwxyz} nopqrstuvwxyz{\\displaystyle \\mathbf {nopqrstuvwxyz} }nopqrstuvwxyz \\mathbf{0123456789} 0123456789{\\displaystyle \\mathbf {0123456789} }0123456789 粗体希腊字母 \\boldsymbol{\\Alpha\\Beta\\Gamma\\Delta\\Epsilon\\Zeta\\Eta\\Theta} ABΓΔEZHΘ{\\displaystyle {\\boldsymbol {\\mathrm {A} \\mathrm {B} \\Gamma \\Delta \\mathrm {E} \\mathrm {Z} \\mathrm {H} \\Theta }}}ABΓΔEZHΘ \\boldsymbol{\\Iota\\Kappa\\Lambda\\Mu\\Nu\\Xi\\Pi\\Rho} IKΛMNΞΠP{\\displaystyle {\\boldsymbol {\\mathrm {I} \\mathrm {K} \\Lambda \\mathrm {M} \\mathrm {N} \\Xi \\Pi \\mathrm {P} }}}IKΛMNΞΠP \\boldsymbol{\\Sigma\\Tau\\Upsilon\\Phi\\Chi\\Psi\\Omega} ΣTΥΦXΨΩ{\\displaystyle {\\boldsymbol {\\Sigma \\mathrm {T} \\Upsilon \\Phi \\mathrm {X} \\Psi \\Omega }}}ΣTΥΦXΨΩ \\boldsymbol{\\alpha\\beta\\gamma\\delta\\epsilon\\zeta\\eta\\theta} αβγδϵζηθ{\\displaystyle {\\boldsymbol {\\alpha \\beta \\gamma \\delta \\epsilon \\zeta \\eta \\theta}}}αβγδϵζηθ \\boldsymbol{\\iota\\kappa\\lambda\\mu\\nu\\xi\\pi\\rho} ικλμνξπρ{\\displaystyle {\\boldsymbol {\\iota \\kappa \\lambda \\mu \\nu \\xi \\pi \\rho}}}ικλμνξπρ \\boldsymbol{\\sigma\\tau\\upsilon\\phi\\chi\\psi\\omega} στυϕχψω{\\displaystyle {\\boldsymbol {\\sigma \\tau \\upsilon \\phi \\chi \\psi \\omega}}}στυϕχψω \\boldsymbol{\\varepsilon\\digamma\\varkappa\\varpi} εϝϰϖ{\\displaystyle {\\boldsymbol {\\varepsilon \\digamma \\varkappa \\varpi}}}εϝϰϖ \\boldsymbol{\\varrho\\varsigma\\vartheta\\varphi} ϱςϑφ{\\displaystyle {\\boldsymbol {\\varrho \\varsigma \\vartheta \\varphi}}}ϱςϑφ 斜体（拉丁字母默认） \\mathit{0123456789} 0123456789{\\displaystyle {\\mathit {0123456789}}}0123456789 斜体希腊字母（小写字母默认） \\mathit{\\Alpha\\Beta\\Gamma\\Delta\\Epsilon\\Zeta\\Eta\\Theta} ABΓΔEZHΘ{\\displaystyle {\\mathit {\\mathrm {A} \\mathrm {B} \\Gamma \\Delta \\mathrm {E} \\mathrm {Z} \\mathrm {H} \\Theta }}}ABΓΔEZHΘ \\mathit{\\Iota\\Kappa\\Lambda\\Mu\\Nu\\Xi\\Pi\\Rho} IKΛMNΞΠP{\\displaystyle {\\mathit {\\mathrm {I} \\mathrm {K} \\Lambda \\mathrm {M} \\mathrm {N} \\Xi \\Pi \\mathrm {P} }}}IKΛMNΞΠP \\mathit{\\Sigma\\Tau\\Upsilon\\Phi\\Chi\\Psi\\Omega} ΣTΥΦXΨΩ{\\displaystyle {\\mathit {\\Sigma \\mathrm {T} \\Upsilon \\Phi \\mathrm {X} \\Psi \\Omega }}}ΣTΥΦXΨΩ 罗马体 \\mathrm{ABCDEFGHI} ABCDEFGHI{\\displaystyle \\mathrm {ABCDEFGHI} }ABCDEFGHI \\mathrm{JKLMNOPQR} JKLMNOPQR{\\displaystyle \\mathrm {JKLMNOPQR} }JKLMNOPQR \\mathrm{STUVWXYZ} STUVWXYZ{\\displaystyle \\mathrm {STUVWXYZ} }STUVWXYZ \\mathrm{abcdefghijklm} abcdefghijklm{\\displaystyle \\mathrm {abcdefghijklm} }abcdefghijklm \\mathrm{nopqrstuvwxyz} nopqrstuvwxyz{\\displaystyle \\mathrm {nopqrstuvwxyz} }nopqrstuvwxyz \\mathrm{0123456789} 0123456789{\\displaystyle \\mathrm {0123456789} }0123456789 无衬线体 \\mathsf{ABCDEFGHI} ABCDEFGHI{\\displaystyle {\\mathsf {ABCDEFGHI}}}ABCDEFGHI \\mathsf{JKLMNOPQR} JKLMNOPQR{\\displaystyle {\\mathsf {JKLMNOPQR}}}JKLMNOPQR \\mathsf{STUVWXYZ} STUVWXYZ{\\displaystyle {\\mathsf {STUVWXYZ}}}STUVWXYZ \\mathsf{abcdefghijklm} abcdefghijklm{\\displaystyle {\\mathsf {abcdefghijklm}}}abcdefghijklm \\mathsf{nopqrstuvwxyz} nopqrstuvwxyz{\\displaystyle {\\mathsf {nopqrstuvwxyz}}}nopqrstuvwxyz \\mathsf{0123456789} 0123456789{\\displaystyle {\\mathsf {0123456789}}}0123456789 无衬线体希腊字母（仅大写） \\mathsf{\\Alpha \\Beta \\Gamma \\Delta \\Epsilon \\Zeta \\Eta \\Theta} ABΓΔEZHΘ{\\displaystyle {\\mathsf {\\mathrm {A} \\mathrm {B} \\Gamma \\Delta \\mathrm {E} \\mathrm {Z} \\mathrm {H} \\Theta }}}ABΓΔEZHΘ \\mathsf{\\Iota \\Kappa \\Lambda \\Mu \\Nu \\Xi \\Pi \\Rho} IKΛMNΞΠP{\\displaystyle {\\mathsf {\\mathrm {I} \\mathrm {K} \\Lambda \\mathrm {M} \\mathrm {N} \\Xi \\Pi \\mathrm {P} }}}IKΛMNΞΠP \\mathsf{\\Sigma \\Tau \\Upsilon \\Phi \\Chi \\Psi \\Omega} ΣTΥΦXΨΩ{\\displaystyle {\\mathsf {\\Sigma \\mathrm {T} \\Upsilon \\Phi \\mathrm {X} \\Psi \\Omega }}}ΣTΥΦXΨΩ 手写体 / 花体 \\mathcal{ABCDEFGHI} ABCDEFGHI{\\displaystyle {\\mathcal {ABCDEFGHI}}}ABCDEFGHI \\mathcal{JKLMNOPQR} JKLMNOPQR{\\displaystyle {\\mathcal {JKLMNOPQR}}}JKLMNOPQR \\mathcal{STUVWXYZ} STUVWXYZ{\\displaystyle {\\mathcal {STUVWXYZ}}}STUVWXYZ Fraktur 体 \\mathfrak{ABCDEFGHI} ABCDEFGHI{\\displaystyle {\\mathfrak {ABCDEFGHI}}}ABCDEFGHI \\mathfrak{JKLMNOPQR} JKLMNOPQR{\\displaystyle {\\mathfrak {JKLMNOPQR}}}JKLMNOPQR \\mathfrak{STUVWXYZ} STUVWXYZ{\\displaystyle {\\mathfrak {STUVWXYZ}}}STUVWXYZ \\mathfrak{abcdefghijklm} abcdefghijklm{\\displaystyle {\\mathfrak {abcdefghijklm}}}abcdefghijklm \\mathfrak{nopqrstuvwxyz} nopqrstuvwxyz{\\displaystyle {\\mathfrak {nopqrstuvwxyz}}}nopqrstuvwxyz \\mathfrak{0123456789} 0123456789{\\displaystyle {\\mathfrak {0123456789}}}0123456789 小型手写体 {\\scriptstyle\\text{abcdefghijklm}} abcdefghijklm{\\displaystyle {\\scriptstyle {\\text{abcdefghijklm}}}}abcdefghijklm 混合字体 特征|语法|渲染效果 斜体字符（忽略空格） x y z xyz{\\displaystyle xyz}xyz 非斜体字符 \\text{x y z} x y z{\\displaystyle {\\text{x y z}}}x y z 混合斜体（差） \\text{if} n \\text{is even} ifnis even{\\displaystyle {\\text{if}}n{\\text{is even}}}ifnis even 混合斜体（好） \\text{if }n\\text{ is even} if n is even{\\displaystyle {\\text{if }}n{\\text{ is even}}}if n is even 混合斜体（替代品：~ 或者 \\ 强制空格） \\text{if}~n\\ \\text{is even} if n is even{\\displaystyle {\\text{if}}~n\\ {\\text{is even}}}if n is even 注释文本 使用 \\text {文字} 来添加注释文本（注释文本不会被识别为公式，不用斜体显示）。\\text {文字}中仍可以使用 $公式$ 插入其它公式。 例子： f(n)= \\begin{cases} n/2, &amp; \\text {if $n$ is even} \\\\ 3n+1, &amp;\\text{if $n$ is odd} \\end{cases} 显示： f(n)={n/2,if n is even3n+1,if n is oddf(n)= \\begin{cases} n/2, &amp; \\text {if $n$ is even} \\\\ 3n+1, &amp; \\text{if $n$ is odd} \\end{cases} f(n)={n/2,3n+1,​if n is evenif n is odd​ 括号 ()、[] 和 | 表示符号本身，使用 \\{\\} 来表示 {} 。 功能|语法|显示 短括号 \\frac{1}{2} (12){\\displaystyle ({\\frac {1}{2}})}(21​) 长括号 \\left(\\frac{1}{2} \\right (12){\\displaystyle \\left({\\frac {1}{2}}\\right)}(21​) 使用 \\left 和 \\right 来创建自动匹配高度的 (圆括号)，[方括号] 和 {花括号} 。 功能|语法|显示 圆括号，小括号 \\left( \\frac{a}{b} \\right) (ab){\\displaystyle \\left({\\frac {a}{b}}\\right)}(ba​) 方括号，中括号 \\left[ \\frac{a}{b} \\right] [ab]{\\displaystyle \\left[{\\frac {a}{b}}\\right]}[ba​] 花括号，大括号 \\left{ \\frac{a}{b} \\right} {ab}{\\displaystyle \\left\\{{\\frac {a}{b}}\\right\\}}{ba​} 角括号 \\left \\langle \\frac{a}{b} \\right \\rangle ⟨ab⟩{\\displaystyle \\left\\langle {\\frac {a}{b}}\\right\\rangle }⟨ba​⟩ 单竖线，绝对值 \\left| \\frac{a}{b} \\right| ∣ab∣{\\displaystyle \\left| \\frac{a}{b} \\right|}∣∣∣​ba​∣∣∣​ 双竖线，范 \\left \\| \\frac{a}{b} \\right \\| ∥ab∥{\\displaystyle \\left\\|{\\frac {a}{b}}\\right\\|}∥∥∥​ba​∥∥∥​ 取整函数 \\left \\lfloor \\frac{a}{b} \\right \\rfloor ⌊ab⌋{\\displaystyle \\left\\lfloor {\\frac {a}{b}}\\right\\rfloor }⌊ba​⌋ 取顶函数 \\left \\lceil \\frac{c}{d} \\right \\rceil ⌈cd⌉{\\displaystyle \\left\\lceil {\\frac {c}{d}}\\right\\rceil }⌈dc​⌉ 斜线与反斜线 \\left / \\frac{a}{b} \\right \\backslash /ab\\{\\displaystyle \\left/{\\frac {a}{b}}\\right\\backslash }/ba​\\ 上下箭头 \\left \\uparrow \\frac{a}{b} \\right \\downarrow ↑ab↓{\\displaystyle \\left\\uparrow {\\frac {a}{b}}\\right\\downarrow }⏐⏐↑​ba​↓⏐⏐​ \\left \\Uparrow \\frac{a}{b} \\right \\Downarrow ⇑ab⇓{\\displaystyle \\left\\Uparrow {\\frac {a}{b}}\\right\\Downarrow }‖‖⇑​ba​⇓‖‖​ \\left \\updownarrow \\frac{a}{b} \\right \\Updownarrow ↕ab⇕{\\displaystyle \\left\\updownarrow {\\frac {a}{b}}\\right\\Updownarrow }↓⏐↑​ba​⇓‖⇑​ 混合括号 \\left[ 0,1 \\right) [0,1){\\displaystyle \\left[0,1\\right)}[0,1) \\left \\langle \\psi \\right | ⟨ψ∣\\left \\langle \\psi \\right |⟨ψ∣ 如果括号只有一边，要用 \\left. 或 \\right. 匹配另一边。 单左括号 \\left \\{\\frac{a}{b} \\right. {ab{\\displaystyle \\left\\{{\\frac {a}{b}}\\right.}{ba​ 单右括号 \\left. \\frac{a}{b} \\right \\} ab}{\\displaystyle \\left.{\\frac {a}{b}}\\right\\}}ba​} 备注： 可以使用 \\big, \\Big, \\bigg, \\Bigg 控制括号的大小，比如代码 \\Bigg ( \\bigg [ \\Big \\{ \\big \\langle \\left | \\| \\frac{a}{b} \\| \\right | \\big \\rangle \\Big \\} \\bigg ] \\Bigg ) 显示︰ ([{⟨∣∥ab∥∣⟩}])\\Bigg ( \\bigg [ \\Big \\{ \\big \\langle \\left | \\| \\frac{a}{b} \\| \\right | \\big \\rangle \\Big \\} \\bigg ] \\Bigg ) ([{⟨∣∣∣​∥ba​∥∣∣∣​⟩}]) 空格 注意 TeX 能够自动处理大多数的空格，但是您有时候需要自己来控制。 功能|语法|显示|宽度 2 个 quad 空格 \\alpha\\qquad\\beta αβ{\\displaystyle \\alpha \\qquad \\beta}αβ mm{\\displaystyle mm}mm quad 空格 \\alpha\\quad\\beta αβ{\\displaystyle \\alpha \\quad \\beta}αβ m{\\displaystyle m}m 大空格 \\alpha\\ \\beta α β{\\displaystyle \\alpha \\ \\beta}α β m3{\\displaystyle {\\frac{m}{3}}}3m​ 中等空格 \\alpha\\;\\beta α β{\\displaystyle \\alpha \\;\\beta}αβ 2m7{\\displaystyle {\\frac {2m}{7}}}72m​ 小空格 \\alpha\\,\\beta α β{\\displaystyle \\alpha \\,\\beta}αβ m6{\\displaystyle {\\frac {m}{6}}}6m​ 没有空格 \\alpha\\beta αβ{\\displaystyle \\alpha \\beta }αβ 0{\\displaystyle 0}0 紧贴 \\alpha\\!\\beta α ⁣β{\\displaystyle \\alpha \\!\\beta}αβ −m6{\\displaystyle -{\\frac {m}{6}}}−6m​ 颜色 Cmd Markdown 公式指导手册里是这样写的： 使用 \\color{颜色}{文字} 来更改特定的文字颜色。 更改文字颜色 需要浏览器支持 ，如果浏览器不知道你所需的颜色，那么文字将被渲染为黑色。 对于较旧的浏览器（HTML4与CSS2），以下颜色是被支持的： 输入 显示 输入 显示 black text\\color{black}{text}text grey text\\color{grey}{text}text silver text\\color{silver}{text}text white text\\color{white}{text}text maroon text\\color{maroon}{text}text red text\\color{red}{text}text yellow text\\color{yellow}{text}text lime text\\color{lime}{text}text olive text\\color{olive}{text}text green text\\color{green}{text}text teal text\\color{teal}{text}text auqa text\\color{auqa}{text}text blue text\\color{blue}{text}text navy text\\color{navy}{text}text purple text\\color{purple}{text}text fuchsia text\\color{fuchsia}{text}text 对于较新的浏览器（HTML5与CSS3），额外的124种颜色将被支持： 输入 \\color {#rgb} {text} 来自定义更多的颜色，其中 #rgb 的 r g b 可输入 0-9 和 a-f 来表示红色、绿色和蓝色的纯度（饱和度）。 例子： \\begin{array}{|rrrrrrrr|}\\hline \\verb+#000+ &amp; \\color{#000}{text} &amp; &amp; &amp; \\verb+#00F+ &amp; \\color{#00F}{text} &amp; &amp; \\\\ &amp; &amp; \\verb+#0F0+ &amp; \\color{#0F0}{text} &amp; &amp; &amp; \\verb+#0FF+ &amp; \\color{#0FF}{text}\\\\ \\verb+#F00+ &amp; \\color{#F00}{text} &amp; &amp; &amp; \\verb+#F0F+ &amp; \\color{#F0F}{text} &amp; &amp; \\\\ &amp; &amp; \\verb+#FF0+ &amp; \\color{#FF0}{text} &amp; &amp; &amp; \\verb+#FFF+ &amp; \\color{#FFF}{text}\\\\ \\hline \\end{array} 显示： #000text#00Ftext#0F0text#0FFtext#F00text#F0Ftext#FF0text#FFFtext\\begin{array}{|rrrrrrrr|}\\hline \\verb+#000+ &amp; \\color{#000}{text} &amp; &amp; &amp; \\verb+#00F+ &amp; \\color{#00F}{text} &amp; &amp; \\\\ &amp; &amp; \\verb+#0F0+ &amp; \\color{#0F0}{text} &amp; &amp; &amp; \\verb+#0FF+ &amp; \\color{#0FF}{text}\\\\ \\verb+#F00+ &amp; \\color{#F00}{text} &amp; &amp; &amp; \\verb+#F0F+ &amp; \\color{#F0F}{text} &amp; &amp; \\\\ &amp; &amp; \\verb+#FF0+ &amp; \\color{#FF0}{text} &amp; &amp; &amp; \\verb+#FFF+ &amp; \\color{#FFF}{text}\\\\ \\hline \\end{array} #000#F00​texttext​#0F0#FF0​texttext​#00F#F0F​texttext​#0FF#FFF​texttext​​ 例子： \\begin{array}{|rrrrrrrr|} \\hline \\verb+#000+ &amp; \\color{#000}{text} &amp; \\verb+#005+ &amp; \\color{#005}{text} &amp; \\verb+#00A+ &amp; \\color{#00A}{text} &amp; \\verb+#00F+ &amp; \\color{#00F}{text} \\\\ \\verb+#500+ &amp; \\color{#500}{text} &amp; \\verb+#505+ &amp; \\color{#505}{text} &amp; \\verb+#50A+ &amp; \\color{#50A}{text} &amp; \\verb+#50F+ &amp; \\color{#50F}{text} \\\\ \\verb+#A00+ &amp; \\color{#A00}{text} &amp; \\verb+#A05+ &amp; \\color{#A05}{text} &amp; \\verb+#A0A+ &amp; \\color{#A0A}{text} &amp; \\verb+#A0F+ &amp; \\color{#A0F}{text} \\\\ \\verb+#F00+ &amp; \\color{#F00}{text} &amp; \\verb+#F05+ &amp; \\color{#F05}{text} &amp; \\verb+#F0A+ &amp; \\color{#F0A}{text} &amp; \\verb+#F0F+ &amp; \\color{#F0F}{text} \\\\ \\hline \\verb+#080+ &amp; \\color{#080}{text} &amp; \\verb+#085+ &amp; \\color{#085}{text} &amp; \\verb+#08A+ &amp; \\color{#08A}{text} &amp; \\verb+#08F+ &amp; \\color{#08F}{text} \\\\ \\verb+#580+ &amp; \\color{#580}{text} &amp; \\verb+#585+ &amp; \\color{#585}{text} &amp; \\verb+#58A+ &amp; \\color{#58A}{text} &amp; \\verb+#58F+ &amp; \\color{#58F}{text} \\\\ \\verb+#A80+ &amp; \\color{#A80}{text} &amp; \\verb+#A85+ &amp; \\color{#A85}{text} &amp; \\verb+#A8A+ &amp; \\color{#A8A}{text} &amp; \\verb+#A8F+ &amp; \\color{#A8F}{text} \\\\ \\verb+#F80+ &amp; \\color{#F80}{text} &amp; \\verb+#F85+ &amp; \\color{#F85}{text} &amp; \\verb+#F8A+ &amp; \\color{#F8A}{text} &amp; \\verb+#F8F+ &amp; \\color{#F8F}{text} \\\\ \\hline \\verb+#0F0+ &amp; \\color{#0F0}{text} &amp; \\verb+#0F5+ &amp; \\color{#0F5}{text} &amp; \\verb+#0FA+ &amp; \\color{#0FA}{text} &amp; \\verb+#0FF+ &amp; \\color{#0FF}{text} \\\\ \\verb+#5F0+ &amp; \\color{#5F0}{text} &amp; \\verb+#5F5+ &amp; \\color{#5F5}{text} &amp; \\verb+#5FA+ &amp; \\color{#5FA}{text} &amp; \\verb+#5FF+ &amp; \\color{#5FF}{text} \\\\ \\verb+#AF0+ &amp; \\color{#AF0}{text} &amp; \\verb+#AF5+ &amp; \\color{#AF5}{text} &amp; \\verb+#AFA+ &amp; \\color{#AFA}{text} &amp; \\verb+#AFF+ &amp; \\color{#AFF}{text} \\\\ \\verb+#FF0+ &amp; \\color{#FF0}{text} &amp; \\verb+#FF5+ &amp; \\color{#FF5}{text} &amp; \\verb+#FFA+ &amp; \\color{#FFA}{text} &amp; \\verb+#FFF+ &amp; \\color{#FFF}{text} \\\\ \\hline \\end{array} 显示： #000text#005text#00Atext#00Ftext#500text#505text#50Atext#50Ftext#A00text#A05text#A0Atext#A0Ftext#F00text#F05text#F0Atext#F0Ftext#080text#085text#08Atext#08Ftext#580text#585text#58Atext#58Ftext#A80text#A85text#A8Atext#A8Ftext#F80text#F85text#F8Atext#F8Ftext#0F0text#0F5text#0FAtext#0FFtext#5F0text#5F5text#5FAtext#5FFtext#AF0text#AF5text#AFAtext#AFFtext#FF0text#FF5text#FFAtext#FFFtext\\begin{array}{|rrrrrrrr|} \\hline \\verb+#000+ &amp; \\color{#000}{text} &amp; \\verb+#005+ &amp; \\color{#005}{text} &amp; \\verb+#00A+ &amp; \\color{#00A}{text} &amp; \\verb+#00F+ &amp; \\color{#00F}{text} \\\\ \\verb+#500+ &amp; \\color{#500}{text} &amp; \\verb+#505+ &amp; \\color{#505}{text} &amp; \\verb+#50A+ &amp; \\color{#50A}{text} &amp; \\verb+#50F+ &amp; \\color{#50F}{text} \\\\ \\verb+#A00+ &amp; \\color{#A00}{text} &amp; \\verb+#A05+ &amp; \\color{#A05}{text} &amp; \\verb+#A0A+ &amp; \\color{#A0A}{text} &amp; \\verb+#A0F+ &amp; \\color{#A0F}{text} \\\\ \\verb+#F00+ &amp; \\color{#F00}{text} &amp; \\verb+#F05+ &amp; \\color{#F05}{text} &amp; \\verb+#F0A+ &amp; \\color{#F0A}{text} &amp; \\verb+#F0F+ &amp; \\color{#F0F}{text} \\\\ \\hline \\verb+#080+ &amp; \\color{#080}{text} &amp; \\verb+#085+ &amp; \\color{#085}{text} &amp; \\verb+#08A+ &amp; \\color{#08A}{text} &amp; \\verb+#08F+ &amp; \\color{#08F}{text} \\\\ \\verb+#580+ &amp; \\color{#580}{text} &amp; \\verb+#585+ &amp; \\color{#585}{text} &amp; \\verb+#58A+ &amp; \\color{#58A}{text} &amp; \\verb+#58F+ &amp; \\color{#58F}{text} \\\\ \\verb+#A80+ &amp; \\color{#A80}{text} &amp; \\verb+#A85+ &amp; \\color{#A85}{text} &amp; \\verb+#A8A+ &amp; \\color{#A8A}{text} &amp; \\verb+#A8F+ &amp; \\color{#A8F}{text} \\\\ \\verb+#F80+ &amp; \\color{#F80}{text} &amp; \\verb+#F85+ &amp; \\color{#F85}{text} &amp; \\verb+#F8A+ &amp; \\color{#F8A}{text} &amp; \\verb+#F8F+ &amp; \\color{#F8F}{text} \\\\ \\hline \\verb+#0F0+ &amp; \\color{#0F0}{text} &amp; \\verb+#0F5+ &amp; \\color{#0F5}{text} &amp; \\verb+#0FA+ &amp; \\color{#0FA}{text} &amp; \\verb+#0FF+ &amp; \\color{#0FF}{text} \\\\ \\verb+#5F0+ &amp; \\color{#5F0}{text} &amp; \\verb+#5F5+ &amp; \\color{#5F5}{text} &amp; \\verb+#5FA+ &amp; \\color{#5FA}{text} &amp; \\verb+#5FF+ &amp; \\color{#5FF}{text} \\\\ \\verb+#AF0+ &amp; \\color{#AF0}{text} &amp; \\verb+#AF5+ &amp; \\color{#AF5}{text} &amp; \\verb+#AFA+ &amp; \\color{#AFA}{text} &amp; \\verb+#AFF+ &amp; \\color{#AFF}{text} \\\\ \\verb+#FF0+ &amp; \\color{#FF0}{text} &amp; \\verb+#FF5+ &amp; \\color{#FF5}{text} &amp; \\verb+#FFA+ &amp; \\color{#FFA}{text} &amp; \\verb+#FFF+ &amp; \\color{#FFF}{text} \\\\ \\hline \\end{array} #000#500#A00#F00#080#580#A80#F80#0F0#5F0#AF0#FF0​texttexttexttexttexttexttexttexttexttexttexttext​#005#505#A05#F05#085#585#A85#F85#0F5#5F5#AF5#FF5​texttexttexttexttexttexttexttexttexttexttexttext​#00A#50A#A0A#F0A#08A#58A#A8A#F8A#0FA#5FA#AFA#FFA​texttexttexttexttexttexttexttexttexttexttexttext​#00F#50F#A0F#F0F#08F#58F#A8F#F8F#0FF#5FF#AFF#FFF​texttexttexttexttexttexttexttexttexttexttexttext​​ 维基百科的数学公式教程里是这样写的： 语法：{\\color{颜色}表达式} 作者实测：在部分浏览器中，上面的语法可能是错误的（只将表达式的第一个字符着色），\\color{颜色}{文字}的语法才是正确的。例如： {\\color{Red}abc}显示abc{\\color{Red}abc}abc \\color{Red}{abc}显示abc\\color{Red}{abc}abc 支持色调表： Apricot{\\displaystyle \\color {Apricot}{\\text{Apricot}}}Apricot Aquamarine{\\displaystyle \\color {Aquamarine}{\\text{Aquamarine}}}Aquamarine Bittersweet{\\displaystyle \\color {Bittersweet}{\\text{Bittersweet}}}Bittersweet Black{\\displaystyle \\color {Black}{\\text{Black}}}Black Blue{\\displaystyle \\color {Blue}{\\text{Blue}}}Blue BlueGreen{\\displaystyle \\color {BlueGreen}{\\text{BlueGreen}}}BlueGreen BlueViolet{\\displaystyle \\color {BlueViolet}{\\text{BlueViolet}}}BlueViolet BrickRed{\\displaystyle \\color {BrickRed}{\\text{BrickRed}}}BrickRed Brown{\\displaystyle \\color {Brown}{\\text{Brown}}}Brown BurntOrange{\\displaystyle \\color {BurntOrange}{\\text{BurntOrange}}}BurntOrange CadetBlue{\\displaystyle \\color {CadetBlue}{\\text{CadetBlue}}}CadetBlue CarnationPink{\\displaystyle \\color {CarnationPink}{\\text{CarnationPink}}}CarnationPink Cerulean{\\displaystyle \\color {Cerulean}{\\text{Cerulean}}}Cerulean CornflowerBlue{\\displaystyle \\color {CornflowerBlue}{\\text{CornflowerBlue}}}CornflowerBlue Cyan{\\displaystyle \\color {Cyan}{\\text{Cyan}}}Cyan Dandelion{\\displaystyle \\color {Dandelion}{\\text{Dandelion}}}Dandelion DarkOrchid{\\displaystyle \\color {DarkOrchid}{\\text{DarkOrchid}}}DarkOrchid Emerald{\\displaystyle \\color {Emerald}{\\text{Emerald}}}Emerald ForestGreen{\\displaystyle \\color {ForestGreen}{\\text{ForestGreen}}}ForestGreen Fuchsia{\\displaystyle \\color {Fuchsia}{\\text{Fuchsia}}}Fuchsia Goldenrod{\\displaystyle \\color {Goldenrod}{\\text{Goldenrod}}}Goldenrod Gray{\\displaystyle \\color {Gray}{\\text{Gray}}}Gray Green{\\displaystyle \\color {Green}{\\text{Green}}}Green GreenYellow{\\displaystyle \\color {GreenYellow}{\\text{GreenYellow}}}GreenYellow JungleGreen{\\displaystyle \\color {JungleGreen}{\\text{JungleGreen}}}JungleGreen Lavender{\\displaystyle \\color {Lavender}{\\text{Lavender}}}Lavender LimeGreen{\\displaystyle \\color {LimeGreen}{\\text{LimeGreen}}}LimeGreen Magenta{\\displaystyle \\color {Magenta}{\\text{Magenta}}}Magenta Mahogany{\\displaystyle \\color {Mahogany}{\\text{Mahogany}}}Mahogany Maroon{\\displaystyle \\color {Maroon}{\\text{Maroon}}}Maroon Melon{\\displaystyle \\color {Melon}{\\text{Melon}}}Melon MidnightBlue{\\displaystyle \\color {MidnightBlue}{\\text{MidnightBlue}}}MidnightBlue Mulberry{\\displaystyle \\color {Mulberry}{\\text{Mulberry}}}Mulberry NavyBlue{\\displaystyle \\color {NavyBlue}{\\text{NavyBlue}}}NavyBlue OliveGreen{\\displaystyle \\color {OliveGreen}{\\text{OliveGreen}}}OliveGreen Orange{\\displaystyle \\color {Orange}{\\text{Orange}}}Orange OrangeRed{\\displaystyle \\color {OrangeRed}{\\text{OrangeRed}}}OrangeRed Orchid{\\displaystyle \\color {Orchid}{\\text{Orchid}}}Orchid Peach{\\displaystyle \\color {Peach}{\\text{Peach}}}Peach Periwinkle{\\displaystyle \\color {Periwinkle}{\\text{Periwinkle}}}Periwinkle PineGreen{\\displaystyle \\color {PineGreen}{\\text{PineGreen}}}PineGreen Plum{\\displaystyle \\color {Plum}{\\text{Plum}}}Plum ProcessBlue{\\displaystyle \\color {ProcessBlue}{\\text{ProcessBlue}}}ProcessBlue Purple{\\displaystyle \\color {Purple}{\\text{Purple}}}Purple RawSienna{\\displaystyle \\color {RawSienna}{\\text{RawSienna}}}RawSienna Red{\\displaystyle \\color {Red}{\\text{Red}}}Red RedOrange{\\displaystyle \\color {RedOrange}{\\text{RedOrange}}}RedOrange RedViolet{\\displaystyle \\color {RedViolet}{\\text{RedViolet}}}RedViolet Rhodamine{\\displaystyle \\color {Rhodamine}{\\text{Rhodamine}}}Rhodamine RoyalBlue{\\displaystyle \\color {RoyalBlue}{\\text{RoyalBlue}}}RoyalBlue RoyalPurple{\\displaystyle \\color {RoyalPurple}{\\text{RoyalPurple}}}RoyalPurple RubineRed{\\displaystyle \\color {RubineRed}{\\text{RubineRed}}}RubineRed Salmon{\\displaystyle \\color {Salmon}{\\text{Salmon}}}Salmon SeaGreen{\\displaystyle \\color {SeaGreen}{\\text{SeaGreen}}}SeaGreen Sepia{\\displaystyle \\color {Sepia}{\\text{Sepia}}}Sepia SkyBlue{\\displaystyle \\color {SkyBlue}{\\text{SkyBlue}}}SkyBlue SpringGreen{\\displaystyle \\color {SpringGreen}{\\text{SpringGreen}}}SpringGreen Tan{\\displaystyle \\color {Tan}{\\text{Tan}}}Tan TealBlue{\\displaystyle \\color {TealBlue}{\\text{TealBlue}}}TealBlue Thistle{\\displaystyle \\color {Thistle}{\\text{Thistle}}}Thistle Turquoise{\\displaystyle \\color {Turquoise}{\\text{Turquoise}}}Turquoise Violet{\\displaystyle \\color {Violet}{\\text{Violet}}}Violet VioletRed{\\displaystyle \\color {VioletRed}{\\text{VioletRed}}}VioletRed White{\\displaystyle \\color {White}{\\text{White}}}White WildStrawberry{\\displaystyle \\color {WildStrawberry}{\\text{WildStrawberry}}}WildStrawberry Yellow{\\displaystyle \\color {Yellow}{\\text{Yellow}}}Yellow YellowGreen{\\displaystyle \\color {YellowGreen}{\\text{YellowGreen}}}YellowGreen YellowOrange{\\displaystyle \\color {YellowOrange}{\\text{YellowOrange}}}YellowOrange ＊注︰输入时第一个字母必需以大写输入，如\\color{OliveGreen}。 例子 {\\color{Blue}x^2}+{\\color{Brown}2x} - {\\color{OliveGreen}1} x2+2x−1{\\displaystyle {\\color {Blue}x^{2}}+{\\color {Brown}2x}-{\\color {OliveGreen}1}}x2+2x−1 x_{\\color{Maroon}1,2}=\\frac{-b\\pm\\sqrt{{\\color{Maroon}b^2-4ac}}}{2a} x1,2=−b±b2−4ac2a{\\displaystyle x_{\\color {Maroon}1,2}={\\frac {-b\\pm {\\sqrt {\\color {Maroon}b^{2}-4ac}}}{2a}}}x1,2​=2a−b±b2−4ac​​ 外部链接 一个介绍 TeX\\TeXTE​X 的 PDF 文档（英文）： http://www.ctan.org/tex-archive/info/gentle/gentle.pdf 手画符号搜索 LaTeX\\LaTeXLATE​X 代码: http://detexify.kirelabs.org/classify.html LaTeX 在线编辑器 AMS-LaTeX 指南 参考 参考维基百科的数学公式教程 参考Cmd Markdown 公式指导手册 本文为 MathJax 在 Markdown 环境下的语法指引。 ","link":"https://Wangrongsheng.github.io/post/51zpJSdcl/"},{"title":"Markdown基础语法","content":" Markdown简介 Markdown是一种轻量级的标记语言，它允许人们通过简单的纯文本来编写文档，并且转换为HTML、Word、PDF等多种格式。 由于其易读易写的特性，许多网站都用其来编写文档或博客，如Github、CSDN等，很多静态博客生成器，如Hexo、Jekyll也是用其来作为博客的格式。 Markdown文件实际上是一个纯文本文件，一般以.md或者.markdown为后缀名。 Markdown基础语法 作为一个轻量级的标记语言，Markdown最大的特点就是简单易用，其语法并不是很复杂，但可以满足日常非专业性的排版需求。 标题 使用#，表示1-6级标题。 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 引用 普通引用 &gt; 引用文本! 效果： 引用文本！ 嵌套引用 &gt; 第一层 &gt;&gt; 第二层 效果： 第一层 第二层 表格 | 字段1 | 字段2 | 字段3 | | :-- | :--: | --: | | A1 | B1 | C1 | | A2 | B2 | C2 | 效果： 字段1 字段2 字段3 A1 B1 C1 A2 B2 C2 代码 行内 AAA`BBB`CCC 效果： AAABBBCCC 区块 4个空格 在每行前面加上4个空格 text = &quot;Hello, world!&quot; print(text) 效果： text = &quot;Hello, world!&quot; print(text) 3个 ` ```text text = &quot;Hello, world!&quot; print(text) \\``` 上述中的“\\”是转义使用的！ 效果： text = &quot;Hello, world!&quot; print(text) 字体样式 斜体,粗体,粗斜体 *text* 或 _text_ 斜体 **text** 或 __text__ 粗体 ***text*** 或 ___text___ 粗斜体 效果 text 斜体 text 粗体 text 粗斜体 上标,下标 上标 益达&lt;sup&gt;TM&lt;/sup&gt; 效果： 益达TM 下标 X&lt;sub&gt;i&lt;/sub&gt; H&lt;sub&gt;2&lt;/sub&gt;O CO&lt;sub&gt;2&lt;/sub&gt; 效果: Xi H2O CO2 下划线 &lt;u&gt;下划线&lt;/u&gt; 效果： 下划线 删除线 ~~删除线~~ 效果： 删除线 列表 无序列表 使用*、+、或-标记无序列表，下面仅以-作为示例， - 第一项 - 第二项 - 第三项 注: 标记后面最少有一个 空格 或 制表符。 效果： 第一项 第二项 第三项 有序列表 有序列表的标记方式是将上述的符号换成数字,并辅以. 1. 第一项 2. 第二项 3. 第三项 效果： 第一项 第二项 第三项 任务列表 用法: - [ ] 或 - [x]，其中[ ]表示不打勾，[x]表示打勾，-可以用+或*替代 - [x] Lorem ipsum dolor sit amet, consectetur adipiscing elit - [x] Nulla lobortis egestas semper - [x] Curabitur elit nibh, euismod et ullamcorper at, iaculis feugiat est - [ ] Vestibulum convallis sit amet nisi a tincidunt - [x] In hac habitasse platea dictumst - [x] In scelerisque nibh non dolor mollis congue sed et metus - [x] Sed egestas felis quis elit dapibus, ac aliquet turpis mattis - [ ] Praesent sed risus massa - [x] Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque - [ ] Nulla vel eros venenatis, imperdiet enim id, faucibus nisi 效果： Lorem ipsum dolor sit amet, consectetur adipiscing elit Nulla lobortis egestas semper Curabitur elit nibh, euismod et ullamcorper at, iaculis feugiat est Vestibulum convallis sit amet nisi a tincidunt In hac habitasse platea dictumst In scelerisque nibh non dolor mollis congue sed et metus Sed egestas felis quis elit dapibus, ac aliquet turpis mattis Praesent sed risus massa Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque Nulla vel eros venenatis, imperdiet enim id, faucibus nisi 嵌套列表 - aaa - bbb 效果： aaa bbb 分割线 分割线使用三个或以上*，也可以使用-和_，下面仅以-作为示例 --- 效果： 链接 普通链接 行内式 [example](http://www.example.com/ &quot;title&quot;) 效果： example 鼠标悬停在链接上可以看到&quot;title&quot;字样 参考式 当一个页面里多次调用相同链接时，这种方法更适用: [example][索引] [索引]: http://www.example.com/ &quot;title&quot; 注意: [索引]: http://www.example.com/ &quot;title&quot;可以写在任意地方，通常习惯于放在markdown本页文档最下方 效果： example 鼠标悬停在链接上可以看到&quot;title&quot;字样 自动链接 当识别到HTML、FTP、Email地址时候会自动转为超链接 图片 行内式 添加图片的形式和链接相似，只需在链接的基础上前方加一个! ![alt](图片地址 &quot;title&quot;) 效果： 鼠标悬停在图标上可以看到&quot;我的博客头像&quot;字样 参考式 当一个页面里多次调用相同图片时，这种方法更适用: ![alt][索引] [索引]: 图片地址 &quot;title&quot; 注意: [索引]: 图片地址 &quot;title&quot;可以写在任意地方，通常习惯于放在markdown本页文档最下方 效果： 鼠标悬停在图标上可以看到&quot;我的博客头像&quot;字样 转义 \\转义的内容 ","link":"https://Wangrongsheng.github.io/post/UWPsajVaD/"},{"title":"基于Gridea+Github建立自己的博客","content":" 前言 我首先给出所有的用到的链接： Gridea官网 Gridea下载 Github Gridea常见问题解决 安装 安装博客 安装指导文档 部署指导文档 安装指导视频 安装评论插件 出于新手安装评论功能，我给出一个特别好的安装Gittalk文章：一款超好用的第三方评论插件-Gittalk 之后将在Github申请到的内容都按照对应位置填写到上述Gridea客户端的Gittalk评论配置中。 自定义域名 除了官方的默认username.github.io域名，我们也可以自己建立自己的域名，这里是一篇配置文章：为你的hexo博客配置个性域名，这里有些不同的是前期的准备域名、域名解析都是一样的，后面我们只需要把我们的域名写在Gridea客户端的文件里面就可以了。 特别要注意：填写好之后要去Github博客仓库把域名写好！ ","link":"https://Wangrongsheng.github.io/post/vo2GSBChP/"},{"title":"基于百度EasyDL平台的数字识别分类","content":" 一、引言 我目前是大二年级上学期，临近期末居然开了一门人工智能导论，最后要求使用百度EasyDL进行图像的分类识别，至于分类的内容嘛，哈哈哈，自己选择，课上脑子里各种分类的想法，最后由于懒惰，还是选择进行数字0-9的识别分类，当然还有更懒惰的，用python生成数据集和测试集，下面来看看流程吧~ 二、生成数据 今天借鉴了一个大佬写的一个生成手写体图片的 Python 程序，可以批量生成手写体数字数据集，在此分享下大佬的生成 30*30像素 的手写体数字 1-9 图片 的实现方法： 大概流程：新建空白图像 &gt;&gt;&gt; 生成随机数 1-9 &gt;&gt;&gt; 将数字写到空白图像上 &gt;&gt;&gt; 旋转、扭曲 处理 &gt;&gt;&gt; 得到 “手写体数字” 具体的实现流程不再赘述，可直接看程序： # Created on: 2019-12-31 # Author: 王荣胜 # Blog: https://sqdxwz.com # Github: https://github.com/WangRongsheng # 生成手写体数字 import random import os from PIL import Image, ImageDraw, ImageFont random.seed(3) path_img = &quot;data_pngs/&quot; # 在目录下生成用来存放数字 1-9 的 9个文件夹，分别用 1-9 命名 def mkdir_for_imgs(): for i in range(49, 58): if os.path.isdir(path_img + &quot;Num_&quot; + chr(i)): pass else: print(path_img + &quot;Num_&quot; + chr(i)) os.makedirs(path_img + &quot;Num_&quot; + chr(i)) # generate folders # mkdir_for_imgs() # 删除路径下的图片 def del_imgs(): for i in range(1, 10): dir_nums = os.listdir(path_img+ &quot;Num_&quot; + str(i)) for tmp_img in dir_nums: if tmp_img in dir_nums: # print(&quot;delete: &quot;, tmp_img) os.remove(path_img + &quot;Num_&quot; + str(i) + &quot;/&quot; + tmp_img) print(&quot;Delete finish&quot;, &quot;\\n&quot;) # del_imgs() # 生成单张扭曲的数字图像 def generate_single(): # 先绘制一个50*50的空图像 im_50_blank = Image.new('RGB', (50, 50), (255, 255, 255)) # 创建画笔 draw = ImageDraw.Draw(im_50_blank) # 生成随机数1-9 num = str(random.randint(1, 9)) # 设置字体，这里选取字体大小25 font = ImageFont.truetype('simsun.ttc', 20) # xy是左上角开始的位置坐标 draw.text(xy=(18, 11), font=font, text=num, fill=(0, 0, 0)) # 随机旋转-10-10角度 random_angle = random.randint(-10, 10) im_50_rotated = im_50_blank.rotate(random_angle) # 图形扭曲参数 params = [1 - float(random.randint(1, 2)) / 100, 0, 0, 0, 1 - float(random.randint(1, 10)) / 100, float(random.randint(1, 2)) / 500, 0.001, float(random.randint(1, 2)) / 500] # 创建扭曲 im_50_transformed = im_50_rotated.transform((50, 50), Image.PERSPECTIVE, params) # 生成新的30*30空白图像 im_30 = im_50_transformed.crop([10, 10, 40, 40]) return im_30, num # 生成手写体数字1-9存入指定文件夹1-9 def generate_1to9(n): # 用cnt_num[1]-cnt_num[9]来计数数字1-9生成的个数，方便之后进行命名 cnt_num = [] for i in range(10): cnt_num.append(0) for m in range(1, n + 1): # 调用生成图像文件函数 im, generate_num = generate_single() # 取灰度 im_gray = im.convert('1') # 计数生成的数字1-9的个数,用来命名图像文件 for j in range(1, 10): if generate_num == str(j): cnt_num[j] = cnt_num[j] + 1 # 路径如 &quot;F:/code/***/P_generate_handwritten_number/data_pngs/1/1_231.png&quot; # 输出显示路径 print(&quot;Generate:&quot;, path_img + &quot;Num_&quot; + str(j) + &quot;/&quot; + str(j) + &quot;_&quot; + str(cnt_num[j]) + &quot;.png&quot;) # 将图像保存在指定文件夹中 im_gray.save(path_img + &quot;Num_&quot; + str(j) + &quot;/&quot; + str(j) + &quot;_&quot; + str(cnt_num[j]) + &quot;.png&quot;) print(&quot;\\n&quot;) # 输出显示1-9的分布 print(&quot;生成的1-9的分布：&quot;) for k in range(9): print(&quot;Num&quot;, k + 1, &quot;:&quot;, cnt_num[k + 1], &quot;in all&quot;) # generate n times # generate_1to9(1000) def main(): #删除操作 del_imgs() #生成文件夹操作 #mkdir_for_imgs() #生成数字图片操作，可以修改生成图片的数量 generate_1to9(10) main() 三、数据集与测试集 我的想法是对数据集的图片和测试集的图片分开生成，其中数据集的规模大小为1000张，测试集10张，至于测试集的数量为什么这么少，是因为在EasyDL平台需要每次自己上传测试的图片（每次一张），那就不要为难自己了嘛，就要十张~ 四、EasyDL平台训练 跟着官方的操作文档和教学视频一顿骚操作： 创建模型 上传数据 训练模型 校验模型 其中最耗费时间的就是上传处理数据，因为是官方的开放免费平台，资源投入肯定不会很大，所以训练数据的数据集处理起来慢是很正常的。 其次是训练模型，我上传了1000张0-9数字的数据集，其实不到1000张，训练了我估计应该有三四十分钟吧，模型训练完毕。 因为是同样的程序生成的数据图片，识别效果大部分还是不错的，除了一些我的眼睛都识别不太出来的。 五、实验心得 导论课还是挺有趣的，毕竟我大部分的东西都已经提前接触过了，听起来也游刃有余，对于实验，我觉得时间安排不太合适，不然我肯定会搞事情的啦，奈何期末已到，小弟渣渣复习，所以将就下吧... 对于百度的这个平台，我觉得还是不太稀奇的，因为每个大厂都有自己的API等平台，就像华为的AI平台一样，但是我的老师一直在谈论百度的，我觉得这个时候，(百度，打钱!!!)。 总结来说，心情愉快，安心复习~ ","link":"https://Wangrongsheng.github.io/post/szEW6I7Y7/"}]}